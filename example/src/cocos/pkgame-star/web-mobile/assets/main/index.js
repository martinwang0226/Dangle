System.register("chunks:///_virtual/pad.ts", ['cc'], function () {
  'use strict';

  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "0276dEUI2ZJ0IawOyDqZ25j", "pad", undefined);

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ResLoading_Ctrl.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './UIMgr.ts', './EventMgr.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, SpriteComponent, _inheritsLoose, _defineProperty, _assertThisInitialized, UICtrl, EventMgr;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      SpriteComponent = module.SpriteComponent;
    }, function (module) {
      _inheritsLoose = module.inheritsLoose;
      _defineProperty = module.defineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      UICtrl = module.UICtrl;
    }, function (module) {
      EventMgr = module.EventMgr;
    }],
    execute: function () {
      var _dec, _class, _temp;

      cclegacy._RF.push({}, "03f6cz7pHRFR6tNMxP663mJ", "ResLoading_Ctrl", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var ResLoading_Ctrl = exports('ResLoading_Ctrl', (_dec = ccclass("ResLoading_Ctrl"), _dec(_class = (_temp = /*#__PURE__*/function (_UICtrl) {
        _inheritsLoose(ResLoading_Ctrl, _UICtrl);

        function ResLoading_Ctrl() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _UICtrl.call.apply(_UICtrl, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this), "progressValue", null);

          return _this;
        }

        var _proto = ResLoading_Ctrl.prototype;

        _proto.onLoad = function onLoad() {
          _UICtrl.prototype.onLoad.call(this);

          this.progressValue = this.view["UI_progress/value"].getComponent(SpriteComponent);
          this.progressValue.fillRange = 0;
          EventMgr.Instance.AddEventListener("loadProgress", this, this.onLoaderProgress);
        };

        _proto.onLoaderProgress = function onLoaderProgress(uname, udata) {
          udata = udata > 1 ? 1 : udata;
          udata = udata < 0 ? 0 : udata;
          this.progressValue.fillRange = udata;
        };

        _proto.onDestroy = function onDestroy() {
          EventMgr.Instance.RemoveListenner("loadProgress", this, this.onLoaderProgress);
        };

        return ResLoading_Ctrl;
      }(UICtrl), _temp)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/GameConstants.ts", ['cc'], function (exports) {
  'use strict';

  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      exports({
        ArrowDirection: void 0,
        GameEnum: void 0,
        GameType: void 0,
        GridType: void 0,
        PlayerState: void 0,
        RoleType: void 0,
        RoundStatus: void 0
      });

      cclegacy._RF.push({}, "043942jVeRAdq13xgYbVF7K", "GameConstants", undefined);

      var GameEnum;

      (function (GameEnum) {
        GameEnum["EventUpdateGameStartData"] = "EventUpdateGameStartData";
        GameEnum["EventUpdateMainUIData"] = "EventUpdateMainUIData";
        GameEnum["EventPlayerPressedLeft"] = "EventPlayerPressedLeft";
        GameEnum["EventPlayerPressedRight"] = "EventPlayerPressedRight";
        GameEnum["EventPlayerPressedUp"] = "EventPlayerPressedUp";
        GameEnum["EventPlayerPressedDown"] = "EventPlayerPressedDown";
        GameEnum["EventPlayerPressedCenter"] = "EventPlayerPressedCenter";
      })(GameEnum || (GameEnum = exports('GameEnum', {})));

      var GameType;

      (function (GameType) {
        GameType[GameType["REGULAR_GAME"] = 1] = "REGULAR_GAME";
        GameType[GameType["OVERTIME_GAME"] = 2] = "OVERTIME_GAME";
      })(GameType || (GameType = exports('GameType', {})));

      var RoundStatus; //角色类型

      (function (RoundStatus) {
        RoundStatus[RoundStatus["IN_GAME"] = 1] = "IN_GAME";
        RoundStatus[RoundStatus["IN_SETTLE"] = 2] = "IN_SETTLE";
      })(RoundStatus || (RoundStatus = exports('RoundStatus', {})));

      var RoleType; //用户状态

      (function (RoleType) {
        RoleType[RoleType["UNKNOWN"] = 0] = "UNKNOWN";
        RoleType[RoleType["AUDIENCE"] = 1] = "AUDIENCE";
        RoleType[RoleType["PLAYER"] = 2] = "PLAYER";
        RoleType[RoleType["PC_PLAYER"] = 100] = "PC_PLAYER";
      })(RoleType || (RoleType = exports('RoleType', {})));

      var PlayerState;

      (function (PlayerState) {
        PlayerState[PlayerState["OFFLINE"] = 0] = "OFFLINE";
        PlayerState[PlayerState["ONLINE"] = 1] = "ONLINE";
      })(PlayerState || (PlayerState = exports('PlayerState', {})));

      var ArrowDirection;

      (function (ArrowDirection) {
        ArrowDirection[ArrowDirection["LEFT"] = 0] = "LEFT";
        ArrowDirection[ArrowDirection["UP"] = 1] = "UP";
        ArrowDirection[ArrowDirection["RIGHT"] = 2] = "RIGHT";
        ArrowDirection[ArrowDirection["DOWN"] = 3] = "DOWN";
        ArrowDirection[ArrowDirection["CENTER"] = 4] = "CENTER";
      })(ArrowDirection || (ArrowDirection = exports('ArrowDirection', {})));

      var GridType;

      (function (GridType) {
        GridType[GridType["STAR"] = 1] = "STAR";
        GridType[GridType["ROLE"] = 2] = "ROLE";
        GridType[GridType["NONE"] = 3] = "NONE";
      })(GridType || (GridType = exports('GridType', {})));

      var GAME_ID = exports('GAME_ID', "201");
      var GameCountDownTime = exports('GameCountDownTime', 10000);
      var GameWindowCountDownTime = exports('GameWindowCountDownTime', 5400);
      var RoundWindowCountDownTime = exports('RoundWindowCountDownTime', 1600);
      var TEXTURE_MODEL_PATH = exports('TEXTURE_MODEL_PATH', 'textures/player'); //贴图路径 + 模型编号 + Tex + skinId

      var SKIN_MODEL_PATH = exports('SKIN_MODEL_PATH', 'prefab/role/player'); //皮肤模型路径 + 模型编号

      var SKIN_MAT_PATH = exports('SKIN_MAT_PATH', 'prefab/roleMat/player'); //皮肤材质路径 + 皮肤模型路径 + 模型编号 + Mat + 材质编号

      var STAR_MODEL_PATH = exports('STAR_MODEL_PATH', 'prefab/star/star'); //星星模型路径

      var SKIN_ID = exports('SKIN_ID', {
        "1": "1",
        "2": "2",
        "3": "3",
        "4": "4",
        "5": "1",
        "6": "2",
        "7": "3",
        "8": "4"
      });
      var MODEL_ID = exports('MODEL_ID', {
        "1": "1",
        "2": "1",
        "3": "1",
        "4": "1",
        "5": "2",
        "6": "2",
        "7": "2",
        "8": "2"
      });
      var SoundName = exports('SoundName', {
        EFFECT_GET_SCORE: "effect_get_score",
        EFFECT_HIT_HERO: "effect_hit_hero",
        EFFECT_JUMP: "effect_jump",
        EFFECT_WIN: "effect_win",
        EFFECT_CLICK: "effect_click"
      });
      var Tips = exports('Tips', {
        tipRegStart: "获取最多星星的玩家所在队伍获胜",
        tipRegPre: "请在 ",
        tipRegRear: "s 内做出选择",
        tipRegNo: "你在本回合无需进行操作",
        tipOverTime: "触发终极盲选模式! 点击 GO 随机选择方向",
        pcTipOverTime: "触发终极盲选模式! 点击键盘 [空格键] 随机选择方向",
        tipOverTimeIn: "正在为你选择方向",
        tipPlayerChoose: "玩家正在选择"
      }); //左，上，右，下可以操作的操作按键

      var ArrowState = exports('ArrowState', {
        2: [true, false, true, true, false],
        4: [false, true, true, true, false],
        8: [true, true, true, false, false],
        6: [true, true, false, true, false]
      }); //左，上，右，下可以操作的格子idx

      var DirIdxData = exports('DirIdxData', {
        2: [1, 0, 3, 5],
        4: [0, 1, 5, 7],
        8: [7, 5, 9, 0],
        6: [5, 3, 0, 9]
      });
      var StarPosData = exports('StarPosData', {
        1: [{
          "x": 0,
          "y": 0.35,
          "z": 0.278
        }],
        2: [{
          "x": 0.172,
          "y": 0.35,
          "z": 0.5
        }, {
          "x": -0.173,
          "y": 0.35,
          "z": 0.022
        }],
        3: [{
          "x": -0.3,
          "y": 0.35,
          "z": 0.5
        }, {
          "x": 0.3,
          "y": 0.35,
          "z": 0.5
        }, {
          "x": 0,
          "y": 0.35,
          "z": -0.196
        }],
        4: [{
          "x": -0.243,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": 0.258,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": -0.237,
          "y": 0.4,
          "z": 0.033
        }, {
          "x": 0.208,
          "y": 0.4,
          "z": 0.022
        }],
        5: [{
          "x": -0.243,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": 0.258,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": -0.341,
          "y": 0.4,
          "z": 0.125
        }, {
          "x": 0.355,
          "y": 0.4,
          "z": 0.022
        }, {
          "x": -0.001,
          "y": 0.45,
          "z": -0.262
        }],
        6: [{
          "x": -0.367,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": 0.433,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": 0.01,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": -0.235,
          "y": 0.4,
          "z": 0.125
        }, {
          "x": 0.238,
          "y": 0.4,
          "z": 0.125
        }, {
          "x": -0.001,
          "y": 0.46,
          "z": -0.301
        }],
        7: [{
          "x": -0.467,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": 0.333,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": -0.067,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": -0.353,
          "y": 0.4,
          "z": 0.125
        }, {
          "x": 0.447,
          "y": 0.4,
          "z": 0.125
        }, {
          "x": 0.047,
          "y": 0.4,
          "z": 0.125
        }, {
          "x": -0.001,
          "y": 0.46,
          "z": -0.301
        }],
        8: [{
          "x": -0.467,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": 0.333,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": -0.067,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": -0.353,
          "y": 0.4,
          "z": 0.125
        }, {
          "x": 0.447,
          "y": 0.4,
          "z": 0.125
        }, {
          "x": 0.047,
          "y": 0.4,
          "z": 0.125
        }, {
          "x": 0.256,
          "y": 0.46,
          "z": -0.301
        }, {
          "x": -0.227,
          "y": 0.46,
          "z": -0.301
        }],
        9: [{
          "x": -0.467,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": 0.333,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": -0.067,
          "y": 0.4,
          "z": 0.648
        }, {
          "x": -0.467,
          "y": 0.4,
          "z": 0.125
        }, {
          "x": 0.35,
          "y": 0.4,
          "z": 0.125
        }, {
          "x": -0.05,
          "y": 0.4,
          "z": 0.125
        }, {
          "x": -0.461,
          "y": 0.46,
          "z": -0.301
        }, {
          "x": 0.339,
          "y": 0.46,
          "z": -0.301
        }, {
          "x": -0.061,
          "y": 0.46,
          "z": -0.301
        }]
      });

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/vector.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './Decimal.ts', './F.ts'], function (exports) {
  'use strict';

  var cclegacy, _defineProperty, Decimal, Fe;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      _defineProperty = module.defineProperty;
    }, function (module) {
      Decimal = module.default;
    }, function (module) {
      Fe = module.Fe;
    }],
    execute: function () {
      cclegacy._RF.push({}, "0506bbwItNPU66V2d+YdmHB", "vector", undefined);

      var Vector = exports('Vector', /*#__PURE__*/function () {
        function Vector(x, y) {
          _defineProperty(this, "x", void 0);

          _defineProperty(this, "y", void 0);

          this.x = 0;
          this.y = 0;

          if (x !== undefined && y !== undefined) {
            this.set(x, y);
          }
        } //-------------操作----------------

        /**
         * 设置值
         * @param x 
         * @param y 
         */


        var _proto = Vector.prototype;

        _proto.set = function set(x, y) {
          this.x = new Decimal(x).toNumber();
          this.y = new Decimal(y).toNumber();
        }
        /**
         * 相加
         * @param v 
         */
        ;

        _proto.add = function add(v, out) {
          out = out || new Vector();
          out.x = new Decimal(this.x).add(v.x).toNumber();
          out.y = new Decimal(this.y).add(v.y).toNumber();
          return out;
        }
        /**
         * 相减
         * @param v 
         */
        ;

        _proto.sub = function sub(v, out) {
          out = out || new Vector();
          out.x = new Decimal(this.x).sub(v.x).toNumber();
          out.y = new Decimal(this.y).sub(v.y).toNumber();
          return out;
        }
        /**
         * 点积
         * @param v 
         */
        ;

        _proto.dot = function dot(v) {
          return new Decimal(this.x).mul(v.x).add(new Decimal(this.y).mul(v.y)).toNumber();
        }
        /**
         * 叉积
         * @param v 
         */
        ;

        _proto.cro = function cro(v) {
          return new Decimal(this.x).mul(v.y).sub(new Decimal(v.x).mul(this.y)).toNumber();
        }
        /**
         * 与标量进行叉积
         * @param n
         */
        ;

        _proto.croNum = function croNum(n, out) {
          out = out || new Vector();
          out.x = new Decimal(n).mul(this.y).mul(-1).toNumber();
          out.y = new Decimal(n).mul(this.x).toNumber();
          return out;
        }
        /**
         * 投影
         * @param v 
         */
        ;

        _proto.pro = function pro(v) {
          return new Decimal(this.dot(v)).div(v.len()).toNumber();
        }
        /**
         * 法向
         */
        ;

        _proto.nor = function nor(out) {
          out = out || new Vector();
          out.x = new Decimal(this.y).toNumber();
          out.y = new Decimal(this.x).mul(-1).toNumber();
          return out;
        }
        /**
         * 求模
         */
        ;

        _proto.len = function len() {
          return Fe.hypot(this.x, this.y).toNumber();
        }
        /**
         * 平方模（节省求平方根操作）
         */
        ;

        _proto.len_s = function len_s() {
          return new Decimal(this.x).mul(this.x).add(new Decimal(this.y).mul(this.y)).toNumber();
        }
        /**
         * 单位化
         */
        ;

        _proto.nol = function nol() {
          var len = this.len();

          if (len === 0) {
            return new Vector();
          }

          this.x = new Decimal(this.x).div(len).toNumber();
          this.y = new Decimal(this.y).div(len).toNumber();
          return this;
        }
        /**
         * 缩放
         * @param n
         */
        ;

        _proto.scl = function scl(n, out) {
          out = out || new Vector();
          out.x = new Decimal(n).mul(this.x).toNumber();
          out.y = new Decimal(n).mul(this.y).toNumber();
          return out;
        }
        /**
         * 反向
         */
        ;

        _proto.inv = function inv(out) {
          out = out || new Vector();
          out.x = new Decimal(this.x).mul(-1).toNumber();
          out.y = new Decimal(this.y).mul(-1).toNumber();
          return out;
        }
        /**
         * 判断两向量是否相等
         * @param v 
         */
        ;

        _proto.eql = function eql(v) {
          return new Decimal(this.x).eq(new Decimal(v.x)) && new Decimal(this.y).eq(new Decimal(v.y));
        }
        /**
         * 求两向量夹角(弧度制)
         * @param v 
         */
        ;

        _proto.ang = function ang(v) {
          return Fe.acos(new Decimal(this.dot(v)).div(this.len()).mul(v.len()).toNumber()).toNumber();
        }
        /**
         * 克隆向量
         */
        ;

        _proto.col = function col() {
          return new Vector(this.x, this.y);
        }
        /**
         * 绕某点旋转向量
         * @param radian 角度（弧度制）
         * @param point 绕的点
         */
        ;

        _proto.rot = function rot(radian, point, out) {
          out = out || new Vector();
          var cos = Fe.cos(radian).toNumber(),
              sin = Fe.sin(radian).toNumber(),
              dx = new Decimal(this.x).sub(point.x).toNumber(),
              dy = new Decimal(this.y).sub(point.y).toNumber();
          out.x = new Decimal(dx).mul(cos).sub(new Decimal(dy).mul(sin)).add(point.x).toNumber();
          out.y = new Decimal(dx).mul(sin).add(new Decimal(dy).mul(cos)).add(point.y).toNumber();
          return out;
        }
        /**
         * 求一个向量（点）按照direction方向，延长len长度后的坐标
         * @param direction
         * @param len 
         */
        ;

        _proto.loc = function loc(direction, len, out) {
          out = out || new Vector();
          direction = direction.nol();
          out.x = new Decimal(direction.x).mul(len).add(this.x).toNumber();
          out.y = new Decimal(direction.y).mul(len).add(this.y).toNumber();
          return out;
        };

        return Vector;
      }());

      var _tempVector1 = exports('_tempVector1', new Vector());

      var _tempVector2 = exports('_tempVector2', new Vector());

      var _tempVector3 = exports('_tempVector3', new Vector());

      var _tempVector4 = exports('_tempVector4', new Vector());

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PoolMgr.ts", ['cc', './_rollupPluginModLoBabelHelpers.js'], function (exports) {
  'use strict';

  var cclegacy, _decorator, instantiate, NodePool, _defineProperty, _createClass;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      instantiate = module.instantiate;
      NodePool = module.NodePool;
    }, function (module) {
      _defineProperty = module.defineProperty;
      _createClass = module.createClass;
    }],
    execute: function () {
      var _dec, _class, _class2, _temp;

      cclegacy._RF.push({}, "0682ajJvP5NJIuJM4Y/y4wD", "PoolMgr", undefined);

      var ccclass = _decorator.ccclass;
      var PoolManager = exports('PoolManager', (_dec = ccclass("PoolManager"), _dec(_class = (_temp = _class2 = /*#__PURE__*/function () {
        function PoolManager() {
          _defineProperty(this, "_dictPool", {});

          _defineProperty(this, "_dictPrefab", {});
        }

        var _proto = PoolManager.prototype;
        /**
         * 根据预设从对象池中获取对应节点
         */

        _proto.getNode = function getNode(prefab, parent) {
          var name = prefab.name; //@ts-ignore

          if (!prefab.position) {
            //@ts-ignore
            name = prefab.data.name;
          }

          this._dictPrefab[name] = prefab;
          var node = null;

          if (this._dictPool.hasOwnProperty(name)) {
            //已有对应的对象池
            var pool = this._dictPool[name];

            if (pool.size() > 0) {
              node = pool.get();
            } else {
              node = instantiate(prefab);
            }
          } else {
            //没有对应对象池，创建他！
            var _pool = new NodePool();

            this._dictPool[name] = _pool;
            node = instantiate(prefab);
          }

          node.parent = parent;
          node.active = true;
          return node;
        }
        /**
         * 将对应节点放回对象池中
         */
        ;

        _proto.putNode = function putNode(node) {
          if (!node) {
            return;
          }

          var name = node.name;
          var pool = null;

          if (this._dictPool.hasOwnProperty(name)) {
            //已有对应的对象池
            pool = this._dictPool[name];
          } else {
            //没有对应对象池，创建他！
            pool = new NodePool();
            this._dictPool[name] = pool;
          }

          pool.put(node);
        }
        /**
         * 根据名称，清除对应对象池
         */
        ;

        _proto.clearPool = function clearPool(name) {
          if (this._dictPool.hasOwnProperty(name)) {
            var pool = this._dictPool[name];
            pool.clear();
          }
        }
        /**
         * 预生成对象池
         * @param prefab 
         * @param nodeNum 
         */
        ;

        _proto.prePool = function prePool(prefab, nodeNum) {
          var name = prefab.name;
          var pool = new NodePool();
          this._dictPool[name] = pool;

          for (var i = 0; i < nodeNum; i++) {
            var node = instantiate(prefab);
            pool.put(node);
          }
        };

        _createClass(PoolManager, null, [{
          key: "Instance",
          get: function get() {
            if (this._instance) {
              return this._instance;
            }

            this._instance = new PoolManager();
            return this._instance;
          }
        }]);

        return PoolManager;
      }(), _defineProperty(_class2, "_instance", void 0), _temp)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AudioManager.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './ResourceUtil.ts', './lodash.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, Node, director, game, AudioSource, AudioClip, _defineProperty, _createClass, ResourceUtil, lodash;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      director = module.director;
      game = module.game;
      AudioSource = module.AudioSource;
      AudioClip = module.AudioClip;
    }, function (module) {
      _defineProperty = module.defineProperty;
      _createClass = module.createClass;
    }, function (module) {
      ResourceUtil = module.ResourceUtil;
    }, function (module) {
      lodash = module.lodash;
    }],
    execute: function () {
      var _dec, _class, _class2, _temp;

      cclegacy._RF.push({}, "0b89dfOrUlLqqTVNPYq2IzE", "AudioManager", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var AudioManager = exports('AudioManager', (_dec = ccclass("AudioManager"), _dec(_class = (_temp = _class2 = /*#__PURE__*/function () {
        function AudioManager() {
          _defineProperty(this, "_persistRootNode", null);

          _defineProperty(this, "_audioSources", []);

          _defineProperty(this, "dictWeaponSoundIndex", {});

          _defineProperty(this, "musicVolume", 0.8);

          _defineProperty(this, "soundVolume", 1);

          _defineProperty(this, "audios", {});

          _defineProperty(this, "arrSound", []);
        }

        var _proto = AudioManager.prototype;

        _proto.init = function init() {
          if (this._persistRootNode) return; //避免切换场景初始化报错

          this._persistRootNode = new Node('audio');
          director.getScene().addChild(this._persistRootNode);
          game.addPersistRootNode(this._persistRootNode); // this.musicVolume = this.getAudioSetting(true) ? 0.8: 0;
          // this.soundVolume = this.getAudioSetting(false) ? 1 : 0;

          var musicState = this.getAudioSetting(true);
          var soundState = this.getAudioSetting(false);
          var isPlayAudio = true;

          if (window.jsb) {
            //获取安卓是否可以播放音乐，例如打电话时候音乐关闭
            isPlayAudio = jsb.reflection.callStaticMethod('com/cocos/game/AppActivity', 'isPlayAudio', '()Z');
          }

          this.musicVolume = isPlayAudio && musicState ? 0.8 : 0;
          this.soundVolume = isPlayAudio && soundState ? 1 : 0;
        };

        _proto._getAudioSource = function _getAudioSource(clip) {
          var result;

          for (var i = 0; i < this._audioSources.length; ++i) {
            var audioSource = this._audioSources[i];

            if (!audioSource.playing) {
              result = audioSource;
              break;
            }
          }

          if (!result) {
            result = this._persistRootNode.addComponent(AudioSource);

            this._audioSources.push(result);
          }

          result.node.off(AudioSource.EventType.ENDED);
          result.clip = clip;
          result.currentTime = 0;
          return result;
        };

        _proto.getAudioSetting = function getAudioSetting(isMusic) {
          return true;
        }
        /**
         * 播放音乐
         * @param {String} name 音乐名称可通过constants.AUDIO_MUSIC 获取
         * @param {Boolean} loop 是否循环播放
         */
        ;

        _proto.playMusic = function playMusic(name, loop) {
          var _this = this;

          var path = 'audio/music/' + name; //微信特殊处理，除一开场的音乐，其余的放在子包里头
          // if (name !== 'click') {
          //     path =  path; //微信特殊处理，除一开场的音乐，其余的放在子包里头
          // }

          ResourceUtil.loadRes(path, AudioClip, function (err, clip) {
            var source = _this._getAudioSource(clip);

            var tmp = {
              source: source,
              isMusic: true
            };
            _this.audios[name] = tmp;
            source.volume = _this.musicVolume;
            source.loop = loop;
            source.play();
          });
        }
        /**
         * 播放音效
         * @param {String} name 音效名称可通过constants.AUDIO_SOUND 获取
         * @param {Boolean} loop 是否循环播放
         */
        ;

        _proto.playSound = function playSound(name, loop) {
          var _this2 = this;

          if (loop === void 0) {
            loop = false;
          }

          if (!this.soundVolume) {
            return;
          } //音效一般是多个的，不会只有一个


          var path = 'sounds/'; // if (name !== 'click') {
          //     path = path; //微信特殊处理，除一开场的音乐，其余的放在子包里头
          // }

          ResourceUtil.loadRes(path + name, AudioClip, function (err, clip) {
            var source = _this2._getAudioSource(clip);

            var tmp = {
              source: source,
              isMusic: false
            };

            _this2.arrSound.push(tmp);

            if (loop) {
              _this2.audios[name] = tmp;
            }

            source.volume = _this2.soundVolume;
            source.loop = loop;
            source.play();
            source.node.on(AudioSource.EventType.ENDED, function () {
              lodash.remove(_this2.arrSound, function (obj) {
                return obj.source === tmp.source;
              });
            });
          });
        };

        _proto.stop = function stop(name) {
          if (this.audios.hasOwnProperty(name)) {
            var audio = this.audios[name];
            audio.source.stop();
          }
        };

        _proto.stopAll = function stopAll() {
          for (var i in this.audios) {
            if (this.audios.hasOwnProperty(i)) {
              var audio = this.audios[i];
              audio.source.stop();
            }
          }
        };

        _proto.getMusicVolume = function getMusicVolume() {
          return this.musicVolume;
        };

        _proto.setMusic = function setMusic(flag) {
          this.musicVolume = flag;

          for (var item in this.audios) {
            if (this.audios.hasOwnProperty(item) && this.audios[item].isMusic) {
              // this.changeState(item, flag);
              var audio = this.audios[item];
              audio.source.volume = this.musicVolume;
            }
          }
        } //看广告时先将音乐暂停
        ;

        _proto.pauseAll = function pauseAll() {
          console.log("pause all music!!!");

          for (var item in this.audios) {
            if (this.audios.hasOwnProperty(item)) {
              var audio = this.audios[item];
              audio.source.pause();
            }
          }
        };

        _proto.resumeAll = function resumeAll() {
          for (var item in this.audios) {
            if (this.audios.hasOwnProperty(item)) {
              var audio = this.audios[item];
              audio.source.play();
            }
          }
        };

        _proto.openMusic = function openMusic() {
          this.setMusic(0.8);
        };

        _proto.closeMusic = function closeMusic() {
          this.setMusic(0);
        };

        _proto.openSound = function openSound() {
          this.setSound(1);
        };

        _proto.closeSound = function closeSound() {
          this.setSound(0);
        };

        _proto.setSound = function setSound(flag) {
          this.soundVolume = flag;

          for (var item in this.audios) {
            if (this.audios.hasOwnProperty(item) && !this.audios[item].isMusic) {
              // this.changeState(item, flag);
              var audio = this.audios[item];
              audio.source.volume = this.soundVolume;
            }
          }

          for (var idx = 0; idx < this.arrSound.length; idx++) {
            var _audio = this.arrSound[idx];
            _audio.source.volume = this.soundVolume;
          }
        };

        _proto.stopSingleSound = function stopSingleSound(name) {
          if (this.audios.hasOwnProperty(name) && !this.audios[name].isMusic) {
            var audio = this.audios[name];
            audio.source.stop();
          }
        };

        _createClass(AudioManager, null, [{
          key: "Instance",
          get: function get() {
            if (this._instance) {
              return this._instance;
            }

            this._instance = new AudioManager();
            return this._instance;
          }
        }]);

        return AudioManager;
      }(), _defineProperty(_class2, "_instance", void 0), _temp)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MyCylinderCollider.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './ColliderBase.ts'], function (exports) {
  'use strict';

  var cclegacy, Vec3, math, _inheritsLoose, CollisionInfo, ColliderBase;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Vec3 = module.Vec3;
      math = module.math;
    }, function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      CollisionInfo = module.CollisionInfo;
      ColliderBase = module.ColliderBase;
    }],
    execute: function () {
      cclegacy._RF.push({}, "0bb43V7reFDJ5N4WYM5aAjS", "MyCylinderCollider", undefined);
      /**
       * @Author: liubeizhang
       * @Date: 2021-08-23 10:46:00 
       * 胶囊体碰撞体
       */


      var MyCylinderCollider = exports('MyCylinderCollider', /*#__PURE__*/function (_ColliderBase) {
        _inheritsLoose(MyCylinderCollider, _ColliderBase);

        function MyCylinderCollider(cfg) {
          var _this;

          _this = _ColliderBase.call(this) || this;
          _this.name = cfg.mName;
          _this.mPos = cfg.mPos;
          _this.mRadius = cfg.mRadius;
          return _this;
        } //计算碰撞


        var _proto = MyCylinderCollider.prototype;

        _proto.CalcCollidersInteraction = function CalcCollidersInteraction(colliders, velocity, borderAdjust) {
          if (velocity == Vec3.ZERO) {
            return;
          }

          var collisionInfoLst = [];
          var normal = Vec3.ZERO;
          var adj = Vec3.ZERO;

          for (var i = 0; i < this.colliders.length; i++) {
            if (this.DetectContact(this.colliders[i], normal, adj)) {
              var info = new CollisionInfo(this.colliders[i], normal, adj);
              collisionInfoLst.push(info);
            }
          }

          if (collisionInfoLst.length == 1) {
            //单个碰撞体，修正速度
            var _info = collisionInfoLst[0];
            velocity = this.CorrectVelocity(velocity, _info.normal);
            borderAdjust = _info.bordersAdjust;
          } else if (collisionInfoLst.length > 1) {
            //多个碰撞体，修改速度
            var centerNormal = Vec3.ZERO;
            var _info2 = null;
            var borderNormalAngle = this.CaclMaxNormalAngle(collisionInfoLst, velocity, centerNormal, _info2);
            var angle = Vec3.angle(velocity.multiplyScalar(-1), centerNormal);

            if (angle > borderNormalAngle) {
              velocity = this.CorrectVelocity(velocity, _info2.normal);
              var adjSum = Vec3.ZERO;

              for (var _i = 0; _i < collisionInfoLst.length; _i++) {
                adjSum.add(collisionInfoLst[_i].bordersAdjust);
              }

              borderAdjust = adjSum;
            } else {
              velocity = Vec3.ZERO;
            }
          } else {
            //没有碰撞
            console.log("没有碰撞");
          }
        } //计算多个碰撞时最大法线角度
        ;

        _proto.CaclMaxNormalAngle = function CaclMaxNormalAngle(infoLst, velocity, centerNormal, info) {
          for (var i = 0; i < infoLst.length; i++) {
            centerNormal.add(infoLst[i].normal);
          }

          centerNormal.x = centerNormal.x / infoLst.length;
          centerNormal.y = centerNormal.y / infoLst.length;
          centerNormal.z = centerNormal.z / infoLst.length;
          var normalAngle = 0;
          var velocityAngle = 0;

          for (var _i2 = 0; _i2 < infoLst.length; _i2++) {
            var tmpAngle = Vec3.angle(centerNormal, infoLst[_i2].normal);

            if (tmpAngle > normalAngle) {
              normalAngle = tmpAngle;
            } //找出速度方向与法线方向上夹角最大的碰撞法线，速度校正由这个法线来决定


            var tmpVelocityAngle = Vec3.angle(centerNormal, infoLst[_i2].normal);

            if (tmpVelocityAngle > velocityAngle) {
              velocityAngle = tmpVelocityAngle;
              info = infoLst[_i2];
            }
          }

          return normalAngle;
        } //修正速度
        ;

        _proto.CorrectVelocity = function CorrectVelocity(velocity, normal) {
          if (normal == Vec3.ZERO) {
            return velocity;
          } //确保是靠近，不是远离


          if (Vec3.angle(normal, velocity) > Math.PI / 2) {
            var prjLen = Vec3.dot(velocity, normal);

            if (prjLen !== 0) {
              velocity.subtract(normal.multiplyScalar(prjLen));
            }
          }

          return velocity;
        };

        _proto.DetectBoxContact = function DetectBoxContact(col, normal, bordersAdjust) {
          //计算矩形物体到胶囊体圆心的向量
          var disoffset = new Vec3();
          Vec3.subtract(disoffset, this.mPos, col.mPos); //通过点乘计算胶囊体不同轴向上的投影

          var dot_disx = Vec3.dot(disoffset, col.mDir[0]);
          var dot_disy = Vec3.dot(disoffset, col.mDir[1]);
          var dot_disz = Vec3.dot(disoffset, col.mDir[2]); //投影钳制在x轴向，y轴向，z轴向里面，这样的话就可以计算临界点位置

          dot_disx = math.clamp(dot_disx, -col.mSize.x, col.mSize.x);
          dot_disy = math.clamp(dot_disy, -col.mSize.y, col.mSize.y);
          dot_disz = math.clamp(dot_disz, -col.mSize.z, col.mSize.z); //计算轴向上的投影向量

          var s_x = new Vec3();
          Vec3.multiplyScalar(s_x, col.mDir[0], dot_disx);
          var s_y = new Vec3();
          Vec3.multiplyScalar(s_y, col.mDir[1], dot_disy);
          var s_z = new Vec3();
          Vec3.multiplyScalar(s_z, col.mDir[2], dot_disz); //计算表面最近的接触点，碰撞体中心位置+轴向偏移

          var point = col.mPos;
          Vec3.add(point, point, s_x);
          Vec3.add(point, point, s_y);
          Vec3.add(point, point, s_z);
          var po = new Vec3();
          Vec3.subtract(po, this.mPos, point);

          if (Vec3.squaredDistance(po, po) > this.mRadius * this.mRadius) {
            //没有相交
            return false;
          } else {
            //相交，得出法线向量和长度
            normal = po.normalize();
            var len = po.length();
            bordersAdjust = normal.multiplyScalar(this.mRadius - len);
            return true;
          }
        };

        _proto.DetectSphereContact = function DetectSphereContact(col, normal, bordersAdjust) {
          var disoffset = new Vec3();
          Vec3.subtract(disoffset, this.mPos, col.mPos);

          if (Vec3.squaredDistance(disoffset, disoffset) > (this.mRadius + col.mRadius) * (this.mRadius + col.mRadius)) {
            return false;
          } else {
            normal = disoffset.normalize();
            bordersAdjust = normal.multiplyScalar(this.mRadius + col.mRadius - disoffset.length());
            return true;
          }
        };

        return MyCylinderCollider;
      }(ColliderBase));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PlayerCtrl.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './GameConstants.ts', './AudioManager.ts', './BridgeMgr.ts', './EffectManager.ts', './GameApp.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, Node, SkeletalAnimation, math, Vec3, Quat, v3, tween, Tween, Component, _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _defineProperty, ArrowState, ArrowDirection, SoundName, AudioManager, BridgeMgr, EffectManager, GameApp;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      SkeletalAnimation = module.SkeletalAnimation;
      math = module.math;
      Vec3 = module.Vec3;
      Quat = module.Quat;
      v3 = module.v3;
      tween = module.tween;
      Tween = module.Tween;
      Component = module.Component;
    }, function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _defineProperty = module.defineProperty;
    }, function (module) {
      ArrowState = module.ArrowState;
      ArrowDirection = module.ArrowDirection;
      SoundName = module.SoundName;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      BridgeMgr = module.BridgeMgr;
    }, function (module) {
      EffectManager = module.EffectManager;
    }, function (module) {
      GameApp = module.GameApp;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor, _descriptor2, _temp;

      cclegacy._RF.push({}, "17603d52E1Nw5UZlOTETYdZ", "PlayerCtrl", undefined);

      var ccclass = _decorator.ccclass,
          integer = _decorator.integer,
          property = _decorator.property;
      var AnimationState = {
        IDLE: "daiji",
        IDLE2: "daiji.002",
        DAOXIA: "daoxia",
        DOWN: "down",
        JUMP: "jump",
        HAPPY: "kaixin"
      };
      var PlayerCtrl = exports('PlayerCtrl', (_dec = ccclass('PlayerCtrl'), _dec2 = property({
        type: Node,
        displayName: ''
      }), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function (_Component) {
        _inheritsLoose(PlayerCtrl, _Component);

        function PlayerCtrl() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_assertThisInitialized(_this), "idx", _descriptor, _assertThisInitialized(_this));

          _defineProperty(_assertThisInitialized(_this), "uid", "");

          _defineProperty(_assertThisInitialized(_this), "startPos", null);

          _defineProperty(_assertThisInitialized(_this), "startRotate", null);

          _defineProperty(_assertThisInitialized(_this), "floorDuration", 0.2);

          _defineProperty(_assertThisInitialized(_this), "rotateDuration", 0.3);

          _defineProperty(_assertThisInitialized(_this), "rotateBackDuration", 0.3);

          _defineProperty(_assertThisInitialized(_this), "prepareDuration", 0.16);

          _defineProperty(_assertThisInitialized(_this), "jumpUpDuration", 0.2);

          _defineProperty(_assertThisInitialized(_this), "jumpDownDuration", 0.22);

          _defineProperty(_assertThisInitialized(_this), "daoxiaDuration", 0.7);

          _defineProperty(_assertThisInitialized(_this), "jumpHeight", 0.7);

          _defineProperty(_assertThisInitialized(_this), "isHitted", false);

          _initializerDefineProperty(_assertThisInitialized(_this), "startFloor", _descriptor2, _assertThisInitialized(_this));

          _defineProperty(_assertThisInitialized(_this), "currentFloor", null);

          _defineProperty(_assertThisInitialized(_this), "sa", null);

          _defineProperty(_assertThisInitialized(_this), "arrowNode", null);

          return _this;
        }

        var _proto = PlayerCtrl.prototype;

        _proto.onLoad = function onLoad() {
          var _this$node$getChildBy;

          this.startPos = this.node.getWorldPosition();
          this.startRotate = this.node.getWorldRotation();
          var model = (_this$node$getChildBy = this.node.getChildByName("aniNode")) === null || _this$node$getChildBy === void 0 ? void 0 : _this$node$getChildBy.children[0];
          this.sa = model === null || model === void 0 ? void 0 : model.getComponent(SkeletalAnimation);
          this.arrowNode = this.node.getChildByName("arrowNode");
          this.arrowNode.active = false;
        };

        _proto.init = function init() {
          this.currentFloor = null;
          this.isHitted = false;
          this.initArrowState();
        };

        _proto.initArrowState = function initArrowState() {
          if (this.arrowNode) {
            this.arrowNode.active = false;
            this.arrowNode.children[0].active = ArrowState[this.idx][0];
            this.arrowNode.children[1].active = ArrowState[this.idx][1];
            this.arrowNode.children[2].active = ArrowState[this.idx][2];
            this.arrowNode.children[3].active = ArrowState[this.idx][3];
          }
        };

        _proto.updateArrowState = function updateArrowState(dir) {
          this.arrowNode.active = true;
          this.arrowNode.children[0].active = dir == ArrowDirection.LEFT ? true : false;
          this.arrowNode.children[1].active = dir == ArrowDirection.UP ? true : false;
          this.arrowNode.children[2].active = dir == ArrowDirection.RIGHT ? true : false;
          this.arrowNode.children[3].active = dir == ArrowDirection.DOWN ? true : false;
        };

        _proto.runIdleAnimation = function runIdleAnimation() {
          this.sa && this.sa.stop();
          var idx = Math.floor(math.random() * 2);
          var state = idx == 0 ? AnimationState.IDLE : AnimationState.IDLE2;
          this.sa && this.sa.play(state);
        };

        _proto.runWinAnimation = function runWinAnimation() {
          var _this2 = this;

          this.sa && this.sa.stop();
          this.sa && this.sa.play(AnimationState.HAPPY);
          this.scheduleOnce(function () {
            _this2.sa && _this2.sa.stop();
            _this2.sa && _this2.sa.play(AnimationState.IDLE);
          }, 2);
          this.showWinEffect();
        };

        _proto.runFailAnimation = function runFailAnimation() {
          var _this3 = this;

          this.sa && this.sa.stop();
          this.sa && this.sa.play(AnimationState.DOWN);
          this.scheduleOnce(function () {
            _this3.sa && _this3.sa.stop();
            _this3.sa && _this3.sa.play(AnimationState.IDLE);
          }, 2);
        };

        _proto.rotateBack = function rotateBack() {
          var _this4 = this;

          var targetPos = new Vec3(this.node.worldPosition.x, this.node.worldPosition.y, this.node.worldPosition.z + 5);
          var dir = targetPos.subtract(this.node.worldPosition).normalize();
          var quat_start = new Quat();
          this.node.getRotation(quat_start);
          var quat_end = new Quat();
          var quat_now = new Quat();
          Quat.fromViewUp(quat_end, dir, v3(0, 1, 0));
          tween(this.node).to(this.rotateBackDuration, {}, {
            onUpdate: function onUpdate(target, ratio) {
              // 这里使用球面插值，旋转时不会出现变形
              quat_now.set(quat_start).slerp(quat_end, ratio);

              _this4.node.setRotation(quat_now);
            },
            onComplete: function onComplete() {}
          }).start();
        };

        _proto.backToStartFloor = function backToStartFloor() {
          this.jumpToDest(this.startFloor, false, this.rotateBack.bind(this));
        };

        _proto.checkHitted = function checkHitted(targetFloor) {
          this.isHitted = true;
        };

        _proto.jumpToDest = function jumpToDest(targetFloor, isHitted, cb) {
          var _this5 = this;

          if (cb === void 0) {
            cb = null;
          } // if (this.currentFloor == targetFloor)
          //     return;


          this.currentFloor = targetFloor;
          this.isHitted = isHitted;
          var pos = targetFloor.getWorldPosition();
          var targetPos = new Vec3(pos.x, this.node.worldPosition.y, pos.z);
          var dir = targetPos.subtract(this.node.worldPosition).normalize();
          var quat_start = new Quat();
          this.node.getRotation(quat_start);
          var quat_end = new Quat();
          var quat_now = new Quat();
          Quat.fromViewUp(quat_end, dir.normalize(), v3(0, 1, 0));
          tween(this.node).to(this.rotateDuration, {}, {
            onUpdate: function onUpdate(target, ratio) {
              // 这里使用球面插值，旋转时不会出现变形
              quat_now.set(quat_start).slerp(quat_end, ratio);

              _this5.node.setRotation(quat_now);
            },
            onComplete: function onComplete() {
              var endPos = new Vec3(targetFloor.position.x, targetFloor.position.y + 0.1, targetFloor.position.z);
              var distance = Vec3.distance(_this5.node.position, endPos);

              var _tempMidX = dir.x * distance * 0.5;

              var _tempMidY = dir.y * distance * 0.5;

              var _tempMidZ = dir.z * distance * 0.5;

              var middlePoint = new Vec3(_tempMidX, _tempMidY, _tempMidZ);
              middlePoint.x += _this5.node.position.x;
              middlePoint.y += _this5.node.position.y;
              middlePoint.y += _this5.jumpHeight;
              middlePoint.z += _this5.node.position.z;
              _this5.sa && _this5.sa.stop();
              _this5.sa && _this5.sa.play(AnimationState.JUMP);

              if (_this5.isHitted) {
                _this5.onHitted();
              } else {
                _this5.scheduleOnce(function () {
                  _this5.sa && _this5.sa.stop();
                  _this5.sa && _this5.sa.play(AnimationState.IDLE);
                }, 1);
              }

              var jumpBefore = tween(_this5.node).to(_this5.prepareDuration, {
                position: _this5.node.position
              }); //上升

              var jumpUp = tween(_this5.node).to(_this5.jumpUpDuration, {
                position: middlePoint
              }).call(function () {
                if (_this5.isHitted) {
                  _this5.showOnHittedEffect(targetFloor.worldPosition);
                }
              }); // 下落

              var jumpDown = tween(_this5.node).to(_this5.jumpDownDuration, {
                position: endPos
              });

              var _tween = tween().sequence(jumpBefore, jumpUp, jumpDown);

              tween(_this5.node).then(_tween).call(function () {
                AudioManager.Instance.playSound(SoundName.EFFECT_JUMP); // SoundMgr.Instance.play_effect(SoundName.EFFECT_JUMP);

                _this5.showJumpDownEffect(targetFloor);

                Tween.stopAllByTarget(targetFloor);
                targetFloor.scale = v3(1, 1, 1);
                tween(targetFloor).to(_this5.floorDuration, {
                  scale: new Vec3(targetFloor.scale.x * 1.1, targetFloor.scale.y * 1.1, targetFloor.scale.z * 1.1) // position: new Vec3(targetFloor.position.x, targetFloor.position.y - 0.15, targetFloor.position.z),

                }, {
                  easing: 'bounceInOut'
                }).to(_this5.floorDuration, {
                  scale: new Vec3(targetFloor.scale.x, targetFloor.scale.y, targetFloor.scale.z) // position: new Vec3(targetFloor.position.x, targetFloor.position.y, targetFloor.position.z),

                }, {
                  easing: 'elasticOut'
                }).start();
                if (cb) cb();
              }).start();
            }
          }).start();
        };

        _proto.jump = function jump() {
          var _this6 = this;

          var targetFloor = this.startFloor;
          var pos = targetFloor.getWorldPosition();
          var targetPos = new Vec3(pos.x, this.node.worldPosition.y, pos.z);
          var dir = targetPos.subtract(this.node.worldPosition).normalize();
          var endPos = new Vec3(targetFloor.position.x, targetFloor.position.y + 0.1, targetFloor.position.z);
          var distance = Vec3.distance(this.node.position, endPos);

          var _tempMidX = dir.x * distance * 0.5;

          var _tempMidY = dir.y * distance * 0.5;

          var _tempMidZ = dir.z * distance * 0.5;

          var middlePoint = new Vec3(_tempMidX, _tempMidY, _tempMidZ);
          middlePoint.x += this.node.position.x;
          middlePoint.y += this.node.position.y;
          middlePoint.y += this.jumpHeight;
          middlePoint.z += this.node.position.z;
          this.sa && this.sa.stop();
          this.sa && this.sa.play(AnimationState.JUMP);
          this.scheduleOnce(function () {
            _this6.sa && _this6.sa.stop();
            _this6.sa && _this6.sa.play(AnimationState.IDLE);
          }, 1);
          var jumpBefore = tween(this.node).to(this.prepareDuration, {
            position: this.node.position
          }); //上升

          var jumpUp = tween(this.node).to(this.jumpUpDuration, {
            position: middlePoint
          }); // 下落

          var jumpDown = tween(this.node).to(this.jumpDownDuration, {
            position: endPos
          });

          var _tween = tween().sequence(jumpBefore, jumpUp, jumpDown);

          tween(this.node).then(_tween).call(function () {
            AudioManager.Instance.playSound(SoundName.EFFECT_JUMP);

            _this6.showJumpDownEffect(targetFloor);

            Tween.stopAllByTarget(targetFloor);
            targetFloor.scale = v3(1, 1, 1);
            tween(targetFloor).to(_this6.floorDuration, {
              scale: new Vec3(targetFloor.scale.x * 1.1, targetFloor.scale.y * 1.1, targetFloor.scale.z * 1.1) // position: new Vec3(targetFloor.position.x, targetFloor.position.y - 0.15, targetFloor.position.z),

            }, {
              easing: 'bounceInOut'
            }).to(_this6.floorDuration, {
              scale: new Vec3(targetFloor.scale.x, targetFloor.scale.y, targetFloor.scale.z) // position: new Vec3(targetFloor.position.x, targetFloor.position.y, targetFloor.position.z),

            }, {
              easing: 'elasticOut'
            }).start();
          }).start();
        };

        _proto.showJumpDownEffect = function showJumpDownEffect(floorNode) {
          EffectManager.Instance.playEffect("yan", floorNode.getWorldPosition());
        };

        _proto.showOnHittedEffect = function showOnHittedEffect(pos) {
          EffectManager.Instance.playEffect("boom", pos); // EffectManager.Instance.playEffect("huode", this.node.getWorldPosition());
        };

        _proto.showWinEffect = function showWinEffect() {
          EffectManager.Instance.playEffect("caidai2", this.node.getWorldPosition());
        };

        _proto.showHuodeEffect = function showHuodeEffect() {
          EffectManager.Instance.playEffect("huode", this.node.getWorldPosition());
        };

        _proto.onHitted = function onHitted() {
          var _this7 = this;

          this.currentFloor = this.startFloor;
          var delayTime = this.prepareDuration + this.jumpUpDuration + this.jumpDownDuration;
          if (this.idx == 2 || this.idx == 8) ;
          this.scheduleOnce(function () {
            if (_this7.uid == GameApp.Instance.data.uId) {
              //调用震动事件桥
              BridgeMgr.Instance.shakeDevice("long");
              AudioManager.Instance.playSound(SoundName.EFFECT_HIT_HERO);
            }

            tween(_this7.node).to(_this7.daoxiaDuration, {
              worldPosition: _this7.startPos
            }).start();
            _this7.sa && _this7.sa.stop();
            _this7.sa && _this7.sa.play(AnimationState.DAOXIA); // sa.getState("daoxia2").repeatCount = 1;
            // sa.getState("daoxia2").wrapMode = AnimationClip.WrapMode.Loop;

            _this7.scheduleOnce(function () {
              _this7.isHitted = false;

              _this7.runFailAnimation(); // this.sa && this.sa.stop();
              // this.sa && this.sa.play(AnimationState.IDLE);
              // sa.getState("daiji").wrapMode = AnimationClip.WrapMode.Loop;

            }, 2);

            _this7.scheduleOnce(_this7.rotateBack.bind(_this7), 1.1);
          }, delayTime);
        };

        return PlayerCtrl;
      }(Component), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "idx", [integer], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "startFloor", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PlayerBottomUI_Ctrl.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './index.cjs.js', './index.cjs.mjs_cjs=&original=.js', './UIMgr.ts', './EventMgr.ts', './GameConstants.ts', './AudioManager.ts', './BridgeMgr.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, LabelComponent, sys, sp, Sprite, Button, math, _inheritsLoose, _defineProperty, _assertThisInitialized, _cjsExports, UICtrl, EventMgr, Tips, ArrowState, SoundName, GameEnum, AudioManager, BridgeMgr;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      LabelComponent = module.LabelComponent;
      sys = module.sys;
      sp = module.sp;
      Sprite = module.Sprite;
      Button = module.Button;
      math = module.math;
    }, function (module) {
      _inheritsLoose = module.inheritsLoose;
      _defineProperty = module.defineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      _cjsExports = module.default;
    }, null, function (module) {
      UICtrl = module.UICtrl;
    }, function (module) {
      EventMgr = module.EventMgr;
    }, function (module) {
      Tips = module.Tips;
      ArrowState = module.ArrowState;
      SoundName = module.SoundName;
      GameEnum = module.GameEnum;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      BridgeMgr = module.BridgeMgr;
    }],
    execute: function () {
      var _dec, _class, _temp;

      cclegacy._RF.push({}, "1a438GvfNJOeocJm3dGfpwf", "PlayerBottomUI_Ctrl", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var Logger = _cjsExports.Logger;
      var PlayerBottomUI_Ctrl = exports('PlayerBottomUI_Ctrl', (_dec = ccclass('PlayerBottomUI_Ctrl'), _dec(_class = (_temp = /*#__PURE__*/function (_UICtrl) {
        _inheritsLoose(PlayerBottomUI_Ctrl, _UICtrl);

        function PlayerBottomUI_Ctrl() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _UICtrl.call.apply(_UICtrl, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this), "settleData", null);

          _defineProperty(_assertThisInitialized(_this), "isOverTimeAnimating", false);

          _defineProperty(_assertThisInitialized(_this), "rotateSpeed", 0.1);

          _defineProperty(_assertThisInitialized(_this), "currentSpeed", 0);

          _defineProperty(_assertThisInitialized(_this), "currentBtnIdx", 0);

          _defineProperty(_assertThisInitialized(_this), "nextBtnIdx", 0);

          _defineProperty(_assertThisInitialized(_this), "endBtnIdx", -1);

          _defineProperty(_assertThisInitialized(_this), "isFinalRotate", false);

          _defineProperty(_assertThisInitialized(_this), "currentNo", 10);

          _defineProperty(_assertThisInitialized(_this), "isLeftShow", false);

          _defineProperty(_assertThisInitialized(_this), "isRightShow", false);

          _defineProperty(_assertThisInitialized(_this), "isUpShow", false);

          _defineProperty(_assertThisInitialized(_this), "isDownShow", false);

          _defineProperty(_assertThisInitialized(_this), "isCenterShow", false);

          _defineProperty(_assertThisInitialized(_this), "playerTipLabel", null);

          _defineProperty(_assertThisInitialized(_this), "tipLabel", null);

          _defineProperty(_assertThisInitialized(_this), "btnUp", null);

          _defineProperty(_assertThisInitialized(_this), "btnDown", null);

          _defineProperty(_assertThisInitialized(_this), "btnLeft", null);

          _defineProperty(_assertThisInitialized(_this), "btnRight", null);

          _defineProperty(_assertThisInitialized(_this), "btnCenter", null);

          _defineProperty(_assertThisInitialized(_this), "btnHelp", null);

          _defineProperty(_assertThisInitialized(_this), "btnMini", null);

          _defineProperty(_assertThisInitialized(_this), "guideMaskNode", null);

          _defineProperty(_assertThisInitialized(_this), "btnList", []);

          return _this;
        }

        var _proto = PlayerBottomUI_Ctrl.prototype;

        _proto.onLoad = function onLoad() {
          _UICtrl.prototype.onLoad.call(this);

          this.playerTipLabel = this.view["tipsBG/tipLabel"];
          this.btnUp = this.view["ButtonUp"];
          this.btnDown = this.view["ButtonDown"];
          this.btnLeft = this.view["ButtonLeft"];
          this.btnRight = this.view["ButtonRight"];
          this.btnCenter = this.view["ButtonGo"];
          this.btnHelp = this.view["help/helpBtn"];
          this.btnMini = this.view["mini/miniBtn"];
          this.addButtonListen(this.btnUp, this, this.onPressUp);
          this.addButtonListen(this.btnDown, this, this.onPressDown);
          this.addButtonListen(this.btnLeft, this, this.onPressLeft);
          this.addButtonListen(this.btnRight, this, this.onPressRight);
          this.addButtonListen(this.btnCenter, this, this.onPressCenter);
          this.updateBtnState(this.btnLeft, false);
          this.updateBtnState(this.btnRight, false);
          this.updateBtnState(this.btnUp, false);
          this.updateBtnState(this.btnDown, false);
          this.updateBtnState(this.btnCenter, false);
          this.btnList.push(this.btnLeft);
          this.btnList.push(this.btnUp);
          this.btnList.push(this.btnRight);
          this.btnList.push(this.btnDown);
          this.guideMaskNode = this.view["guideMask"];
          this.addButtonListen(this.guideMaskNode, this, this.hideGuideAni);
          this.addButtonListen(this.btnHelp, this, this.onPressplayerHelp);
          this.addButtonListen(this.btnMini, this, this.onPressPlayerMini);
          this.tipLabel = this.playerTipLabel.getComponent(LabelComponent);
        } //更新快照数据
        ;

        _proto.updateSnapshotUI = function updateSnapshotUI() {
          if (this.tipLabel) this.tipLabel.string = Tips.tipRegStart;
          this.updateOperateBtnState(false, false, false, false, false);
        } //更新本局或本轮开始数据
        ;

        _proto.updateGameStartUI = function updateGameStartUI(data) {
          var _this2 = this;

          var tipReg = Tips.tipRegPre + data.roundCountdown.toString() + Tips.tipRegRear;

          var _label = data.isPlayoff == false ? tipReg : Tips.tipOverTime;

          this.currentNo = data.roundCountdown;

          if (data.myData.id) {
            //在本局，基于局面的选择控制按钮的显示隐藏
            if (data.isPlayoff == false) {
              //重连时间很短促的情况下就不要做这种提示了，时间太短，不适宜展示
              if (data.roundCountdown > 3) {
                var isShow = sys.localStorage.getItem("guideShowed");

                if (isShow != "1") {
                  this.showGuideAni();
                  sys.localStorage.setItem("guideShowed", "1");
                  this.scheduleOnce(function () {
                    _this2.hideGuideAni();
                  }, data.roundCountdown);
                }
              }

              this.updateOperateBtnState(ArrowState[data.myData.id][0], ArrowState[data.myData.id][1], ArrowState[data.myData.id][2], ArrowState[data.myData.id][3], false);
              this.updateTimeTips();
              this.schedule(this.updateTimeTips, 1, this.currentNo, 0);
              Logger.info("显示非加赛按钮,isPlayoff = ", data.isPlayoff, "  我的格子数据为：", JSON.stringify(data));
            } else {
              this.updateOperateBtnState(false, false, false, false, true);
              this.scheduleOnce(function () {
                if (_this2.isOverTimeAnimating) return;

                _this2.overTimeRunning();
              }, this.currentNo - 3);
              Logger.info("显示加赛按钮,isPlayoff = ", data.isPlayoff, "  我的格子数据为：", JSON.stringify(data));
            }
          } else {
            _label = Tips.tipRegNo; //不在本局

            Logger.info("不在本轮，无法操作,isPlayoff = ", data.isPlayoff, "  我的格子数据为：", JSON.stringify(data));
            this.updateOperateBtnState(false, false, false, false, false);
          }

          this.tipLabel.string = _label;
        };

        _proto.showGuideAni = function showGuideAni() {
          this.view["guideMask"].active = true;
          var guideAni = this.view["guideAni"];
          guideAni.active = true;
          var aniNode = guideAni.getComponent(sp.Skeleton);
          aniNode.setAnimation(0, 'zhiying', true);
        };

        _proto.hideGuideAni = function hideGuideAni() {
          sys.localStorage.setItem("guideShowed", "1");
          this.view["guideMask"].active = false;
          var guideAni = this.view["guideAni"];
          guideAni.active = false;
        };

        _proto.updateTimeTips = function updateTimeTips() {
          var _label = "请在 " + this.currentNo + "s 内做出选择";

          this.tipLabel.string = _label;
          this.currentNo--;
        } //更新本轮结束数据
        ;

        _proto.updateRoundSettleUI = function updateRoundSettleUI() {};

        _proto.start = function start() {};

        _proto.updateLabel = function updateLabel(str) {
          this.unschedule(this.updateTimeTips);
          this.tipLabel.string = str;
        } //加赛开关
        ;

        _proto.overTimeRunning = function overTimeRunning() {
          this.updateOperateBtnState(false, false, false, false, false);
          this.tipLabel.string = Tips.tipOverTimeIn;
          this.isOverTimeAnimating = true;
          this.rotateSpeed = 0.1;
          this.currentSpeed = 0;
          this.currentBtnIdx = 0;
          this.endBtnIdx = -1;
        } //按钮移动降速
        ;

        _proto.slowDown = function slowDown(offsetIdx, settleData) {
          this.endBtnIdx = offsetIdx;
          this.settleData = settleData;
        };

        _proto.update = function update(dt) {
          //加赛动画实现
          if (this.isOverTimeAnimating) {
            this.currentSpeed += dt;

            if (this.currentSpeed > this.rotateSpeed) {
              if (this.isFinalRotate) {
                this.rotateSpeed += 0.03;
              }

              this.currentSpeed = 0;
              if (this.currentBtnIdx > 3) this.currentBtnIdx = 0;
              var preIdx = this.currentBtnIdx == 0 ? 3 : this.currentBtnIdx - 1;

              if (this.endBtnIdx >= 0 && preIdx == this.endBtnIdx) {
                this.isOverTimeAnimating = false;
                return;
              }

              this.updateBtnState(this.btnList[this.currentBtnIdx], true);
              this.updateBtnState(this.btnList[preIdx], false);
              AudioManager.Instance.playSound(SoundName.EFFECT_CLICK); // SoundMgr.Instance.play_effect(SoundName.EFFECT_CLICK);

              this.currentBtnIdx++;
            }
          }
        } //更新操作按钮显示隐藏
        ;

        _proto.updateOperateBtnState = function updateOperateBtnState(leftShow, upShow, rightShow, downShow, centerShow) {
          if (this.isLeftShow == !leftShow) {
            this.isLeftShow = leftShow;
            this.updateBtnState(this.btnLeft, leftShow);
          }

          if (this.isRightShow == !rightShow) {
            this.isRightShow = rightShow;
            this.updateBtnState(this.btnRight, rightShow);
          }

          if (this.isUpShow == !upShow) {
            this.isUpShow = upShow;
            this.updateBtnState(this.btnUp, upShow);
          }

          if (this.isDownShow == !downShow) {
            this.isDownShow = downShow;
            this.updateBtnState(this.btnDown, downShow);
          }

          if (this.isCenterShow == !centerShow) {
            this.isCenterShow = centerShow;
            this.updateBtnState(this.btnCenter, centerShow);
          }

          this.btnCenter.active = centerShow;
          this.btnUp.active = !centerShow;
          this.btnDown.active = !centerShow;
          this.btnLeft.active = !centerShow;
          this.btnRight.active = !centerShow;
        };

        _proto.updateBtnState = function updateBtnState(node, isShow) {
          var sp = node.getComponent(Sprite);
          var btn = node.getComponent(Button);

          if (isShow) {
            sp.color = math.color(sp.color.r, sp.color.g, sp.color.b, 255);
          } else {
            sp.color = math.color(sp.color.r, sp.color.g, sp.color.b, 120);
          }

          btn.enabled = isShow;
          btn.interactable = this.isOverTimeAnimating ? false : isShow;
        };

        _proto.onPressUp = function onPressUp() {
          Logger.info("onPressUp");
          EventMgr.Instance.Emit(GameEnum.EventPlayerPressedUp, null);
        };

        _proto.onPressDown = function onPressDown() {
          Logger.info("onPressDown");
          AudioManager.Instance.playSound(SoundName.EFFECT_CLICK); // SoundMgr.Instance.play_effect(SoundName.EFFECT_CLICK);

          EventMgr.Instance.Emit(GameEnum.EventPlayerPressedDown, null);
        };

        _proto.onPressLeft = function onPressLeft() {
          Logger.info("onPressLeft");
          AudioManager.Instance.playSound(SoundName.EFFECT_CLICK); // SoundMgr.Instance.play_effect(SoundName.EFFECT_CLICK);

          EventMgr.Instance.Emit(GameEnum.EventPlayerPressedLeft, null);
        };

        _proto.onPressRight = function onPressRight() {
          Logger.info("onPressRight");
          AudioManager.Instance.playSound(SoundName.EFFECT_CLICK); // SoundMgr.Instance.play_effect(SoundName.EFFECT_CLICK);

          EventMgr.Instance.Emit(GameEnum.EventPlayerPressedRight, null);
        };

        _proto.onPressCenter = function onPressCenter() {
          // 加赛逻辑
          Logger.info("加赛逻辑 onPressCenter");
          this.overTimeRunning();
        };

        _proto.onPressplayerHelp = function onPressplayerHelp() {
          Logger.info("onPressplayerHelp");
          BridgeMgr.Instance.helpPage();
        };

        _proto.onPressPlayerMini = function onPressPlayerMini() {
          Logger.info("onPressPlayerMini");
          BridgeMgr.Instance.miniPage();
        };

        return PlayerBottomUI_Ctrl;
      }(UICtrl), _temp)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/F.ts", ['cc', './Decimal.ts'], function (exports) {
  'use strict';

  var cclegacy, Decimal;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      Decimal = module.default;
      exports('F', module.default);
    }],
    execute: function () {
      cclegacy._RF.push({}, "21aa4eY3TBJdqR6guEU3wId", "F", undefined);

      var pi = exports('pi', new Decimal(3.141592653589793));
      var DEG = exports('DEG', new Decimal(57.29577951308232));
      var RAD = exports('RAD', new Decimal(0.017453292519943295)); // 系统常量

      var PI = exports('PI', new Decimal(3.141592653589793));
      var E = exports('E', new Decimal(2.718281828459045));
      var LN2 = exports('LN2', new Decimal(0.6931471805599453));
      var LN10 = exports('LN10', new Decimal(2.302585092994046));
      var LOG2E = exports('LOG2E', new Decimal(1.4426950408889634));
      var LOG10E = exports('LOG10E', new Decimal(0.4342944819032518));
      var SQRT1_2 = exports('SQRT1_2', new Decimal(0.7071067811865476));
      var SQRT2 = exports('SQRT2', new Decimal(1.4142135623730951));
      var ZERO = exports('ZERO', new Decimal(0));
      var Fe = exports('Fe', /*#__PURE__*/function () {
        function Fe() {}
        /**
         * 三角函数
         */


        Fe.sin = function sin(x) {
          return new Decimal(Math.sin(x));
        };

        Fe.cos = function cos(x) {
          return new Decimal(Math.cos(x));
        };

        Fe.asin = function asin(x) {
          return new Decimal(Math.asin(x));
        };

        Fe.acos = function acos(x) {
          return new Decimal(Math.acos(x));
        };

        Fe.hypot = function hypot(x, y) {
          return new Decimal(Math.hypot(x, y));
        };

        return Fe;
      }());

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/protobuf-library.min.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      loader.define(module.meta.url, function (exports$1, _require, module, __filename, __dirname) {
        var require = loader.createRequireWithReqMap({}, _require);

        (function () {
          (function (global, undefined$1) {
            (function prelude(modules, cache, entries) {
              function $require(name) {
                var $module = cache[name];
                if (!$module) modules[name][0].call($module = cache[name] = {
                  exports: {}
                }, $require, $module, $module.exports);
                return $module.exports;
              }

              var protobuf = global.protobuf = $require(entries[0]);
              if (typeof define === "function" && define.amd) define(["long"], function (Long) {
                if (Long && Long.isLong) {
                  protobuf.util.Long = Long;
                  protobuf.configure();
                }

                return protobuf;
              });
              if (typeof module === "object" && module && module.exports) module.exports = protobuf;
            })({
              1: [function (require, module, exports) {
                module.exports = asPromise;

                function asPromise(fn, ctx) {
                  var params = new Array(arguments.length - 1),
                      offset = 0,
                      index = 2,
                      pending = true;

                  while (index < arguments.length) {
                    params[offset++] = arguments[index++];
                  }

                  return new Promise(function executor(resolve, reject) {
                    params[offset] = function callback(err) {
                      if (pending) {
                        pending = false;
                        if (err) reject(err);else {
                          var params = new Array(arguments.length - 1),
                              offset = 0;

                          while (offset < params.length) {
                            params[offset++] = arguments[offset];
                          }

                          resolve.apply(null, params);
                        }
                      }
                    };

                    try {
                      fn.apply(ctx || null, params);
                    } catch (err) {
                      if (pending) {
                        pending = false;
                        reject(err);
                      }
                    }
                  });
                }
              }, {}],
              2: [function (require, module, exports) {
                var base64 = exports;

                base64.length = function length(string) {
                  var p = string.length;
                  if (!p) return 0;
                  var n = 0;

                  while (--p % 4 > 1 && string.charAt(p) === "=") {
                    ++n;
                  }

                  return Math.ceil(string.length * 3) / 4 - n;
                };

                var b64 = new Array(64);
                var s64 = new Array(123);

                for (var i = 0; i < 64;) {
                  s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
                }

                base64.encode = function encode(buffer, start, end) {
                  var parts = null,
                      chunk = [];
                  var i = 0,
                      j = 0,
                      t;

                  while (start < end) {
                    var b = buffer[start++];

                    switch (j) {
                      case 0:
                        chunk[i++] = b64[b >> 2];
                        t = (b & 3) << 4;
                        j = 1;
                        break;

                      case 1:
                        chunk[i++] = b64[t | b >> 4];
                        t = (b & 15) << 2;
                        j = 2;
                        break;

                      case 2:
                        chunk[i++] = b64[t | b >> 6];
                        chunk[i++] = b64[b & 63];
                        j = 0;
                        break;
                    }

                    if (i > 8191) {
                      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
                      i = 0;
                    }
                  }

                  if (j) {
                    chunk[i++] = b64[t];
                    chunk[i++] = 61;
                    if (j === 1) chunk[i++] = 61;
                  }

                  if (parts) {
                    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
                    return parts.join("");
                  }

                  return String.fromCharCode.apply(String, chunk.slice(0, i));
                };

                var invalidEncoding = "invalid encoding";

                base64.decode = function decode(string, buffer, offset) {
                  var start = offset;
                  var j = 0,
                      t;

                  for (var i = 0; i < string.length;) {
                    var c = string.charCodeAt(i++);
                    if (c === 61 && j > 1) break;
                    if ((c = s64[c]) === undefined$1) throw Error(invalidEncoding);

                    switch (j) {
                      case 0:
                        t = c;
                        j = 1;
                        break;

                      case 1:
                        buffer[offset++] = t << 2 | (c & 48) >> 4;
                        t = c;
                        j = 2;
                        break;

                      case 2:
                        buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                        t = c;
                        j = 3;
                        break;

                      case 3:
                        buffer[offset++] = (t & 3) << 6 | c;
                        j = 0;
                        break;
                    }
                  }

                  if (j === 1) throw Error(invalidEncoding);
                  return offset - start;
                };

                base64.test = function test(string) {
                  return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
                };
              }, {}],
              3: [function (require, module, exports) {
                module.exports = codegen;

                function codegen(functionParams, functionName) {
                  if (typeof functionParams === "string") {
                    functionName = functionParams;
                    functionParams = undefined$1;
                  }

                  var body = [];

                  function Codegen(formatStringOrScope) {
                    if (typeof formatStringOrScope !== "string") {
                      var source = toString();
                      if (codegen.verbose) console.log("codegen: " + source);
                      source = "return " + source;

                      if (formatStringOrScope) {
                        var scopeKeys = Object.keys(formatStringOrScope),
                            scopeParams = new Array(scopeKeys.length + 1),
                            scopeValues = new Array(scopeKeys.length),
                            scopeOffset = 0;

                        while (scopeOffset < scopeKeys.length) {
                          scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                          scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                        }

                        scopeParams[scopeOffset] = source;
                        return Function.apply(null, scopeParams).apply(null, scopeValues);
                      }

                      return Function(source)();
                    }

                    var formatParams = new Array(arguments.length - 1),
                        formatOffset = 0;

                    while (formatOffset < formatParams.length) {
                      formatParams[formatOffset] = arguments[++formatOffset];
                    }

                    formatOffset = 0;
                    formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
                      var value = formatParams[formatOffset++];

                      switch ($1) {
                        case "d":
                        case "f":
                          return String(Number(value));

                        case "i":
                          return String(Math.floor(value));

                        case "j":
                          return JSON.stringify(value);

                        case "s":
                          return String(value);
                      }

                      return "%";
                    });
                    if (formatOffset !== formatParams.length) throw Error("parameter count mismatch");
                    body.push(formatStringOrScope);
                    return Codegen;
                  }

                  function toString(functionNameOverride) {
                    return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
                  }

                  Codegen.toString = toString;
                  return Codegen;
                }

                codegen.verbose = false;
              }, {}],
              4: [function (require, module, exports) {
                module.exports = EventEmitter;

                function EventEmitter() {
                  this._listeners = {};
                }

                EventEmitter.prototype.on = function on(evt, fn, ctx) {
                  (this._listeners[evt] || (this._listeners[evt] = [])).push({
                    fn: fn,
                    ctx: ctx || this
                  });
                  return this;
                };

                EventEmitter.prototype.off = function off(evt, fn) {
                  if (evt === undefined$1) this._listeners = {};else {
                    if (fn === undefined$1) this._listeners[evt] = [];else {
                      var listeners = this._listeners[evt];

                      for (var i = 0; i < listeners.length;) {
                        if (listeners[i].fn === fn) listeners.splice(i, 1);else ++i;
                      }
                    }
                  }
                  return this;
                };

                EventEmitter.prototype.emit = function emit(evt) {
                  var listeners = this._listeners[evt];

                  if (listeners) {
                    var args = [],
                        i = 1;

                    for (; i < arguments.length;) {
                      args.push(arguments[i++]);
                    }

                    for (i = 0; i < listeners.length;) {
                      listeners[i].fn.apply(listeners[i++].ctx, args);
                    }
                  }

                  return this;
                };
              }, {}],
              5: [function (require, module, exports) {
                module.exports = fetch;

                var asPromise = require(1),
                    inquire = require(7);

                var fs = inquire("fs");

                function fetch(filename, options, callback) {
                  if (typeof options === "function") {
                    callback = options;
                    options = {};
                  } else if (!options) options = {};

                  if (!callback) return asPromise(fetch, this, filename, options);
                  if (!options.xhr && fs && fs.readFile) return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
                    return err && typeof XMLHttpRequest !== "undefined" ? fetch.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
                  });
                  return fetch.xhr(filename, options, callback);
                }

                fetch.xhr = function fetch_xhr(filename, options, callback) {
                  var xhr = new XMLHttpRequest();

                  xhr.onreadystatechange = function fetchOnReadyStateChange() {
                    if (xhr.readyState !== 4) return undefined$1;
                    if (xhr.status !== 0 && xhr.status !== 200) return callback(Error("status " + xhr.status));

                    if (options.binary) {
                      var buffer = xhr.response;

                      if (!buffer) {
                        buffer = [];

                        for (var i = 0; i < xhr.responseText.length; ++i) {
                          buffer.push(xhr.responseText.charCodeAt(i) & 255);
                        }
                      }

                      return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
                    }

                    return callback(null, xhr.responseText);
                  };

                  if (options.binary) {
                    if ("overrideMimeType" in xhr) xhr.overrideMimeType("text/plain; charset=x-user-defined");
                    xhr.responseType = "arraybuffer";
                  }

                  xhr.open("GET", filename);
                  xhr.send();
                };
              }, {
                1: 1,
                7: 7
              }],
              6: [function (require, module, exports) {
                module.exports = factory(factory);

                function factory(exports) {
                  if (typeof Float32Array !== "undefined") (function () {
                    var f32 = new Float32Array([-0]),
                        f8b = new Uint8Array(f32.buffer),
                        le = f8b[3] === 128;

                    function writeFloat_f32_cpy(val, buf, pos) {
                      f32[0] = val;
                      buf[pos] = f8b[0];
                      buf[pos + 1] = f8b[1];
                      buf[pos + 2] = f8b[2];
                      buf[pos + 3] = f8b[3];
                    }

                    function writeFloat_f32_rev(val, buf, pos) {
                      f32[0] = val;
                      buf[pos] = f8b[3];
                      buf[pos + 1] = f8b[2];
                      buf[pos + 2] = f8b[1];
                      buf[pos + 3] = f8b[0];
                    }

                    exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
                    exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

                    function readFloat_f32_cpy(buf, pos) {
                      f8b[0] = buf[pos];
                      f8b[1] = buf[pos + 1];
                      f8b[2] = buf[pos + 2];
                      f8b[3] = buf[pos + 3];
                      return f32[0];
                    }

                    function readFloat_f32_rev(buf, pos) {
                      f8b[3] = buf[pos];
                      f8b[2] = buf[pos + 1];
                      f8b[1] = buf[pos + 2];
                      f8b[0] = buf[pos + 3];
                      return f32[0];
                    }

                    exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
                    exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
                  })();else (function () {
                    function writeFloat_ieee754(writeUint, val, buf, pos) {
                      var sign = val < 0 ? 1 : 0;
                      if (sign) val = -val;
                      if (val === 0) writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);else if (isNaN(val)) writeUint(2143289344, buf, pos);else if (val > 3.4028234663852886e38) writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);else if (val < 1.1754943508222875e-38) writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);else {
                        var exponent = Math.floor(Math.log(val) / Math.LN2),
                            mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                        writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
                      }
                    }

                    exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
                    exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

                    function readFloat_ieee754(readUint, buf, pos) {
                      var uint = readUint(buf, pos),
                          sign = (uint >> 31) * 2 + 1,
                          exponent = uint >>> 23 & 255,
                          mantissa = uint & 8388607;
                      return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1.401298464324817e-45 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
                    }

                    exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
                    exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
                  })();
                  if (typeof Float64Array !== "undefined") (function () {
                    var f64 = new Float64Array([-0]),
                        f8b = new Uint8Array(f64.buffer),
                        le = f8b[7] === 128;

                    function writeDouble_f64_cpy(val, buf, pos) {
                      f64[0] = val;
                      buf[pos] = f8b[0];
                      buf[pos + 1] = f8b[1];
                      buf[pos + 2] = f8b[2];
                      buf[pos + 3] = f8b[3];
                      buf[pos + 4] = f8b[4];
                      buf[pos + 5] = f8b[5];
                      buf[pos + 6] = f8b[6];
                      buf[pos + 7] = f8b[7];
                    }

                    function writeDouble_f64_rev(val, buf, pos) {
                      f64[0] = val;
                      buf[pos] = f8b[7];
                      buf[pos + 1] = f8b[6];
                      buf[pos + 2] = f8b[5];
                      buf[pos + 3] = f8b[4];
                      buf[pos + 4] = f8b[3];
                      buf[pos + 5] = f8b[2];
                      buf[pos + 6] = f8b[1];
                      buf[pos + 7] = f8b[0];
                    }

                    exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
                    exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

                    function readDouble_f64_cpy(buf, pos) {
                      f8b[0] = buf[pos];
                      f8b[1] = buf[pos + 1];
                      f8b[2] = buf[pos + 2];
                      f8b[3] = buf[pos + 3];
                      f8b[4] = buf[pos + 4];
                      f8b[5] = buf[pos + 5];
                      f8b[6] = buf[pos + 6];
                      f8b[7] = buf[pos + 7];
                      return f64[0];
                    }

                    function readDouble_f64_rev(buf, pos) {
                      f8b[7] = buf[pos];
                      f8b[6] = buf[pos + 1];
                      f8b[5] = buf[pos + 2];
                      f8b[4] = buf[pos + 3];
                      f8b[3] = buf[pos + 4];
                      f8b[2] = buf[pos + 5];
                      f8b[1] = buf[pos + 6];
                      f8b[0] = buf[pos + 7];
                      return f64[0];
                    }

                    exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
                    exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
                  })();else (function () {
                    function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
                      var sign = val < 0 ? 1 : 0;
                      if (sign) val = -val;

                      if (val === 0) {
                        writeUint(0, buf, pos + off0);
                        writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
                      } else if (isNaN(val)) {
                        writeUint(0, buf, pos + off0);
                        writeUint(2146959360, buf, pos + off1);
                      } else if (val > 1.7976931348623157e308) {
                        writeUint(0, buf, pos + off0);
                        writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
                      } else {
                        var mantissa;

                        if (val < 2.2250738585072014e-308) {
                          mantissa = val / 5e-324;
                          writeUint(mantissa >>> 0, buf, pos + off0);
                          writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                        } else {
                          var exponent = Math.floor(Math.log(val) / Math.LN2);
                          if (exponent === 1024) exponent = 1023;
                          mantissa = val * Math.pow(2, -exponent);
                          writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                          writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                        }
                      }
                    }

                    exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
                    exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

                    function readDouble_ieee754(readUint, off0, off1, buf, pos) {
                      var lo = readUint(buf, pos + off0),
                          hi = readUint(buf, pos + off1);
                      var sign = (hi >> 31) * 2 + 1,
                          exponent = hi >>> 20 & 2047,
                          mantissa = 4294967296 * (hi & 1048575) + lo;
                      return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
                    }

                    exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
                    exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
                  })();
                  return exports;
                }

                function writeUintLE(val, buf, pos) {
                  buf[pos] = val & 255;
                  buf[pos + 1] = val >>> 8 & 255;
                  buf[pos + 2] = val >>> 16 & 255;
                  buf[pos + 3] = val >>> 24;
                }

                function writeUintBE(val, buf, pos) {
                  buf[pos] = val >>> 24;
                  buf[pos + 1] = val >>> 16 & 255;
                  buf[pos + 2] = val >>> 8 & 255;
                  buf[pos + 3] = val & 255;
                }

                function readUintLE(buf, pos) {
                  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
                }

                function readUintBE(buf, pos) {
                  return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
                }
              }, {}],
              7: [function (require, module, exports) {
                module.exports = inquire;

                function inquire(moduleName) {
                  try {
                    var mod = eval("quire".replace(/^/, "re"))(moduleName);
                    if (mod && (mod.length || Object.keys(mod).length)) return mod;
                  } catch (e) {}

                  return null;
                }
              }, {}],
              8: [function (require, module, exports) {
                var path = exports;

                var isAbsolute = path.isAbsolute = function isAbsolute(path) {
                  return /^(?:\/|\w+:)/.test(path);
                };

                var normalize = path.normalize = function normalize(path) {
                  path = path.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
                  var parts = path.split("/"),
                      absolute = isAbsolute(path),
                      prefix = "";
                  if (absolute) prefix = parts.shift() + "/";

                  for (var i = 0; i < parts.length;) {
                    if (parts[i] === "..") {
                      if (i > 0 && parts[i - 1] !== "..") parts.splice(--i, 2);else if (absolute) parts.splice(i, 1);else ++i;
                    } else if (parts[i] === ".") parts.splice(i, 1);else ++i;
                  }

                  return prefix + parts.join("/");
                };

                path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
                  if (!alreadyNormalized) includePath = normalize(includePath);
                  if (isAbsolute(includePath)) return includePath;
                  if (!alreadyNormalized) originPath = normalize(originPath);
                  return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
                };
              }, {}],
              9: [function (require, module, exports) {
                module.exports = pool;

                function pool(alloc, slice, size) {
                  var SIZE = size || 8192;
                  var MAX = SIZE >>> 1;
                  var slab = null;
                  var offset = SIZE;
                  return function pool_alloc(size) {
                    if (size < 1 || size > MAX) return alloc(size);

                    if (offset + size > SIZE) {
                      slab = alloc(SIZE);
                      offset = 0;
                    }

                    var buf = slice.call(slab, offset, offset += size);
                    if (offset & 7) offset = (offset | 7) + 1;
                    return buf;
                  };
                }
              }, {}],
              10: [function (require, module, exports) {
                var utf8 = exports;

                utf8.length = function utf8_length(string) {
                  var len = 0,
                      c = 0;

                  for (var i = 0; i < string.length; ++i) {
                    c = string.charCodeAt(i);
                    if (c < 128) len += 1;else if (c < 2048) len += 2;else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
                      ++i;
                      len += 4;
                    } else len += 3;
                  }

                  return len;
                };

                utf8.read = function utf8_read(buffer, start, end) {
                  var len = end - start;
                  if (len < 1) return "";
                  var parts = null,
                      chunk = [],
                      i = 0,
                      t;

                  while (start < end) {
                    t = buffer[start++];
                    if (t < 128) chunk[i++] = t;else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;else if (t > 239 && t < 365) {
                      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
                      chunk[i++] = 55296 + (t >> 10);
                      chunk[i++] = 56320 + (t & 1023);
                    } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;

                    if (i > 8191) {
                      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
                      i = 0;
                    }
                  }

                  if (parts) {
                    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
                    return parts.join("");
                  }

                  return String.fromCharCode.apply(String, chunk.slice(0, i));
                };

                utf8.write = function utf8_write(string, buffer, offset) {
                  var start = offset,
                      c1,
                      c2;

                  for (var i = 0; i < string.length; ++i) {
                    c1 = string.charCodeAt(i);

                    if (c1 < 128) {
                      buffer[offset++] = c1;
                    } else if (c1 < 2048) {
                      buffer[offset++] = c1 >> 6 | 192;
                      buffer[offset++] = c1 & 63 | 128;
                    } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
                      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
                      ++i;
                      buffer[offset++] = c1 >> 18 | 240;
                      buffer[offset++] = c1 >> 12 & 63 | 128;
                      buffer[offset++] = c1 >> 6 & 63 | 128;
                      buffer[offset++] = c1 & 63 | 128;
                    } else {
                      buffer[offset++] = c1 >> 12 | 224;
                      buffer[offset++] = c1 >> 6 & 63 | 128;
                      buffer[offset++] = c1 & 63 | 128;
                    }
                  }

                  return offset - start;
                };
              }, {}],
              11: [function (require, module, exports) {
                module.exports = common;
                var commonRe = /\/|\./;

                function common(name, json) {
                  if (!commonRe.test(name)) {
                    name = "google/protobuf/" + name + ".proto";
                    json = {
                      nested: {
                        google: {
                          nested: {
                            protobuf: {
                              nested: json
                            }
                          }
                        }
                      }
                    };
                  }

                  common[name] = json;
                }

                common("any", {
                  Any: {
                    fields: {
                      type_url: {
                        type: "string",
                        id: 1
                      },
                      value: {
                        type: "bytes",
                        id: 2
                      }
                    }
                  }
                });
                var timeType;
                common("duration", {
                  Duration: timeType = {
                    fields: {
                      seconds: {
                        type: "int64",
                        id: 1
                      },
                      nanos: {
                        type: "int32",
                        id: 2
                      }
                    }
                  }
                });
                common("timestamp", {
                  Timestamp: timeType
                });
                common("empty", {
                  Empty: {
                    fields: {}
                  }
                });
                common("struct", {
                  Struct: {
                    fields: {
                      fields: {
                        keyType: "string",
                        type: "Value",
                        id: 1
                      }
                    }
                  },
                  Value: {
                    oneofs: {
                      kind: {
                        oneof: ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]
                      }
                    },
                    fields: {
                      nullValue: {
                        type: "NullValue",
                        id: 1
                      },
                      numberValue: {
                        type: "double",
                        id: 2
                      },
                      stringValue: {
                        type: "string",
                        id: 3
                      },
                      boolValue: {
                        type: "bool",
                        id: 4
                      },
                      structValue: {
                        type: "Struct",
                        id: 5
                      },
                      listValue: {
                        type: "ListValue",
                        id: 6
                      }
                    }
                  },
                  NullValue: {
                    values: {
                      NULL_VALUE: 0
                    }
                  },
                  ListValue: {
                    fields: {
                      values: {
                        rule: "repeated",
                        type: "Value",
                        id: 1
                      }
                    }
                  }
                });
                common("wrappers", {
                  DoubleValue: {
                    fields: {
                      value: {
                        type: "double",
                        id: 1
                      }
                    }
                  },
                  FloatValue: {
                    fields: {
                      value: {
                        type: "float",
                        id: 1
                      }
                    }
                  },
                  Int64Value: {
                    fields: {
                      value: {
                        type: "int64",
                        id: 1
                      }
                    }
                  },
                  UInt64Value: {
                    fields: {
                      value: {
                        type: "uint64",
                        id: 1
                      }
                    }
                  },
                  Int32Value: {
                    fields: {
                      value: {
                        type: "int32",
                        id: 1
                      }
                    }
                  },
                  UInt32Value: {
                    fields: {
                      value: {
                        type: "uint32",
                        id: 1
                      }
                    }
                  },
                  BoolValue: {
                    fields: {
                      value: {
                        type: "bool",
                        id: 1
                      }
                    }
                  },
                  StringValue: {
                    fields: {
                      value: {
                        type: "string",
                        id: 1
                      }
                    }
                  },
                  BytesValue: {
                    fields: {
                      value: {
                        type: "bytes",
                        id: 1
                      }
                    }
                  }
                });

                common.get = function get(file) {
                  return common[file] || null;
                };
              }, {}],
              12: [function (require, module, exports) {
                var converter = exports;

                var Enum = require(15),
                    util = require(37);

                function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
                  if (field.resolvedType) {
                    if (field.resolvedType instanceof Enum) {
                      gen("switch(d%s){", prop);

                      for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                        if (field.repeated && values[keys[i]] === field.typeDefault) gen("default:");
                        gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
                      }

                      gen("}");
                    } else gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
                  } else {
                    var isUnsigned = false;

                    switch (field.type) {
                      case "double":
                      case "float":
                        gen("m%s=Number(d%s)", prop, prop);
                        break;

                      case "uint32":
                      case "fixed32":
                        gen("m%s=d%s>>>0", prop, prop);
                        break;

                      case "int32":
                      case "sint32":
                      case "sfixed32":
                        gen("m%s=d%s|0", prop, prop);
                        break;

                      case "uint64":
                        isUnsigned = true;

                      case "int64":
                      case "sint64":
                      case "fixed64":
                      case "sfixed64":
                        gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                        break;

                      case "bytes":
                        gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length)", prop)("m%s=d%s", prop, prop);
                        break;

                      case "string":
                        gen("m%s=String(d%s)", prop, prop);
                        break;

                      case "bool":
                        gen("m%s=Boolean(d%s)", prop, prop);
                        break;
                    }
                  }

                  return gen;
                }

                converter.fromObject = function fromObject(mtype) {
                  var fields = mtype.fieldsArray;
                  var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
                  if (!fields.length) return gen("return new this.ctor");
                  gen("var m=new this.ctor");

                  for (var i = 0; i < fields.length; ++i) {
                    var field = fields[i].resolve(),
                        prop = util.safeProp(field.name);

                    if (field.map) {
                      gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
                      genValuePartial_fromObject(gen, field, i, prop + "[ks[i]]")("}")("}");
                    } else if (field.repeated) {
                      gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
                      genValuePartial_fromObject(gen, field, i, prop + "[i]")("}")("}");
                    } else {
                      if (!(field.resolvedType instanceof Enum)) gen("if(d%s!=null){", prop);
                      genValuePartial_fromObject(gen, field, i, prop);
                      if (!(field.resolvedType instanceof Enum)) gen("}");
                    }
                  }

                  return gen("return m");
                };

                function genValuePartial_toObject(gen, field, fieldIndex, prop) {
                  if (field.resolvedType) {
                    if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);else gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
                  } else {
                    var isUnsigned = false;

                    switch (field.type) {
                      case "double":
                      case "float":
                        gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                        break;

                      case "uint64":
                        isUnsigned = true;

                      case "int64":
                      case "sint64":
                      case "fixed64":
                      case "sfixed64":
                        gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
                        break;

                      case "bytes":
                        gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                        break;

                      default:
                        gen("d%s=m%s", prop, prop);
                        break;
                    }
                  }

                  return gen;
                }

                converter.toObject = function toObject(mtype) {
                  var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
                  if (!fields.length) return util.codegen()("return {}");
                  var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
                  var repeatedFields = [],
                      mapFields = [],
                      normalFields = [],
                      i = 0;

                  for (; i < fields.length; ++i) {
                    if (!fields[i].partOf) (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
                  }

                  if (repeatedFields.length) {
                    gen("if(o.arrays||o.defaults){");

                    for (i = 0; i < repeatedFields.length; ++i) {
                      gen("d%s=[]", util.safeProp(repeatedFields[i].name));
                    }

                    gen("}");
                  }

                  if (mapFields.length) {
                    gen("if(o.objects||o.defaults){");

                    for (i = 0; i < mapFields.length; ++i) {
                      gen("d%s={}", util.safeProp(mapFields[i].name));
                    }

                    gen("}");
                  }

                  if (normalFields.length) {
                    gen("if(o.defaults){");

                    for (i = 0; i < normalFields.length; ++i) {
                      var field = normalFields[i],
                          prop = util.safeProp(field.name);
                      if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);else if (field["long"]) gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());else if (field.bytes) gen("d%s=o.bytes===String?%j:%s", prop, String.fromCharCode.apply(String, field.typeDefault), "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]");else gen("d%s=%j", prop, field.typeDefault);
                    }

                    gen("}");
                  }

                  var hasKs2 = false;

                  for (i = 0; i < fields.length; ++i) {
                    var field = fields[i],
                        index = mtype._fieldsArray.indexOf(field),
                        prop = util.safeProp(field.name);

                    if (field.map) {
                      if (!hasKs2) {
                        hasKs2 = true;
                        gen("var ks2");
                      }

                      gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
                      genValuePartial_toObject(gen, field, index, prop + "[ks2[j]]")("}");
                    } else if (field.repeated) {
                      gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
                      genValuePartial_toObject(gen, field, index, prop + "[j]")("}");
                    } else {
                      gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
                      genValuePartial_toObject(gen, field, index, prop);
                      if (field.partOf) gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
                    }

                    gen("}");
                  }

                  return gen("return d");
                };
              }, {
                15: 15,
                37: 37
              }],
              13: [function (require, module, exports) {
                module.exports = decoder;

                var Enum = require(15),
                    types = require(36),
                    util = require(37);

                function missing(field) {
                  return "missing required '" + field.name + "'";
                }

                function decoder(mtype) {
                  var gen = util.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function (field) {
                    return field.map;
                  }).length ? ",k" : ""))("while(r.pos<c){")("var t=r.uint32()");
                  if (mtype.group) gen("if((t&7)===4)")("break");
                  gen("switch(t>>>3){");
                  var i = 0;

                  for (; i < mtype.fieldsArray.length; ++i) {
                    var field = mtype._fieldsArray[i].resolve(),
                        type = field.resolvedType instanceof Enum ? "int32" : field.type,
                        ref = "m" + util.safeProp(field.name);

                    gen("case %i:", field.id);

                    if (field.map) {
                      gen("r.skip().pos++")("if(%s===util.emptyObject)", ref)("%s={}", ref)("k=r.%s()", field.keyType)("r.pos++");

                      if (types["long"][field.keyType] !== undefined$1) {
                        if (types.basic[type] === undefined$1) gen('%s[typeof k==="object"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())', ref, i);else gen('%s[typeof k==="object"?util.longToHash(k):k]=r.%s()', ref, type);
                      } else {
                        if (types.basic[type] === undefined$1) gen("%s[k]=types[%i].decode(r,r.uint32())", ref, i);else gen("%s[k]=r.%s()", ref, type);
                      }
                    } else if (field.repeated) {
                      gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
                      if (types.packed[type] !== undefined$1) gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
                      if (types.basic[type] === undefined$1) gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);else gen("%s.push(r.%s())", ref, type);
                    } else if (types.basic[type] === undefined$1) gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i);else gen("%s=r.%s()", ref, type);

                    gen("break");
                  }

                  gen("default:")("r.skipType(t&7)")("break")("}")("}");

                  for (i = 0; i < mtype._fieldsArray.length; ++i) {
                    var rfield = mtype._fieldsArray[i];
                    if (rfield.required) gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
                  }

                  return gen("return m");
                }
              }, {
                15: 15,
                36: 36,
                37: 37
              }],
              14: [function (require, module, exports) {
                module.exports = encoder;

                var Enum = require(15),
                    types = require(36),
                    util = require(37);

                function genTypePartial(gen, field, fieldIndex, ref) {
                  return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
                }

                function encoder(mtype) {
                  var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
                  var i, ref;
                  var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);

                  for (var i = 0; i < fields.length; ++i) {
                    var field = fields[i].resolve(),
                        index = mtype._fieldsArray.indexOf(field),
                        type = field.resolvedType instanceof Enum ? "int32" : field.type,
                        wireType = types.basic[type];

                    ref = "m" + util.safeProp(field.name);

                    if (field.map) {
                      gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
                      if (wireType === undefined$1) gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);else gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
                      gen("}")("}");
                    } else if (field.repeated) {
                      gen("if(%s!=null&&%s.length){", ref, ref);

                      if (field.packed && types.packed[type] !== undefined$1) {
                        gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
                      } else {
                        gen("for(var i=0;i<%s.length;++i)", ref);
                        if (wireType === undefined$1) genTypePartial(gen, field, index, ref + "[i]");else gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
                      }

                      gen("}");
                    } else {
                      if (field.optional) gen("if(%s!=null&&m.hasOwnProperty(%j))", ref, field.name);
                      if (wireType === undefined$1) genTypePartial(gen, field, index, ref);else gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
                    }
                  }

                  return gen("return w");
                }
              }, {
                15: 15,
                36: 36,
                37: 37
              }],
              15: [function (require, module, exports) {
                module.exports = Enum;

                var ReflectionObject = require(24);

                ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

                var Namespace = require(23),
                    util = require(37);

                function Enum(name, values, options) {
                  ReflectionObject.call(this, name, options);
                  if (values && typeof values !== "object") throw TypeError("values must be an object");
                  this.valuesById = {};
                  this.values = Object.create(this.valuesById);
                  this.comments = {};
                  this.reserved = undefined$1;
                  if (values) for (var keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                    if (typeof values[keys[i]] === "number") this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
                  }
                }

                Enum.fromJSON = function fromJSON(name, json) {
                  var enm = new Enum(name, json.values, json.options);
                  enm.reserved = json.reserved;
                  return enm;
                };

                Enum.prototype.toJSON = function toJSON() {
                  return util.toObject(["options", this.options, "values", this.values, "reserved", this.reserved && this.reserved.length ? this.reserved : undefined$1]);
                };

                Enum.prototype.add = function add(name, id, comment) {
                  if (!util.isString(name)) throw TypeError("name must be a string");
                  if (!util.isInteger(id)) throw TypeError("id must be an integer");
                  if (this.values[name] !== undefined$1) throw Error("duplicate name '" + name + "' in " + this);
                  if (this.isReservedId(id)) throw Error("id " + id + " is reserved in " + this);
                  if (this.isReservedName(name)) throw Error("name '" + name + "' is reserved in " + this);

                  if (this.valuesById[id] !== undefined$1) {
                    if (!(this.options && this.options.allow_alias)) throw Error("duplicate id " + id + " in " + this);
                    this.values[name] = id;
                  } else this.valuesById[this.values[name] = id] = name;

                  this.comments[name] = comment || null;
                  return this;
                };

                Enum.prototype.remove = function remove(name) {
                  if (!util.isString(name)) throw TypeError("name must be a string");
                  var val = this.values[name];
                  if (val == null) throw Error("name '" + name + "' does not exist in " + this);
                  delete this.valuesById[val];
                  delete this.values[name];
                  delete this.comments[name];
                  return this;
                };

                Enum.prototype.isReservedId = function isReservedId(id) {
                  return Namespace.isReservedId(this.reserved, id);
                };

                Enum.prototype.isReservedName = function isReservedName(name) {
                  return Namespace.isReservedName(this.reserved, name);
                };
              }, {
                23: 23,
                24: 24,
                37: 37
              }],
              16: [function (require, module, exports) {
                module.exports = Field;

                var ReflectionObject = require(24);

                ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

                var Enum = require(15),
                    types = require(36),
                    util = require(37);

                var Type;
                var ruleRe = /^required|optional|repeated$/;

                Field.fromJSON = function fromJSON(name, json) {
                  return new Field(name, json.id, json.type, json.rule, json.extend, json.options);
                };

                function Field(name, id, type, rule, extend, options) {
                  if (util.isObject(rule)) {
                    options = rule;
                    rule = extend = undefined$1;
                  } else if (util.isObject(extend)) {
                    options = extend;
                    extend = undefined$1;
                  }

                  ReflectionObject.call(this, name, options);
                  if (!util.isInteger(id) || id < 0) throw TypeError("id must be a non-negative integer");
                  if (!util.isString(type)) throw TypeError("type must be a string");
                  if (rule !== undefined$1 && !ruleRe.test(rule = rule.toString().toLowerCase())) throw TypeError("rule must be a string rule");
                  if (extend !== undefined$1 && !util.isString(extend)) throw TypeError("extend must be a string");
                  this.rule = rule && rule !== "optional" ? rule : undefined$1;
                  this.type = type;
                  this.id = id;
                  this.extend = extend || undefined$1;
                  this.required = rule === "required";
                  this.optional = !this.required;
                  this.repeated = rule === "repeated";
                  this.map = false;
                  this.message = null;
                  this.partOf = null;
                  this.typeDefault = null;
                  this.defaultValue = null;
                  this["long"] = util.Long ? types["long"][type] !== undefined$1 : false;
                  this.bytes = type === "bytes";
                  this.resolvedType = null;
                  this.extensionField = null;
                  this.declaringField = null;
                  this._packed = null;
                }

                Object.defineProperty(Field.prototype, "packed", {
                  get: function get() {
                    if (this._packed === null) this._packed = this.getOption("packed") !== false;
                    return this._packed;
                  }
                });

                Field.prototype.setOption = function setOption(name, value, ifNotSet) {
                  if (name === "packed") this._packed = null;
                  return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
                };

                Field.prototype.toJSON = function toJSON() {
                  return util.toObject(["rule", this.rule !== "optional" && this.rule || undefined$1, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options]);
                };

                Field.prototype.resolve = function resolve() {
                  if (this.resolved) return this;

                  if ((this.typeDefault = types.defaults[this.type]) === undefined$1) {
                    this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
                    if (this.resolvedType instanceof Type) this.typeDefault = null;else this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
                  }

                  if (this.options && this.options["default"] != null) {
                    this.typeDefault = this.options["default"];
                    if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string") this.typeDefault = this.resolvedType.values[this.typeDefault];
                  }

                  if (this.options) {
                    if (this.options.packed === true || this.options.packed !== undefined$1 && this.resolvedType && !(this.resolvedType instanceof Enum)) delete this.options.packed;
                    if (!Object.keys(this.options).length) this.options = undefined$1;
                  }

                  if (this["long"]) {
                    this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
                    if (Object.freeze) Object.freeze(this.typeDefault);
                  } else if (this.bytes && typeof this.typeDefault === "string") {
                    var buf;
                    if (util.base64.test(this.typeDefault)) util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);else util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
                    this.typeDefault = buf;
                  }

                  if (this.map) this.defaultValue = util.emptyObject;else if (this.repeated) this.defaultValue = util.emptyArray;else this.defaultValue = this.typeDefault;
                  if (this.parent instanceof Type) this.parent.ctor.prototype[this.name] = this.defaultValue;
                  return ReflectionObject.prototype.resolve.call(this);
                };

                Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
                  if (typeof fieldType === "function") fieldType = util.decorateType(fieldType).name;else if (fieldType && typeof fieldType === "object") fieldType = util.decorateEnum(fieldType).name;
                  return function fieldDecorator(prototype, fieldName) {
                    util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, {
                      "default": defaultValue
                    }));
                  };
                };

                Field._configure = function configure(Type_) {
                  Type = Type_;
                };
              }, {
                15: 15,
                24: 24,
                36: 36,
                37: 37
              }],
              17: [function (require, module, exports) {
                var protobuf = module.exports = require(18);

                protobuf.build = "light";

                function load(filename, root, callback) {
                  if (typeof root === "function") {
                    callback = root;
                    root = new protobuf.Root();
                  } else if (!root) root = new protobuf.Root();

                  return root.load(filename, callback);
                }

                protobuf.load = load;

                function loadSync(filename, root) {
                  if (!root) root = new protobuf.Root();
                  return root.loadSync(filename);
                }

                protobuf.loadSync = loadSync;
                protobuf.encoder = require(14);
                protobuf.decoder = require(13);
                protobuf.verifier = require(40);
                protobuf.converter = require(12);
                protobuf.ReflectionObject = require(24);
                protobuf.Namespace = require(23);
                protobuf.Root = require(29);
                protobuf.Enum = require(15);
                protobuf.Type = require(35);
                protobuf.Field = require(16);
                protobuf.OneOf = require(25);
                protobuf.MapField = require(20);
                protobuf.Service = require(33);
                protobuf.Method = require(22);
                protobuf.Message = require(21);
                protobuf.wrappers = require(41);
                protobuf.types = require(36);
                protobuf.util = require(37);

                protobuf.ReflectionObject._configure(protobuf.Root);

                protobuf.Namespace._configure(protobuf.Type, protobuf.Service);

                protobuf.Root._configure(protobuf.Type);

                protobuf.Field._configure(protobuf.Type);
              }, {
                12: 12,
                13: 13,
                14: 14,
                15: 15,
                16: 16,
                18: 18,
                20: 20,
                21: 21,
                22: 22,
                23: 23,
                24: 24,
                25: 25,
                29: 29,
                33: 33,
                35: 35,
                36: 36,
                37: 37,
                40: 40,
                41: 41
              }],
              18: [function (require, module, exports) {
                var protobuf = exports;
                protobuf.build = "minimal";
                protobuf.Writer = require(42);
                protobuf.BufferWriter = require(43);
                protobuf.Reader = require(27);
                protobuf.BufferReader = require(28);
                protobuf.util = require(39);
                protobuf.rpc = require(31);
                protobuf.roots = require(30);
                protobuf.configure = configure;

                function configure() {
                  protobuf.Reader._configure(protobuf.BufferReader);

                  protobuf.util._configure();
                }

                protobuf.Writer._configure(protobuf.BufferWriter);

                configure();
              }, {
                27: 27,
                28: 28,
                30: 30,
                31: 31,
                39: 39,
                42: 42,
                43: 43
              }],
              19: [function (require, module, exports) {
                var protobuf = module.exports = require(17);

                protobuf.build = "full";
                protobuf.tokenize = require(34);
                protobuf.parse = require(26);
                protobuf.common = require(11);

                protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
              }, {
                11: 11,
                17: 17,
                26: 26,
                34: 34
              }],
              20: [function (require, module, exports) {
                module.exports = MapField;

                var Field = require(16);

                ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

                var types = require(36),
                    util = require(37);

                function MapField(name, id, keyType, type, options) {
                  Field.call(this, name, id, type, options);
                  if (!util.isString(keyType)) throw TypeError("keyType must be a string");
                  this.keyType = keyType;
                  this.resolvedKeyType = null;
                  this.map = true;
                }

                MapField.fromJSON = function fromJSON(name, json) {
                  return new MapField(name, json.id, json.keyType, json.type, json.options);
                };

                MapField.prototype.toJSON = function toJSON() {
                  return util.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options]);
                };

                MapField.prototype.resolve = function resolve() {
                  if (this.resolved) return this;
                  if (types.mapKey[this.keyType] === undefined$1) throw Error("invalid key type: " + this.keyType);
                  return Field.prototype.resolve.call(this);
                };

                MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
                  if (typeof fieldValueType === "function") fieldValueType = util.decorateType(fieldValueType).name;else if (fieldValueType && typeof fieldValueType === "object") fieldValueType = util.decorateEnum(fieldValueType).name;
                  return function mapFieldDecorator(prototype, fieldName) {
                    util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
                  };
                };
              }, {
                16: 16,
                36: 36,
                37: 37
              }],
              21: [function (require, module, exports) {
                module.exports = Message;

                var util = require(39);

                function Message(properties) {
                  if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                    this[keys[i]] = properties[keys[i]];
                  }
                }

                Message.create = function create(properties) {
                  return this.$type.create(properties);
                };

                Message.encode = function encode(message, writer) {
                  return this.$type.encode(message, writer);
                };

                Message.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.$type.encodeDelimited(message, writer);
                };

                Message.decode = function decode(reader) {
                  return this.$type.decode(reader);
                };

                Message.decodeDelimited = function decodeDelimited(reader) {
                  return this.$type.decodeDelimited(reader);
                };

                Message.verify = function verify(message) {
                  return this.$type.verify(message);
                };

                Message.fromObject = function fromObject(object) {
                  return this.$type.fromObject(object);
                };

                Message.toObject = function toObject(message, options) {
                  return this.$type.toObject(message, options);
                };

                Message.prototype.toJSON = function toJSON() {
                  return this.$type.toObject(this, util.toJSONOptions);
                };
              }, {
                39: 39
              }],
              22: [function (require, module, exports) {
                module.exports = Method;

                var ReflectionObject = require(24);

                ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

                var util = require(37);

                function Method(name, type, requestType, responseType, requestStream, responseStream, options) {
                  if (util.isObject(requestStream)) {
                    options = requestStream;
                    requestStream = responseStream = undefined$1;
                  } else if (util.isObject(responseStream)) {
                    options = responseStream;
                    responseStream = undefined$1;
                  }

                  if (!(type === undefined$1 || util.isString(type))) throw TypeError("type must be a string");
                  if (!util.isString(requestType)) throw TypeError("requestType must be a string");
                  if (!util.isString(responseType)) throw TypeError("responseType must be a string");
                  ReflectionObject.call(this, name, options);
                  this.type = type || "rpc";
                  this.requestType = requestType;
                  this.requestStream = requestStream ? true : undefined$1;
                  this.responseType = responseType;
                  this.responseStream = responseStream ? true : undefined$1;
                  this.resolvedRequestType = null;
                  this.resolvedResponseType = null;
                }

                Method.fromJSON = function fromJSON(name, json) {
                  return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options);
                };

                Method.prototype.toJSON = function toJSON() {
                  return util.toObject(["type", this.type !== "rpc" && this.type || undefined$1, "requestType", this.requestType, "requestStream", this.requestStream, "responseType", this.responseType, "responseStream", this.responseStream, "options", this.options]);
                };

                Method.prototype.resolve = function resolve() {
                  if (this.resolved) return this;
                  this.resolvedRequestType = this.parent.lookupType(this.requestType);
                  this.resolvedResponseType = this.parent.lookupType(this.responseType);
                  return ReflectionObject.prototype.resolve.call(this);
                };
              }, {
                24: 24,
                37: 37
              }],
              23: [function (require, module, exports) {
                module.exports = Namespace;

                var ReflectionObject = require(24);

                ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

                var Enum = require(15),
                    Field = require(16),
                    util = require(37);

                var Type, Service;

                Namespace.fromJSON = function fromJSON(name, json) {
                  return new Namespace(name, json.options).addJSON(json.nested);
                };

                function arrayToJSON(array) {
                  if (!(array && array.length)) return undefined$1;
                  var obj = {};

                  for (var i = 0; i < array.length; ++i) {
                    obj[array[i].name] = array[i].toJSON();
                  }

                  return obj;
                }

                Namespace.arrayToJSON = arrayToJSON;

                Namespace.isReservedId = function isReservedId(reserved, id) {
                  if (reserved) for (var i = 0; i < reserved.length; ++i) {
                    if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] >= id) return true;
                  }
                  return false;
                };

                Namespace.isReservedName = function isReservedName(reserved, name) {
                  if (reserved) for (var i = 0; i < reserved.length; ++i) {
                    if (reserved[i] === name) return true;
                  }
                  return false;
                };

                function Namespace(name, options) {
                  ReflectionObject.call(this, name, options);
                  this.nested = undefined$1;
                  this._nestedArray = null;
                }

                function clearCache(namespace) {
                  namespace._nestedArray = null;
                  return namespace;
                }

                Object.defineProperty(Namespace.prototype, "nestedArray", {
                  get: function get() {
                    return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
                  }
                });

                Namespace.prototype.toJSON = function toJSON() {
                  return util.toObject(["options", this.options, "nested", arrayToJSON(this.nestedArray)]);
                };

                Namespace.prototype.addJSON = function addJSON(nestedJson) {
                  var ns = this;

                  if (nestedJson) {
                    for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
                      nested = nestedJson[names[i]];
                      ns.add((nested.fields !== undefined$1 ? Type.fromJSON : nested.values !== undefined$1 ? Enum.fromJSON : nested.methods !== undefined$1 ? Service.fromJSON : nested.id !== undefined$1 ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));
                    }
                  }

                  return this;
                };

                Namespace.prototype.get = function get(name) {
                  return this.nested && this.nested[name] || null;
                };

                Namespace.prototype.getEnum = function getEnum(name) {
                  if (this.nested && this.nested[name] instanceof Enum) return this.nested[name].values;
                  throw Error("no such enum");
                };

                Namespace.prototype.add = function add(object) {
                  if (!(object instanceof Field && object.extend !== undefined$1 || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace)) throw TypeError("object must be a valid nested object");
                  if (!this.nested) this.nested = {};else {
                    var prev = this.get(object.name);

                    if (prev) {
                      if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                        var nested = prev.nestedArray;

                        for (var i = 0; i < nested.length; ++i) {
                          object.add(nested[i]);
                        }

                        this.remove(prev);
                        if (!this.nested) this.nested = {};
                        object.setOptions(prev.options, true);
                      } else throw Error("duplicate name '" + object.name + "' in " + this);
                    }
                  }
                  this.nested[object.name] = object;
                  object.onAdd(this);
                  return clearCache(this);
                };

                Namespace.prototype.remove = function remove(object) {
                  if (!(object instanceof ReflectionObject)) throw TypeError("object must be a ReflectionObject");
                  if (object.parent !== this) throw Error(object + " is not a member of " + this);
                  delete this.nested[object.name];
                  if (!Object.keys(this.nested).length) this.nested = undefined$1;
                  object.onRemove(this);
                  return clearCache(this);
                };

                Namespace.prototype.define = function define(path, json) {
                  if (util.isString(path)) path = path.split(".");else if (!Array.isArray(path)) throw TypeError("illegal path");
                  if (path && path.length && path[0] === "") throw Error("path must be relative");
                  var ptr = this;

                  while (path.length > 0) {
                    var part = path.shift();

                    if (ptr.nested && ptr.nested[part]) {
                      ptr = ptr.nested[part];
                      if (!(ptr instanceof Namespace)) throw Error("path conflicts with non-namespace objects");
                    } else ptr.add(ptr = new Namespace(part));
                  }

                  if (json) ptr.addJSON(json);
                  return ptr;
                };

                Namespace.prototype.resolveAll = function resolveAll() {
                  var nested = this.nestedArray,
                      i = 0;

                  while (i < nested.length) {
                    if (nested[i] instanceof Namespace) nested[i++].resolveAll();else nested[i++].resolve();
                  }

                  return this.resolve();
                };

                Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {
                  if (typeof filterTypes === "boolean") {
                    parentAlreadyChecked = filterTypes;
                    filterTypes = undefined$1;
                  } else if (filterTypes && !Array.isArray(filterTypes)) filterTypes = [filterTypes];

                  if (util.isString(path) && path.length) {
                    if (path === ".") return this.root;
                    path = path.split(".");
                  } else if (!path.length) return this;

                  if (path[0] === "") return this.root.lookup(path.slice(1), filterTypes);
                  var found = this.get(path[0]);

                  if (found) {
                    if (path.length === 1) {
                      if (!filterTypes || filterTypes.indexOf(found.constructor) > -1) return found;
                    } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true))) return found;
                  } else for (var i = 0; i < this.nestedArray.length; ++i) {
                    if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true))) return found;
                  }

                  if (this.parent === null || parentAlreadyChecked) return null;
                  return this.parent.lookup(path, filterTypes);
                };

                Namespace.prototype.lookupType = function lookupType(path) {
                  var found = this.lookup(path, [Type]);
                  if (!found) throw Error("no such type");
                  return found;
                };

                Namespace.prototype.lookupEnum = function lookupEnum(path) {
                  var found = this.lookup(path, [Enum]);
                  if (!found) throw Error("no such Enum '" + path + "' in " + this);
                  return found;
                };

                Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
                  var found = this.lookup(path, [Type, Enum]);
                  if (!found) throw Error("no such Type or Enum '" + path + "' in " + this);
                  return found;
                };

                Namespace.prototype.lookupService = function lookupService(path) {
                  var found = this.lookup(path, [Service]);
                  if (!found) throw Error("no such Service '" + path + "' in " + this);
                  return found;
                };

                Namespace._configure = function (Type_, Service_) {
                  Type = Type_;
                  Service = Service_;
                };
              }, {
                15: 15,
                16: 16,
                24: 24,
                37: 37
              }],
              24: [function (require, module, exports) {
                module.exports = ReflectionObject;
                ReflectionObject.className = "ReflectionObject";

                var util = require(37);

                var Root;

                function ReflectionObject(name, options) {
                  if (!util.isString(name)) throw TypeError("name must be a string");
                  if (options && !util.isObject(options)) throw TypeError("options must be an object");
                  this.options = options;
                  this.name = name;
                  this.parent = null;
                  this.resolved = false;
                  this.comment = null;
                  this.filename = null;
                }

                Object.defineProperties(ReflectionObject.prototype, {
                  root: {
                    get: function get() {
                      var ptr = this;

                      while (ptr.parent !== null) {
                        ptr = ptr.parent;
                      }

                      return ptr;
                    }
                  },
                  fullName: {
                    get: function get() {
                      var path = [this.name],
                          ptr = this.parent;

                      while (ptr) {
                        path.unshift(ptr.name);
                        ptr = ptr.parent;
                      }

                      return path.join(".");
                    }
                  }
                });

                ReflectionObject.prototype.toJSON = function toJSON() {
                  throw Error();
                };

                ReflectionObject.prototype.onAdd = function onAdd(parent) {
                  if (this.parent && this.parent !== parent) this.parent.remove(this);
                  this.parent = parent;
                  this.resolved = false;
                  var root = parent.root;
                  if (root instanceof Root) root._handleAdd(this);
                };

                ReflectionObject.prototype.onRemove = function onRemove(parent) {
                  var root = parent.root;
                  if (root instanceof Root) root._handleRemove(this);
                  this.parent = null;
                  this.resolved = false;
                };

                ReflectionObject.prototype.resolve = function resolve() {
                  if (this.resolved) return this;
                  if (this.root instanceof Root) this.resolved = true;
                  return this;
                };

                ReflectionObject.prototype.getOption = function getOption(name) {
                  if (this.options) return this.options[name];
                  return undefined$1;
                };

                ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
                  if (!ifNotSet || !this.options || this.options[name] === undefined$1) (this.options || (this.options = {}))[name] = value;
                  return this;
                };

                ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
                  if (options) for (var keys = Object.keys(options), i = 0; i < keys.length; ++i) {
                    this.setOption(keys[i], options[keys[i]], ifNotSet);
                  }
                  return this;
                };

                ReflectionObject.prototype.toString = function toString() {
                  var className = this.constructor.className,
                      fullName = this.fullName;
                  if (fullName.length) return className + " " + fullName;
                  return className;
                };

                ReflectionObject._configure = function (Root_) {
                  Root = Root_;
                };
              }, {
                37: 37
              }],
              25: [function (require, module, exports) {
                module.exports = OneOf;

                var ReflectionObject = require(24);

                ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

                var Field = require(16),
                    util = require(37);

                function OneOf(name, fieldNames, options) {
                  if (!Array.isArray(fieldNames)) {
                    options = fieldNames;
                    fieldNames = undefined$1;
                  }

                  ReflectionObject.call(this, name, options);
                  if (!(fieldNames === undefined$1 || Array.isArray(fieldNames))) throw TypeError("fieldNames must be an Array");
                  this.oneof = fieldNames || [];
                  this.fieldsArray = [];
                }

                OneOf.fromJSON = function fromJSON(name, json) {
                  return new OneOf(name, json.oneof, json.options);
                };

                OneOf.prototype.toJSON = function toJSON() {
                  return util.toObject(["options", this.options, "oneof", this.oneof]);
                };

                function addFieldsToParent(oneof) {
                  if (oneof.parent) for (var i = 0; i < oneof.fieldsArray.length; ++i) {
                    if (!oneof.fieldsArray[i].parent) oneof.parent.add(oneof.fieldsArray[i]);
                  }
                }

                OneOf.prototype.add = function add(field) {
                  if (!(field instanceof Field)) throw TypeError("field must be a Field");
                  if (field.parent && field.parent !== this.parent) field.parent.remove(field);
                  this.oneof.push(field.name);
                  this.fieldsArray.push(field);
                  field.partOf = this;
                  addFieldsToParent(this);
                  return this;
                };

                OneOf.prototype.remove = function remove(field) {
                  if (!(field instanceof Field)) throw TypeError("field must be a Field");
                  var index = this.fieldsArray.indexOf(field);
                  if (index < 0) throw Error(field + " is not a member of " + this);
                  this.fieldsArray.splice(index, 1);
                  index = this.oneof.indexOf(field.name);
                  if (index > -1) this.oneof.splice(index, 1);
                  field.partOf = null;
                  return this;
                };

                OneOf.prototype.onAdd = function onAdd(parent) {
                  ReflectionObject.prototype.onAdd.call(this, parent);
                  var self = this;

                  for (var i = 0; i < this.oneof.length; ++i) {
                    var field = parent.get(this.oneof[i]);

                    if (field && !field.partOf) {
                      field.partOf = self;
                      self.fieldsArray.push(field);
                    }
                  }

                  addFieldsToParent(this);
                };

                OneOf.prototype.onRemove = function onRemove(parent) {
                  for (var i = 0, field; i < this.fieldsArray.length; ++i) {
                    if ((field = this.fieldsArray[i]).parent) field.parent.remove(field);
                  }

                  ReflectionObject.prototype.onRemove.call(this, parent);
                };

                OneOf.d = function decorateOneOf() {
                  var fieldNames = new Array(arguments.length),
                      index = 0;

                  while (index < arguments.length) {
                    fieldNames[index] = arguments[index++];
                  }

                  return function oneOfDecorator(prototype, oneofName) {
                    util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
                    Object.defineProperty(prototype, oneofName, {
                      get: util.oneOfGetter(fieldNames),
                      set: util.oneOfSetter(fieldNames)
                    });
                  };
                };
              }, {
                16: 16,
                24: 24,
                37: 37
              }],
              26: [function (require, module, exports) {
                module.exports = parse;
                parse.filename = null;
                parse.defaults = {
                  keepCase: false
                };

                var tokenize = require(34),
                    Root = require(29),
                    Type = require(35),
                    Field = require(16),
                    MapField = require(20),
                    OneOf = require(25),
                    Enum = require(15),
                    Service = require(33),
                    Method = require(22),
                    types = require(36),
                    util = require(37);

                var base10Re = /^[1-9][0-9]*$/,
                    base10NegRe = /^-?[1-9][0-9]*$/,
                    base16Re = /^0[x][0-9a-fA-F]+$/,
                    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
                    base8Re = /^0[0-7]+$/,
                    base8NegRe = /^-?0[0-7]+$/,
                    numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
                    nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
                    typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
                    fqTypeRefRe = /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/;

                function parse(source, root, options) {
                  if (!(root instanceof Root)) {
                    options = root;
                    root = new Root();
                  }

                  if (!options) options = parse.defaults;
                  var tn = tokenize(source),
                      next = tn.next,
                      push = tn.push,
                      peek = tn.peek,
                      skip = tn.skip,
                      cmnt = tn.cmnt;
                  var head = true,
                      pkg,
                      imports,
                      weakImports,
                      syntax,
                      isProto3 = false;
                  var ptr = root;
                  var applyCase = options.keepCase ? function (name) {
                    return name;
                  } : util.camelCase;

                  function illegal(token, name, insideTryCatch) {
                    var filename = parse.filename;
                    if (!insideTryCatch) parse.filename = null;
                    return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
                  }

                  function readString() {
                    var values = [],
                        token;

                    do {
                      if ((token = next()) !== '"' && token !== "'") throw illegal(token);
                      values.push(next());
                      skip(token);
                      token = peek();
                    } while (token === '"' || token === "'");

                    return values.join("");
                  }

                  function readValue(acceptTypeRef) {
                    var token = next();

                    switch (token) {
                      case "'":
                      case '"':
                        push(token);
                        return readString();

                      case "true":
                      case "TRUE":
                        return true;

                      case "false":
                      case "FALSE":
                        return false;
                    }

                    try {
                      return parseNumber(token, true);
                    } catch (e) {
                      if (acceptTypeRef && typeRefRe.test(token)) return token;
                      throw illegal(token, "value");
                    }
                  }

                  function readRanges(target, acceptStrings) {
                    var token, start;

                    do {
                      if (acceptStrings && ((token = peek()) === '"' || token === "'")) target.push(readString());else target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
                    } while (skip(",", true));

                    skip(";");
                  }

                  function parseNumber(token, insideTryCatch) {
                    var sign = 1;

                    if (token.charAt(0) === "-") {
                      sign = -1;
                      token = token.substring(1);
                    }

                    switch (token) {
                      case "inf":
                      case "INF":
                      case "Inf":
                        return sign * Infinity;

                      case "nan":
                      case "NAN":
                      case "Nan":
                      case "NaN":
                        return NaN;

                      case "0":
                        return 0;
                    }

                    if (base10Re.test(token)) return sign * parseInt(token, 10);
                    if (base16Re.test(token)) return sign * parseInt(token, 16);
                    if (base8Re.test(token)) return sign * parseInt(token, 8);
                    if (numberRe.test(token)) return sign * parseFloat(token);
                    throw illegal(token, "number", insideTryCatch);
                  }

                  function parseId(token, acceptNegative) {
                    switch (token) {
                      case "max":
                      case "MAX":
                      case "Max":
                        return 536870911;

                      case "0":
                        return 0;
                    }

                    if (!acceptNegative && token.charAt(0) === "-") throw illegal(token, "id");
                    if (base10NegRe.test(token)) return parseInt(token, 10);
                    if (base16NegRe.test(token)) return parseInt(token, 16);
                    if (base8NegRe.test(token)) return parseInt(token, 8);
                    throw illegal(token, "id");
                  }

                  function parsePackage() {
                    if (pkg !== undefined$1) throw illegal("package");
                    pkg = next();
                    if (!typeRefRe.test(pkg)) throw illegal(pkg, "name");
                    ptr = ptr.define(pkg);
                    skip(";");
                  }

                  function parseImport() {
                    var token = peek();
                    var whichImports;

                    switch (token) {
                      case "weak":
                        whichImports = weakImports || (weakImports = []);
                        next();
                        break;

                      case "public":
                        next();

                      default:
                        whichImports = imports || (imports = []);
                        break;
                    }

                    token = readString();
                    skip(";");
                    whichImports.push(token);
                  }

                  function parseSyntax() {
                    skip("=");
                    syntax = readString();
                    isProto3 = syntax === "proto3";
                    if (!isProto3 && syntax !== "proto2") throw illegal(syntax, "syntax");
                    skip(";");
                  }

                  function parseCommon(parent, token) {
                    switch (token) {
                      case "option":
                        parseOption(parent, token);
                        skip(";");
                        return true;

                      case "message":
                        parseType(parent, token);
                        return true;

                      case "enum":
                        parseEnum(parent, token);
                        return true;

                      case "service":
                        parseService(parent, token);
                        return true;

                      case "extend":
                        parseExtension(parent, token);
                        return true;
                    }

                    return false;
                  }

                  function ifBlock(obj, fnIf, fnElse) {
                    var trailingLine = tn.line;

                    if (obj) {
                      obj.comment = cmnt();
                      obj.filename = parse.filename;
                    }

                    if (skip("{", true)) {
                      var token;

                      while ((token = next()) !== "}") {
                        fnIf(token);
                      }

                      skip(";", true);
                    } else {
                      if (fnElse) fnElse();
                      skip(";");
                      if (obj && typeof obj.comment !== "string") obj.comment = cmnt(trailingLine);
                    }
                  }

                  function parseType(parent, token) {
                    if (!nameRe.test(token = next())) throw illegal(token, "type name");
                    var type = new Type(token);
                    ifBlock(type, function parseType_block(token) {
                      if (parseCommon(type, token)) return;

                      switch (token) {
                        case "map":
                          parseMapField(type);
                          break;

                        case "required":
                        case "optional":
                        case "repeated":
                          parseField(type, token);
                          break;

                        case "oneof":
                          parseOneOf(type, token);
                          break;

                        case "extensions":
                          readRanges(type.extensions || (type.extensions = []));
                          break;

                        case "reserved":
                          readRanges(type.reserved || (type.reserved = []), true);
                          break;

                        default:
                          if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);
                          push(token);
                          parseField(type, "optional");
                          break;
                      }
                    });
                    parent.add(type);
                  }

                  function parseField(parent, rule, extend) {
                    var type = next();

                    if (type === "group") {
                      parseGroup(parent, rule);
                      return;
                    }

                    if (!typeRefRe.test(type)) throw illegal(type, "type");
                    var name = next();
                    if (!nameRe.test(name)) throw illegal(name, "name");
                    name = applyCase(name);
                    skip("=");
                    var field = new Field(name, parseId(next()), type, rule, extend);
                    ifBlock(field, function parseField_block(token) {
                      if (token === "option") {
                        parseOption(field, token);
                        skip(";");
                      } else throw illegal(token);
                    }, function parseField_line() {
                      parseInlineOptions(field);
                    });
                    parent.add(field);
                    if (!isProto3 && field.repeated && (types.packed[type] !== undefined$1 || types.basic[type] === undefined$1)) field.setOption("packed", false, true);
                  }

                  function parseGroup(parent, rule) {
                    var name = next();
                    if (!nameRe.test(name)) throw illegal(name, "name");
                    var fieldName = util.lcFirst(name);
                    if (name === fieldName) name = util.ucFirst(name);
                    skip("=");
                    var id = parseId(next());
                    var type = new Type(name);
                    type.group = true;
                    var field = new Field(fieldName, id, name, rule);
                    field.filename = parse.filename;
                    ifBlock(type, function parseGroup_block(token) {
                      switch (token) {
                        case "option":
                          parseOption(type, token);
                          skip(";");
                          break;

                        case "required":
                        case "optional":
                        case "repeated":
                          parseField(type, token);
                          break;

                        default:
                          throw illegal(token);
                      }
                    });
                    parent.add(type).add(field);
                  }

                  function parseMapField(parent) {
                    skip("<");
                    var keyType = next();
                    if (types.mapKey[keyType] === undefined$1) throw illegal(keyType, "type");
                    skip(",");
                    var valueType = next();
                    if (!typeRefRe.test(valueType)) throw illegal(valueType, "type");
                    skip(">");
                    var name = next();
                    if (!nameRe.test(name)) throw illegal(name, "name");
                    skip("=");
                    var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
                    ifBlock(field, function parseMapField_block(token) {
                      if (token === "option") {
                        parseOption(field, token);
                        skip(";");
                      } else throw illegal(token);
                    }, function parseMapField_line() {
                      parseInlineOptions(field);
                    });
                    parent.add(field);
                  }

                  function parseOneOf(parent, token) {
                    if (!nameRe.test(token = next())) throw illegal(token, "name");
                    var oneof = new OneOf(applyCase(token));
                    ifBlock(oneof, function parseOneOf_block(token) {
                      if (token === "option") {
                        parseOption(oneof, token);
                        skip(";");
                      } else {
                        push(token);
                        parseField(oneof, "optional");
                      }
                    });
                    parent.add(oneof);
                  }

                  function parseEnum(parent, token) {
                    if (!nameRe.test(token = next())) throw illegal(token, "name");
                    var enm = new Enum(token);
                    ifBlock(enm, function parseEnum_block(token) {
                      switch (token) {
                        case "option":
                          parseOption(enm, token);
                          skip(";");
                          break;

                        case "reserved":
                          readRanges(enm.reserved || (enm.reserved = []), true);
                          break;

                        default:
                          parseEnumValue(enm, token);
                      }
                    });
                    parent.add(enm);
                  }

                  function parseEnumValue(parent, token) {
                    if (!nameRe.test(token)) throw illegal(token, "name");
                    skip("=");
                    var value = parseId(next(), true),
                        dummy = {};
                    ifBlock(dummy, function parseEnumValue_block(token) {
                      if (token === "option") {
                        parseOption(dummy, token);
                        skip(";");
                      } else throw illegal(token);
                    }, function parseEnumValue_line() {
                      parseInlineOptions(dummy);
                    });
                    parent.add(token, value, dummy.comment);
                  }

                  function parseOption(parent, token) {
                    var isCustom = skip("(", true);
                    if (!typeRefRe.test(token = next())) throw illegal(token, "name");
                    var name = token;

                    if (isCustom) {
                      skip(")");
                      name = "(" + name + ")";
                      token = peek();

                      if (fqTypeRefRe.test(token)) {
                        name += token;
                        next();
                      }
                    }

                    skip("=");
                    parseOptionValue(parent, name);
                  }

                  function parseOptionValue(parent, name) {
                    if (skip("{", true)) {
                      do {
                        if (!nameRe.test(token = next())) throw illegal(token, "name");
                        if (peek() === "{") parseOptionValue(parent, name + "." + token);else {
                          skip(":");
                          if (peek() === "{") parseOptionValue(parent, name + "." + token);else setOption(parent, name + "." + token, readValue(true));
                        }
                      } while (!skip("}", true));
                    } else setOption(parent, name, readValue(true));
                  }

                  function setOption(parent, name, value) {
                    if (parent.setOption) parent.setOption(name, value);
                  }

                  function parseInlineOptions(parent) {
                    if (skip("[", true)) {
                      do {
                        parseOption(parent, "option");
                      } while (skip(",", true));

                      skip("]");
                    }

                    return parent;
                  }

                  function parseService(parent, token) {
                    if (!nameRe.test(token = next())) throw illegal(token, "service name");
                    var service = new Service(token);
                    ifBlock(service, function parseService_block(token) {
                      if (parseCommon(service, token)) return;
                      if (token === "rpc") parseMethod(service, token);else throw illegal(token);
                    });
                    parent.add(service);
                  }

                  function parseMethod(parent, token) {
                    var type = token;
                    if (!nameRe.test(token = next())) throw illegal(token, "name");
                    var name = token,
                        requestType,
                        requestStream,
                        responseType,
                        responseStream;
                    skip("(");
                    if (skip("stream", true)) requestStream = true;
                    if (!typeRefRe.test(token = next())) throw illegal(token);
                    requestType = token;
                    skip(")");
                    skip("returns");
                    skip("(");
                    if (skip("stream", true)) responseStream = true;
                    if (!typeRefRe.test(token = next())) throw illegal(token);
                    responseType = token;
                    skip(")");
                    var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
                    ifBlock(method, function parseMethod_block(token) {
                      if (token === "option") {
                        parseOption(method, token);
                        skip(";");
                      } else throw illegal(token);
                    });
                    parent.add(method);
                  }

                  function parseExtension(parent, token) {
                    if (!typeRefRe.test(token = next())) throw illegal(token, "reference");
                    var reference = token;
                    ifBlock(null, function parseExtension_block(token) {
                      switch (token) {
                        case "required":
                        case "repeated":
                        case "optional":
                          parseField(parent, token, reference);
                          break;

                        default:
                          if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);
                          push(token);
                          parseField(parent, "optional", reference);
                          break;
                      }
                    });
                  }

                  var token;

                  while ((token = next()) !== null) {
                    switch (token) {
                      case "package":
                        if (!head) throw illegal(token);
                        parsePackage();
                        break;

                      case "import":
                        if (!head) throw illegal(token);
                        parseImport();
                        break;

                      case "syntax":
                        if (!head) throw illegal(token);
                        parseSyntax();
                        break;

                      case "option":
                        if (!head) throw illegal(token);
                        parseOption(ptr, token);
                        skip(";");
                        break;

                      default:
                        if (parseCommon(ptr, token)) {
                          head = false;
                          continue;
                        }

                        throw illegal(token);
                    }
                  }

                  parse.filename = null;
                  return {
                    "package": pkg,
                    imports: imports,
                    weakImports: weakImports,
                    syntax: syntax,
                    root: root
                  };
                }
              }, {
                15: 15,
                16: 16,
                20: 20,
                22: 22,
                25: 25,
                29: 29,
                33: 33,
                34: 34,
                35: 35,
                36: 36,
                37: 37
              }],
              27: [function (require, module, exports) {
                module.exports = Reader;

                var util = require(39);

                var BufferReader;
                var LongBits = util.LongBits,
                    utf8 = util.utf8;

                function indexOutOfRange(reader, writeLength) {
                  return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
                }

                function Reader(buffer) {
                  this.buf = buffer;
                  this.pos = 0;
                  this.len = buffer.length;
                }

                var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
                  if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);
                  throw Error("illegal buffer");
                } : function create_array(buffer) {
                  if (Array.isArray(buffer)) return new Reader(buffer);
                  throw Error("illegal buffer");
                };
                Reader.create = util.Buffer ? function create_buffer_setup(buffer) {
                  return (Reader.create = function create_buffer(buffer) {
                    return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer) : create_array(buffer);
                  })(buffer);
                } : create_array;
                Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;

                Reader.prototype.uint32 = function read_uint32_setup() {
                  var value = 4294967295;
                  return function read_uint32() {
                    value = (this.buf[this.pos] & 127) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;

                    if ((this.pos += 5) > this.len) {
                      this.pos = this.len;
                      throw indexOutOfRange(this, 10);
                    }

                    return value;
                  };
                }();

                Reader.prototype.int32 = function read_int32() {
                  return this.uint32() | 0;
                };

                Reader.prototype.sint32 = function read_sint32() {
                  var value = this.uint32();
                  return value >>> 1 ^ -(value & 1) | 0;
                };

                function readLongVarint() {
                  var bits = new LongBits(0, 0);
                  var i = 0;

                  if (this.len - this.pos > 4) {
                    for (; i < 4; ++i) {
                      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
                      if (this.buf[this.pos++] < 128) return bits;
                    }

                    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
                    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
                    if (this.buf[this.pos++] < 128) return bits;
                    i = 0;
                  } else {
                    for (; i < 3; ++i) {
                      if (this.pos >= this.len) throw indexOutOfRange(this);
                      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
                      if (this.buf[this.pos++] < 128) return bits;
                    }

                    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
                    return bits;
                  }

                  if (this.len - this.pos > 4) {
                    for (; i < 5; ++i) {
                      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
                      if (this.buf[this.pos++] < 128) return bits;
                    }
                  } else {
                    for (; i < 5; ++i) {
                      if (this.pos >= this.len) throw indexOutOfRange(this);
                      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
                      if (this.buf[this.pos++] < 128) return bits;
                    }
                  }

                  throw Error("invalid varint encoding");
                }

                Reader.prototype.bool = function read_bool() {
                  return this.uint32() !== 0;
                };

                function readFixed32_end(buf, end) {
                  return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
                }

                Reader.prototype.fixed32 = function read_fixed32() {
                  if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
                  return readFixed32_end(this.buf, this.pos += 4);
                };

                Reader.prototype.sfixed32 = function read_sfixed32() {
                  if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
                  return readFixed32_end(this.buf, this.pos += 4) | 0;
                };

                function readFixed64() {
                  if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
                  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
                }

                Reader.prototype["float"] = function read_float() {
                  if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
                  var value = util["float"].readFloatLE(this.buf, this.pos);
                  this.pos += 4;
                  return value;
                };

                Reader.prototype["double"] = function read_double() {
                  if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
                  var value = util["float"].readDoubleLE(this.buf, this.pos);
                  this.pos += 8;
                  return value;
                };

                Reader.prototype.bytes = function read_bytes() {
                  var length = this.uint32(),
                      start = this.pos,
                      end = this.pos + length;
                  if (end > this.len) throw indexOutOfRange(this, length);
                  this.pos += length;
                  if (Array.isArray(this.buf)) return this.buf.slice(start, end);
                  return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
                };

                Reader.prototype.string = function read_string() {
                  var bytes = this.bytes();
                  return utf8.read(bytes, 0, bytes.length);
                };

                Reader.prototype.skip = function skip(length) {
                  if (typeof length === "number") {
                    if (this.pos + length > this.len) throw indexOutOfRange(this, length);
                    this.pos += length;
                  } else {
                    do {
                      if (this.pos >= this.len) throw indexOutOfRange(this);
                    } while (this.buf[this.pos++] & 128);
                  }

                  return this;
                };

                Reader.prototype.skipType = function (wireType) {
                  switch (wireType) {
                    case 0:
                      this.skip();
                      break;

                    case 1:
                      this.skip(8);
                      break;

                    case 2:
                      this.skip(this.uint32());
                      break;

                    case 3:
                      do {
                        if ((wireType = this.uint32() & 7) === 4) break;
                        this.skipType(wireType);
                      } while (true);

                      break;

                    case 5:
                      this.skip(4);
                      break;

                    default:
                      throw Error("invalid wire type " + wireType + " at offset " + this.pos);
                  }

                  return this;
                };

                Reader._configure = function (BufferReader_) {
                  BufferReader = BufferReader_;
                  var fn = util.Long ? "toLong" : "toNumber";
                  util.merge(Reader.prototype, {
                    int64: function read_int64() {
                      return readLongVarint.call(this)[fn](false);
                    },
                    uint64: function read_uint64() {
                      return readLongVarint.call(this)[fn](true);
                    },
                    sint64: function read_sint64() {
                      return readLongVarint.call(this).zzDecode()[fn](false);
                    },
                    fixed64: function read_fixed64() {
                      return readFixed64.call(this)[fn](true);
                    },
                    sfixed64: function read_sfixed64() {
                      return readFixed64.call(this)[fn](false);
                    }
                  });
                };
              }, {
                39: 39
              }],
              28: [function (require, module, exports) {
                module.exports = BufferReader;

                var Reader = require(27);

                (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

                var util = require(39);

                function BufferReader(buffer) {
                  Reader.call(this, buffer);
                }

                if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;

                BufferReader.prototype.string = function read_string_buffer() {
                  var len = this.uint32();
                  return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
                };
              }, {
                27: 27,
                39: 39
              }],
              29: [function (require, module, exports) {
                module.exports = Root;

                var Namespace = require(23);

                ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

                var Field = require(16),
                    Enum = require(15),
                    OneOf = require(25),
                    util = require(37);

                var Type, parse, common;

                function Root(options) {
                  Namespace.call(this, "", options);
                  this.deferred = [];
                  this.files = [];
                }

                Root.fromJSON = function fromJSON(json, root) {
                  if (!root) root = new Root();
                  if (json.options) root.setOptions(json.options);
                  return root.addJSON(json.nested);
                };

                Root.prototype.resolvePath = util.path.resolve;

                function SYNC() {}

                Root.prototype.load = function load(filename, options, callback) {
                  if (typeof options === "function") {
                    callback = options;
                    options = undefined$1;
                  }

                  var self = this;
                  if (!callback) return util.asPromise(load, self, filename, options);
                  var sync = callback === SYNC;

                  function finish(err, root) {
                    if (!callback) return;
                    var cb = callback;
                    callback = null;
                    if (sync) throw err;
                    cb(err, root);
                  }

                  function process(filename, source) {
                    try {
                      if (util.isString(source) && source.charAt(0) === "{") source = JSON.parse(source);
                      if (!util.isString(source)) self.setOptions(source.options).addJSON(source.nested);else {
                        parse.filename = filename;
                        var parsed = parse(source, self, options),
                            resolved,
                            i = 0;
                        if (parsed.imports) for (; i < parsed.imports.length; ++i) {
                          if (resolved = self.resolvePath(filename, parsed.imports[i])) fetch(resolved);
                        }
                        if (parsed.weakImports) for (i = 0; i < parsed.weakImports.length; ++i) {
                          if (resolved = self.resolvePath(filename, parsed.weakImports[i])) fetch(resolved, true);
                        }
                      }
                    } catch (err) {
                      finish(err);
                    }

                    if (!sync && !queued) finish(null, self);
                  }

                  function fetch(filename, weak) {
                    var idx = filename.lastIndexOf("google/protobuf/");

                    if (idx > -1) {
                      var altname = filename.substring(idx);
                      if (altname in common) filename = altname;
                    }

                    if (self.files.indexOf(filename) > -1) return;
                    self.files.push(filename);

                    if (filename in common) {
                      if (sync) process(filename, common[filename]);else {
                        ++queued;
                        setTimeout(function () {
                          --queued;
                          process(filename, common[filename]);
                        });
                      }
                      return;
                    }

                    if (sync) {
                      var source;

                      try {
                        source = util.fs.readFileSync(filename).toString("utf8");
                      } catch (err) {
                        if (!weak) finish(err);
                        return;
                      }

                      process(filename, source);
                    } else {
                      ++queued;
                      util.fetch(filename, function (err, source) {
                        --queued;
                        if (!callback) return;

                        if (err) {
                          if (!weak) finish(err);else if (!queued) finish(null, self);
                          return;
                        }

                        process(filename, source);
                      });
                    }
                  }

                  var queued = 0;
                  if (util.isString(filename)) filename = [filename];

                  for (var i = 0, resolved; i < filename.length; ++i) {
                    if (resolved = self.resolvePath("", filename[i])) fetch(resolved);
                  }

                  if (sync) return self;
                  if (!queued) finish(null, self);
                  return undefined$1;
                };

                Root.prototype.loadSync = function loadSync(filename, options) {
                  if (!util.isNode) throw Error("not supported");
                  return this.load(filename, options, SYNC);
                };

                Root.prototype.resolveAll = function resolveAll() {
                  if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function (field) {
                    return "'extend " + field.extend + "' in " + field.parent.fullName;
                  }).join(", "));
                  return Namespace.prototype.resolveAll.call(this);
                };

                var exposeRe = /^[A-Z]/;

                function tryHandleExtension(root, field) {
                  var extendedType = field.parent.lookup(field.extend);

                  if (extendedType) {
                    var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined$1, field.options);
                    sisterField.declaringField = field;
                    field.extensionField = sisterField;
                    extendedType.add(sisterField);
                    return true;
                  }

                  return false;
                }

                Root.prototype._handleAdd = function _handleAdd(object) {
                  if (object instanceof Field) {
                    if (object.extend !== undefined$1 && !object.extensionField) if (!tryHandleExtension(this, object)) this.deferred.push(object);
                  } else if (object instanceof Enum) {
                    if (exposeRe.test(object.name)) object.parent[object.name] = object.values;
                  } else if (!(object instanceof OneOf)) {
                    if (object instanceof Type) for (var i = 0; i < this.deferred.length;) {
                      if (tryHandleExtension(this, this.deferred[i])) this.deferred.splice(i, 1);else ++i;
                    }

                    for (var j = 0; j < object.nestedArray.length; ++j) {
                      this._handleAdd(object._nestedArray[j]);
                    }

                    if (exposeRe.test(object.name)) object.parent[object.name] = object;
                  }
                };

                Root.prototype._handleRemove = function _handleRemove(object) {
                  if (object instanceof Field) {
                    if (object.extend !== undefined$1) {
                      if (object.extensionField) {
                        object.extensionField.parent.remove(object.extensionField);
                        object.extensionField = null;
                      } else {
                        var index = this.deferred.indexOf(object);
                        if (index > -1) this.deferred.splice(index, 1);
                      }
                    }
                  } else if (object instanceof Enum) {
                    if (exposeRe.test(object.name)) delete object.parent[object.name];
                  } else if (object instanceof Namespace) {
                    for (var i = 0; i < object.nestedArray.length; ++i) {
                      this._handleRemove(object._nestedArray[i]);
                    }

                    if (exposeRe.test(object.name)) delete object.parent[object.name];
                  }
                };

                Root._configure = function (Type_, parse_, common_) {
                  Type = Type_;
                  parse = parse_;
                  common = common_;
                };
              }, {
                15: 15,
                16: 16,
                23: 23,
                25: 25,
                37: 37
              }],
              30: [function (require, module, exports) {
                module.exports = {};
              }, {}],
              31: [function (require, module, exports) {
                var rpc = exports;
                rpc.Service = require(32);
              }, {
                32: 32
              }],
              32: [function (require, module, exports) {
                module.exports = Service;

                var util = require(39);

                (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

                function Service(rpcImpl, requestDelimited, responseDelimited) {
                  if (typeof rpcImpl !== "function") throw TypeError("rpcImpl must be a function");
                  util.EventEmitter.call(this);
                  this.rpcImpl = rpcImpl;
                  this.requestDelimited = Boolean(requestDelimited);
                  this.responseDelimited = Boolean(responseDelimited);
                }

                Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
                  if (!request) throw TypeError("request must be specified");
                  var self = this;
                  if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

                  if (!self.rpcImpl) {
                    setTimeout(function () {
                      callback(Error("already ended"));
                    }, 0);
                    return undefined$1;
                  }

                  try {
                    return self.rpcImpl(method, requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
                      if (err) {
                        self.emit("error", err, method);
                        return callback(err);
                      }

                      if (response === null) {
                        self.end(true);
                        return undefined$1;
                      }

                      if (!(response instanceof responseCtor)) {
                        try {
                          response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                        } catch (err) {
                          self.emit("error", err, method);
                          return callback(err);
                        }
                      }

                      self.emit("data", response, method);
                      return callback(null, response);
                    });
                  } catch (err) {
                    self.emit("error", err, method);
                    setTimeout(function () {
                      callback(err);
                    }, 0);
                    return undefined$1;
                  }
                };

                Service.prototype.end = function end(endedByRPC) {
                  if (this.rpcImpl) {
                    if (!endedByRPC) this.rpcImpl(null, null, null);
                    this.rpcImpl = null;
                    this.emit("end").off();
                  }

                  return this;
                };
              }, {
                39: 39
              }],
              33: [function (require, module, exports) {
                module.exports = Service;

                var Namespace = require(23);

                ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

                var Method = require(22),
                    util = require(37),
                    rpc = require(31);

                function Service(name, options) {
                  Namespace.call(this, name, options);
                  this.methods = {};
                  this._methodsArray = null;
                }

                Service.fromJSON = function fromJSON(name, json) {
                  var service = new Service(name, json.options);
                  if (json.methods) for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i) {
                    service.add(Method.fromJSON(names[i], json.methods[names[i]]));
                  }
                  if (json.nested) service.addJSON(json.nested);
                  return service;
                };

                Service.prototype.toJSON = function toJSON() {
                  var inherited = Namespace.prototype.toJSON.call(this);
                  return util.toObject(["options", inherited && inherited.options || undefined$1, "methods", Namespace.arrayToJSON(this.methodsArray) || {}, "nested", inherited && inherited.nested || undefined$1]);
                };

                Object.defineProperty(Service.prototype, "methodsArray", {
                  get: function get() {
                    return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
                  }
                });

                function clearCache(service) {
                  service._methodsArray = null;
                  return service;
                }

                Service.prototype.get = function get(name) {
                  return this.methods[name] || Namespace.prototype.get.call(this, name);
                };

                Service.prototype.resolveAll = function resolveAll() {
                  var methods = this.methodsArray;

                  for (var i = 0; i < methods.length; ++i) {
                    methods[i].resolve();
                  }

                  return Namespace.prototype.resolve.call(this);
                };

                Service.prototype.add = function add(object) {
                  if (this.get(object.name)) throw Error("duplicate name '" + object.name + "' in " + this);

                  if (object instanceof Method) {
                    this.methods[object.name] = object;
                    object.parent = this;
                    return clearCache(this);
                  }

                  return Namespace.prototype.add.call(this, object);
                };

                Service.prototype.remove = function remove(object) {
                  if (object instanceof Method) {
                    if (this.methods[object.name] !== object) throw Error(object + " is not a member of " + this);
                    delete this.methods[object.name];
                    object.parent = null;
                    return clearCache(this);
                  }

                  return Namespace.prototype.remove.call(this, object);
                };

                Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                  var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);

                  for (var i = 0, method; i < this.methodsArray.length; ++i) {
                    var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
                    rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
                      m: method,
                      q: method.resolvedRequestType.ctor,
                      s: method.resolvedResponseType.ctor
                    });
                  }

                  return rpcService;
                };
              }, {
                22: 22,
                23: 23,
                31: 31,
                37: 37
              }],
              34: [function (require, module, exports) {
                module.exports = tokenize;
                var delimRe = /[\s{}=;:[\],'"()<>]/g,
                    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
                    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
                var setCommentRe = /^ *[*/]+ */,
                    setCommentSplitRe = /\n/g,
                    whitespaceRe = /\s/,
                    unescapeRe = /\\(.?)/g;
                var unescapeMap = {
                  0: "\0",
                  r: "\r",
                  n: "\n",
                  t: "\t"
                };

                function unescape(str) {
                  return str.replace(unescapeRe, function ($0, $1) {
                    switch ($1) {
                      case "\\":
                      case "":
                        return $1;

                      default:
                        return unescapeMap[$1] || "";
                    }
                  });
                }

                tokenize.unescape = unescape;

                function tokenize(source) {
                  source = source.toString();
                  var offset = 0,
                      length = source.length,
                      line = 1,
                      commentType = null,
                      commentText = null,
                      commentLine = 0,
                      commentLineEmpty = false;
                  var stack = [];
                  var stringDelim = null;

                  function illegal(subject) {
                    return Error("illegal " + subject + " (line " + line + ")");
                  }

                  function readString() {
                    var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
                    re.lastIndex = offset - 1;
                    var match = re.exec(source);
                    if (!match) throw illegal("string");
                    offset = re.lastIndex;
                    push(stringDelim);
                    stringDelim = null;
                    return unescape(match[1]);
                  }

                  function charAt(pos) {
                    return source.charAt(pos);
                  }

                  function setComment(start, end) {
                    commentType = source.charAt(start++);
                    commentLine = line;
                    commentLineEmpty = false;
                    var offset = start - 3,
                        c;

                    do {
                      if (--offset < 0 || (c = source.charAt(offset)) === "\n") {
                        commentLineEmpty = true;
                        break;
                      }
                    } while (c === " " || c === "\t");

                    var lines = source.substring(start, end).split(setCommentSplitRe);

                    for (var i = 0; i < lines.length; ++i) {
                      lines[i] = lines[i].replace(setCommentRe, "").trim();
                    }

                    commentText = lines.join("\n").trim();
                  }

                  function next() {
                    if (stack.length > 0) return stack.shift();
                    if (stringDelim) return readString();
                    var repeat, prev, curr, start, isDoc;

                    do {
                      if (offset === length) return null;
                      repeat = false;

                      while (whitespaceRe.test(curr = charAt(offset))) {
                        if (curr === "\n") ++line;
                        if (++offset === length) return null;
                      }

                      if (charAt(offset) === "/") {
                        if (++offset === length) throw illegal("comment");

                        if (charAt(offset) === "/") {
                          isDoc = charAt(start = offset + 1) === "/";

                          while (charAt(++offset) !== "\n") {
                            if (offset === length) return null;
                          }

                          ++offset;
                          if (isDoc) setComment(start, offset - 1);
                          ++line;
                          repeat = true;
                        } else if ((curr = charAt(offset)) === "*") {
                          isDoc = charAt(start = offset + 1) === "*";

                          do {
                            if (curr === "\n") ++line;
                            if (++offset === length) throw illegal("comment");
                            prev = curr;
                            curr = charAt(offset);
                          } while (prev !== "*" || curr !== "/");

                          ++offset;
                          if (isDoc) setComment(start, offset - 2);
                          repeat = true;
                        } else return "/";
                      }
                    } while (repeat);

                    var end = offset;
                    delimRe.lastIndex = 0;
                    var delim = delimRe.test(charAt(end++));
                    if (!delim) while (end < length && !delimRe.test(charAt(end))) {
                      ++end;
                    }
                    var token = source.substring(offset, offset = end);
                    if (token === '"' || token === "'") stringDelim = token;
                    return token;
                  }

                  function push(token) {
                    stack.push(token);
                  }

                  function peek() {
                    if (!stack.length) {
                      var token = next();
                      if (token === null) return null;
                      push(token);
                    }

                    return stack[0];
                  }

                  function skip(expected, optional) {
                    var actual = peek(),
                        equals = actual === expected;

                    if (equals) {
                      next();
                      return true;
                    }

                    if (!optional) throw illegal("token '" + actual + "', '" + expected + "' expected");
                    return false;
                  }

                  function cmnt(trailingLine) {
                    var ret = null;

                    if (trailingLine === undefined$1) {
                      if (commentLine === line - 1 && (commentType === "*" || commentLineEmpty)) ret = commentText;
                    } else {
                      if (commentLine < trailingLine) peek();
                      if (commentLine === trailingLine && !commentLineEmpty && commentType === "/") ret = commentText;
                    }

                    return ret;
                  }

                  return Object.defineProperty({
                    next: next,
                    peek: peek,
                    push: push,
                    skip: skip,
                    cmnt: cmnt
                  }, "line", {
                    get: function get() {
                      return line;
                    }
                  });
                }
              }, {}],
              35: [function (require, module, exports) {
                module.exports = Type;

                var Namespace = require(23);

                ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

                var Enum = require(15),
                    OneOf = require(25),
                    Field = require(16),
                    MapField = require(20),
                    Service = require(33),
                    Message = require(21),
                    Reader = require(27),
                    Writer = require(42),
                    util = require(37),
                    encoder = require(14),
                    decoder = require(13),
                    verifier = require(40),
                    converter = require(12),
                    wrappers = require(41);

                function Type(name, options) {
                  Namespace.call(this, name, options);
                  this.fields = {};
                  this.oneofs = undefined$1;
                  this.extensions = undefined$1;
                  this.reserved = undefined$1;
                  this.group = undefined$1;
                  this._fieldsById = null;
                  this._fieldsArray = null;
                  this._oneofsArray = null;
                  this._ctor = null;
                }

                Object.defineProperties(Type.prototype, {
                  fieldsById: {
                    get: function get() {
                      if (this._fieldsById) return this._fieldsById;
                      this._fieldsById = {};

                      for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                        var field = this.fields[names[i]],
                            id = field.id;
                        if (this._fieldsById[id]) throw Error("duplicate id " + id + " in " + this);
                        this._fieldsById[id] = field;
                      }

                      return this._fieldsById;
                    }
                  },
                  fieldsArray: {
                    get: function get() {
                      return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
                    }
                  },
                  oneofsArray: {
                    get: function get() {
                      return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
                    }
                  },
                  ctor: {
                    get: function get() {
                      return this._ctor || (this.ctor = Type.generateConstructor(this)());
                    },
                    set: function set(ctor) {
                      var prototype = ctor.prototype;

                      if (!(prototype instanceof Message)) {
                        (ctor.prototype = new Message()).constructor = ctor;
                        util.merge(ctor.prototype, prototype);
                      }

                      ctor.$type = ctor.prototype.$type = this;
                      util.merge(ctor, Message, true);
                      this._ctor = ctor;
                      var i = 0;

                      for (; i < this.fieldsArray.length; ++i) {
                        this._fieldsArray[i].resolve();
                      }

                      var ctorProperties = {};

                      for (i = 0; i < this.oneofsArray.length; ++i) {
                        ctorProperties[this._oneofsArray[i].resolve().name] = {
                          get: util.oneOfGetter(this._oneofsArray[i].oneof),
                          set: util.oneOfSetter(this._oneofsArray[i].oneof)
                        };
                      }

                      if (i) Object.defineProperties(ctor.prototype, ctorProperties);
                    }
                  }
                });

                Type.generateConstructor = function generateConstructor(mtype) {
                  var gen = util.codegen(["p"], mtype.name);

                  for (var i = 0, field; i < mtype.fieldsArray.length; ++i) {
                    if ((field = mtype._fieldsArray[i]).map) gen("this%s={}", util.safeProp(field.name));else if (field.repeated) gen("this%s=[]", util.safeProp(field.name));
                  }

                  return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
                };

                function clearCache(type) {
                  type._fieldsById = type._fieldsArray = type._oneofsArray = null;
                  delete type.encode;
                  delete type.decode;
                  delete type.verify;
                  return type;
                }

                Type.fromJSON = function fromJSON(name, json) {
                  var type = new Type(name, json.options);
                  type.extensions = json.extensions;
                  type.reserved = json.reserved;
                  var names = Object.keys(json.fields),
                      i = 0;

                  for (; i < names.length; ++i) {
                    type.add((typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));
                  }

                  if (json.oneofs) for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i) {
                    type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
                  }
                  if (json.nested) for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
                    var nested = json.nested[names[i]];
                    type.add((nested.id !== undefined$1 ? Field.fromJSON : nested.fields !== undefined$1 ? Type.fromJSON : nested.values !== undefined$1 ? Enum.fromJSON : nested.methods !== undefined$1 ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));
                  }
                  if (json.extensions && json.extensions.length) type.extensions = json.extensions;
                  if (json.reserved && json.reserved.length) type.reserved = json.reserved;
                  if (json.group) type.group = true;
                  return type;
                };

                Type.prototype.toJSON = function toJSON() {
                  var inherited = Namespace.prototype.toJSON.call(this);
                  return util.toObject(["options", inherited && inherited.options || undefined$1, "oneofs", Namespace.arrayToJSON(this.oneofsArray), "fields", Namespace.arrayToJSON(this.fieldsArray.filter(function (obj) {
                    return !obj.declaringField;
                  })) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions : undefined$1, "reserved", this.reserved && this.reserved.length ? this.reserved : undefined$1, "group", this.group || undefined$1, "nested", inherited && inherited.nested || undefined$1]);
                };

                Type.prototype.resolveAll = function resolveAll() {
                  var fields = this.fieldsArray,
                      i = 0;

                  while (i < fields.length) {
                    fields[i++].resolve();
                  }

                  var oneofs = this.oneofsArray;
                  i = 0;

                  while (i < oneofs.length) {
                    oneofs[i++].resolve();
                  }

                  return Namespace.prototype.resolveAll.call(this);
                };

                Type.prototype.get = function get(name) {
                  return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
                };

                Type.prototype.add = function add(object) {
                  if (this.get(object.name)) throw Error("duplicate name '" + object.name + "' in " + this);

                  if (object instanceof Field && object.extend === undefined$1) {
                    if (this._fieldsById ? this._fieldsById[object.id] : this.fieldsById[object.id]) throw Error("duplicate id " + object.id + " in " + this);
                    if (this.isReservedId(object.id)) throw Error("id " + object.id + " is reserved in " + this);
                    if (this.isReservedName(object.name)) throw Error("name '" + object.name + "' is reserved in " + this);
                    if (object.parent) object.parent.remove(object);
                    this.fields[object.name] = object;
                    object.message = this;
                    object.onAdd(this);
                    return clearCache(this);
                  }

                  if (object instanceof OneOf) {
                    if (!this.oneofs) this.oneofs = {};
                    this.oneofs[object.name] = object;
                    object.onAdd(this);
                    return clearCache(this);
                  }

                  return Namespace.prototype.add.call(this, object);
                };

                Type.prototype.remove = function remove(object) {
                  if (object instanceof Field && object.extend === undefined$1) {
                    if (!this.fields || this.fields[object.name] !== object) throw Error(object + " is not a member of " + this);
                    delete this.fields[object.name];
                    object.parent = null;
                    object.onRemove(this);
                    return clearCache(this);
                  }

                  if (object instanceof OneOf) {
                    if (!this.oneofs || this.oneofs[object.name] !== object) throw Error(object + " is not a member of " + this);
                    delete this.oneofs[object.name];
                    object.parent = null;
                    object.onRemove(this);
                    return clearCache(this);
                  }

                  return Namespace.prototype.remove.call(this, object);
                };

                Type.prototype.isReservedId = function isReservedId(id) {
                  return Namespace.isReservedId(this.reserved, id);
                };

                Type.prototype.isReservedName = function isReservedName(name) {
                  return Namespace.isReservedName(this.reserved, name);
                };

                Type.prototype.create = function create(properties) {
                  return new this.ctor(properties);
                };

                Type.prototype.setup = function setup() {
                  var fullName = this.fullName,
                      types = [];

                  for (var i = 0; i < this.fieldsArray.length; ++i) {
                    types.push(this._fieldsArray[i].resolve().resolvedType);
                  }

                  this.encode = encoder(this)({
                    Writer: Writer,
                    types: types,
                    util: util
                  });
                  this.decode = decoder(this)({
                    Reader: Reader,
                    types: types,
                    util: util
                  });
                  this.verify = verifier(this)({
                    types: types,
                    util: util
                  });
                  this.fromObject = converter.fromObject(this)({
                    types: types,
                    util: util
                  });
                  this.toObject = converter.toObject(this)({
                    types: types,
                    util: util
                  });
                  var wrapper = wrappers[fullName];

                  if (wrapper) {
                    var originalThis = Object.create(this);
                    originalThis.fromObject = this.fromObject;
                    this.fromObject = wrapper.fromObject.bind(originalThis);
                    originalThis.toObject = this.toObject;
                    this.toObject = wrapper.toObject.bind(originalThis);
                  }

                  return this;
                };

                Type.prototype.encode = function encode_setup(message, writer) {
                  return this.setup().encode(message, writer);
                };

                Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
                };

                Type.prototype.decode = function decode_setup(reader, length) {
                  return this.setup().decode(reader, length);
                };

                Type.prototype.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof Reader)) reader = Reader.create(reader);
                  return this.decode(reader, reader.uint32());
                };

                Type.prototype.verify = function verify_setup(message) {
                  return this.setup().verify(message);
                };

                Type.prototype.fromObject = function fromObject(object) {
                  return this.setup().fromObject(object);
                };

                Type.prototype.toObject = function toObject(message, options) {
                  return this.setup().toObject(message, options);
                };

                Type.d = function decorateType(typeName) {
                  return function typeDecorator(target) {
                    util.decorateType(target, typeName);
                  };
                };
              }, {
                12: 12,
                13: 13,
                14: 14,
                15: 15,
                16: 16,
                20: 20,
                21: 21,
                23: 23,
                25: 25,
                27: 27,
                33: 33,
                37: 37,
                40: 40,
                41: 41,
                42: 42
              }],
              36: [function (require, module, exports) {
                var types = exports;

                var util = require(37);

                var s = ["double", "float", "int32", "uint32", "sint32", "fixed32", "sfixed32", "int64", "uint64", "sint64", "fixed64", "sfixed64", "bool", "string", "bytes"];

                function bake(values, offset) {
                  var i = 0,
                      o = {};
                  offset |= 0;

                  while (i < values.length) {
                    o[s[i + offset]] = values[i++];
                  }

                  return o;
                }

                types.basic = bake([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]);
                types.defaults = bake([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false, "", util.emptyArray, null]);
                types["long"] = bake([0, 0, 0, 1, 1], 7);
                types.mapKey = bake([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2);
                types.packed = bake([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0]);
              }, {
                37: 37
              }],
              37: [function (require, module, exports) {
                var util = module.exports = require(39);

                var roots = require(30);

                var Type, Enum;
                util.codegen = require(3);
                util.fetch = require(5);
                util.path = require(8);
                util.fs = util.inquire("fs");

                util.toArray = function toArray(object) {
                  if (object) {
                    var keys = Object.keys(object),
                        array = new Array(keys.length),
                        index = 0;

                    while (index < keys.length) {
                      array[index] = object[keys[index++]];
                    }

                    return array;
                  }

                  return [];
                };

                util.toObject = function toObject(array) {
                  var object = {},
                      index = 0;

                  while (index < array.length) {
                    var key = array[index++],
                        val = array[index++];
                    if (val !== undefined$1) object[key] = val;
                  }

                  return object;
                };

                var safePropBackslashRe = /\\/g,
                    safePropQuoteRe = /"/g;

                util.isReserved = function isReserved(name) {
                  return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
                };

                util.safeProp = function safeProp(prop) {
                  if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop)) return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
                  return "." + prop;
                };

                util.ucFirst = function ucFirst(str) {
                  return str.charAt(0).toUpperCase() + str.substring(1);
                };

                var camelCaseRe = /_([a-z])/g;

                util.camelCase = function camelCase(str) {
                  return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function ($0, $1) {
                    return $1.toUpperCase();
                  });
                };

                util.compareFieldsById = function compareFieldsById(a, b) {
                  return a.id - b.id;
                };

                util.decorateType = function decorateType(ctor, typeName) {
                  if (ctor.$type) {
                    if (typeName && ctor.$type.name !== typeName) {
                      util.decorateRoot.remove(ctor.$type);
                      ctor.$type.name = typeName;
                      util.decorateRoot.add(ctor.$type);
                    }

                    return ctor.$type;
                  }

                  if (!Type) Type = require(35);
                  var type = new Type(typeName || ctor.name);
                  util.decorateRoot.add(type);
                  type.ctor = ctor;
                  Object.defineProperty(ctor, "$type", {
                    value: type,
                    enumerable: false
                  });
                  Object.defineProperty(ctor.prototype, "$type", {
                    value: type,
                    enumerable: false
                  });
                  return type;
                };

                var decorateEnumIndex = 0;

                util.decorateEnum = function decorateEnum(object) {
                  if (object.$type) return object.$type;
                  if (!Enum) Enum = require(15);
                  var enm = new Enum("Enum" + decorateEnumIndex++, object);
                  util.decorateRoot.add(enm);
                  Object.defineProperty(object, "$type", {
                    value: enm,
                    enumerable: false
                  });
                  return enm;
                };

                Object.defineProperty(util, "decorateRoot", {
                  get: function get() {
                    return roots["decorated"] || (roots["decorated"] = new (require(29))());
                  }
                });
              }, {
                15: 15,
                29: 29,
                3: 3,
                30: 30,
                35: 35,
                39: 39,
                5: 5,
                8: 8
              }],
              38: [function (require, module, exports) {
                module.exports = LongBits;

                var util = require(39);

                function LongBits(lo, hi) {
                  this.lo = lo >>> 0;
                  this.hi = hi >>> 0;
                }

                var zero = LongBits.zero = new LongBits(0, 0);

                zero.toNumber = function () {
                  return 0;
                };

                zero.zzEncode = zero.zzDecode = function () {
                  return this;
                };

                zero.length = function () {
                  return 1;
                };

                var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

                LongBits.fromNumber = function fromNumber(value) {
                  if (value === 0) return zero;
                  var sign = value < 0;
                  if (sign) value = -value;
                  var lo = value >>> 0,
                      hi = (value - lo) / 4294967296 >>> 0;

                  if (sign) {
                    hi = ~hi >>> 0;
                    lo = ~lo >>> 0;

                    if (++lo > 4294967295) {
                      lo = 0;
                      if (++hi > 4294967295) hi = 0;
                    }
                  }

                  return new LongBits(lo, hi);
                };

                LongBits.from = function from(value) {
                  if (typeof value === "number") return LongBits.fromNumber(value);

                  if (util.isString(value)) {
                    if (util.Long) value = util.Long.fromString(value);else return LongBits.fromNumber(parseInt(value, 10));
                  }

                  return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
                };

                LongBits.prototype.toNumber = function toNumber(unsigned) {
                  if (!unsigned && this.hi >>> 31) {
                    var lo = ~this.lo + 1 >>> 0,
                        hi = ~this.hi >>> 0;
                    if (!lo) hi = hi + 1 >>> 0;
                    return -(lo + hi * 4294967296);
                  }

                  return this.lo + this.hi * 4294967296;
                };

                LongBits.prototype.toLong = function toLong(unsigned) {
                  return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {
                    low: this.lo | 0,
                    high: this.hi | 0,
                    unsigned: Boolean(unsigned)
                  };
                };

                var charCodeAt = String.prototype.charCodeAt;

                LongBits.fromHash = function fromHash(hash) {
                  if (hash === zeroHash) return zero;
                  return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
                };

                LongBits.prototype.toHash = function toHash() {
                  return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
                };

                LongBits.prototype.zzEncode = function zzEncode() {
                  var mask = this.hi >> 31;
                  this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
                  this.lo = (this.lo << 1 ^ mask) >>> 0;
                  return this;
                };

                LongBits.prototype.zzDecode = function zzDecode() {
                  var mask = -(this.lo & 1);
                  this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
                  this.hi = (this.hi >>> 1 ^ mask) >>> 0;
                  return this;
                };

                LongBits.prototype.length = function length() {
                  var part0 = this.lo,
                      part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
                      part2 = this.hi >>> 24;
                  return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
                };
              }, {
                39: 39
              }],
              39: [function (require, module, exports) {
                var util = exports;
                util.asPromise = require(1);
                util.base64 = require(2);
                util.EventEmitter = require(4);
                util["float"] = require(6);
                util.inquire = require(7);
                util.utf8 = require(10);
                util.pool = require(9);
                util.LongBits = require(38);
                util.emptyArray = Object.freeze ? Object.freeze([]) : [];
                util.emptyObject = Object.freeze ? Object.freeze({}) : {};
                util.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);

                util.isInteger = Number.isInteger || function isInteger(value) {
                  return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
                };

                util.isString = function isString(value) {
                  return typeof value === "string" || value instanceof String;
                };

                util.isObject = function isObject(value) {
                  return value && typeof value === "object";
                };

                util.isset = util.isSet = function isSet(obj, prop) {
                  var value = obj[prop];
                  if (value != null && obj.hasOwnProperty(prop)) return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
                  return false;
                };

                util.Buffer = function () {
                  try {
                    var Buffer = util.inquire("buffer").Buffer;
                    return Buffer.prototype.utf8Write ? Buffer : null;
                  } catch (e) {
                    return null;
                  }
                }();

                util._Buffer_from = null;
                util._Buffer_allocUnsafe = null;

                util.newBuffer = function newBuffer(sizeOrArray) {
                  return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
                };

                util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
                util.Long = global.dcodeIO && global.dcodeIO.Long || util.inquire("long");
                util.key2Re = /^true|false|0|1$/;
                util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
                util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

                util.longToHash = function longToHash(value) {
                  return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
                };

                util.longFromHash = function longFromHash(hash, unsigned) {
                  var bits = util.LongBits.fromHash(hash);
                  if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);
                  return bits.toNumber(Boolean(unsigned));
                };

                function merge(dst, src, ifNotSet) {
                  for (var keys = Object.keys(src), i = 0; i < keys.length; ++i) {
                    if (dst[keys[i]] === undefined$1 || !ifNotSet) dst[keys[i]] = src[keys[i]];
                  }

                  return dst;
                }

                util.merge = merge;

                util.lcFirst = function lcFirst(str) {
                  return str.charAt(0).toLowerCase() + str.substring(1);
                };

                function newError(name) {
                  function CustomError(message, properties) {
                    if (!(this instanceof CustomError)) return new CustomError(message, properties);
                    Object.defineProperty(this, "message", {
                      get: function get() {
                        return message;
                      }
                    });
                    if (Error.captureStackTrace) Error.captureStackTrace(this, CustomError);else Object.defineProperty(this, "stack", {
                      value: new Error().stack || ""
                    });
                    if (properties) merge(this, properties);
                  }

                  (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
                  Object.defineProperty(CustomError.prototype, "name", {
                    get: function get() {
                      return name;
                    }
                  });

                  CustomError.prototype.toString = function toString() {
                    return this.name + ": " + this.message;
                  };

                  return CustomError;
                }

                util.newError = newError;
                util.ProtocolError = newError("ProtocolError");

                util.oneOfGetter = function getOneOf(fieldNames) {
                  var fieldMap = {};

                  for (var i = 0; i < fieldNames.length; ++i) {
                    fieldMap[fieldNames[i]] = 1;
                  }

                  return function () {
                    for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i) {
                      if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined$1 && this[keys[i]] !== null) return keys[i];
                    }
                  };
                };

                util.oneOfSetter = function setOneOf(fieldNames) {
                  return function (name) {
                    for (var i = 0; i < fieldNames.length; ++i) {
                      if (fieldNames[i] !== name) delete this[fieldNames[i]];
                    }
                  };
                };

                util.toJSONOptions = {
                  longs: String,
                  enums: String,
                  bytes: String,
                  json: true
                };

                util._configure = function () {
                  var Buffer = util.Buffer;

                  if (!Buffer) {
                    util._Buffer_from = util._Buffer_allocUnsafe = null;
                    return;
                  }

                  util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || function Buffer_from(value, encoding) {
                    return new Buffer(value, encoding);
                  };

                  util._Buffer_allocUnsafe = Buffer.allocUnsafe || function Buffer_allocUnsafe(size) {
                    return new Buffer(size);
                  };
                };
              }, {
                1: 1,
                10: 10,
                2: 2,
                38: 38,
                4: 4,
                6: 6,
                7: 7,
                9: 9
              }],
              40: [function (require, module, exports) {
                module.exports = verifier;

                var Enum = require(15),
                    util = require(37);

                function invalid(field, expected) {
                  return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
                }

                function genVerifyValue(gen, field, fieldIndex, ref) {
                  if (field.resolvedType) {
                    if (field.resolvedType instanceof Enum) {
                      gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));

                      for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) {
                        gen("case %i:", field.resolvedType.values[keys[j]]);
                      }

                      gen("break")("}");
                    } else {
                      gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
                    }
                  } else {
                    switch (field.type) {
                      case "int32":
                      case "uint32":
                      case "sint32":
                      case "fixed32":
                      case "sfixed32":
                        gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
                        break;

                      case "int64":
                      case "uint64":
                      case "sint64":
                      case "fixed64":
                      case "sfixed64":
                        gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
                        break;

                      case "float":
                      case "double":
                        gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
                        break;

                      case "bool":
                        gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
                        break;

                      case "string":
                        gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
                        break;

                      case "bytes":
                        gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
                        break;
                    }
                  }

                  return gen;
                }

                function genVerifyKey(gen, field, ref) {
                  switch (field.keyType) {
                    case "int32":
                    case "uint32":
                    case "sint32":
                    case "fixed32":
                    case "sfixed32":
                      gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
                      break;

                    case "int64":
                    case "uint64":
                    case "sint64":
                    case "fixed64":
                    case "sfixed64":
                      gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
                      break;

                    case "bool":
                      gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
                      break;
                  }

                  return gen;
                }

                function verifier(mtype) {
                  var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
                  var oneofs = mtype.oneofsArray,
                      seenFirstField = {};
                  if (oneofs.length) gen("var p={}");

                  for (var i = 0; i < mtype.fieldsArray.length; ++i) {
                    var field = mtype._fieldsArray[i].resolve(),
                        ref = "m" + util.safeProp(field.name);

                    if (field.optional) gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);

                    if (field.map) {
                      gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
                      genVerifyKey(gen, field, "k[i]");
                      genVerifyValue(gen, field, i, ref + "[k[i]]")("}");
                    } else if (field.repeated) {
                      gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
                      genVerifyValue(gen, field, i, ref + "[i]")("}");
                    } else {
                      if (field.partOf) {
                        var oneofProp = util.safeProp(field.partOf.name);
                        if (seenFirstField[field.partOf.name] === 1) gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
                        seenFirstField[field.partOf.name] = 1;
                        gen("p%s=1", oneofProp);
                      }

                      genVerifyValue(gen, field, i, ref);
                    }

                    if (field.optional) gen("}");
                  }

                  return gen("return null");
                }
              }, {
                15: 15,
                37: 37
              }],
              41: [function (require, module, exports) {
                var wrappers = exports;

                var Message = require(21);

                wrappers[".google.protobuf.Any"] = {
                  fromObject: function fromObject(object) {
                    if (object && object["@type"]) {
                      var type = this.lookup(object["@type"]);

                      if (type) {
                        var type_url = object["@type"].charAt(0) === "." ? object["@type"].substr(1) : object["@type"];
                        return this.create({
                          type_url: "/" + type_url,
                          value: type.encode(type.fromObject(object)).finish()
                        });
                      }
                    }

                    return this.fromObject(object);
                  },
                  toObject: function toObject(message, options) {
                    if (options && options.json && message.type_url && message.value) {
                      var name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
                      var type = this.lookup(name);
                      if (type) message = type.decode(message.value);
                    }

                    if (!(message instanceof this.ctor) && message instanceof Message) {
                      var object = message.$type.toObject(message, options);
                      object["@type"] = message.$type.fullName;
                      return object;
                    }

                    return this.toObject(message, options);
                  }
                };
              }, {
                21: 21
              }],
              42: [function (require, module, exports) {
                module.exports = Writer;

                var util = require(39);

                var BufferWriter;
                var LongBits = util.LongBits,
                    base64 = util.base64,
                    utf8 = util.utf8;

                function Op(fn, len, val) {
                  this.fn = fn;
                  this.len = len;
                  this.next = undefined$1;
                  this.val = val;
                }

                function noop() {}

                function State(writer) {
                  this.head = writer.head;
                  this.tail = writer.tail;
                  this.len = writer.len;
                  this.next = writer.states;
                }

                function Writer() {
                  this.len = 0;
                  this.head = new Op(noop, 0, 0);
                  this.tail = this.head;
                  this.states = null;
                }

                Writer.create = util.Buffer ? function create_buffer_setup() {
                  return (Writer.create = function create_buffer() {
                    return new BufferWriter();
                  })();
                } : function create_array() {
                  return new Writer();
                };

                Writer.alloc = function alloc(size) {
                  return new util.Array(size);
                };

                if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

                Writer.prototype._push = function push(fn, len, val) {
                  this.tail = this.tail.next = new Op(fn, len, val);
                  this.len += len;
                  return this;
                };

                function writeByte(val, buf, pos) {
                  buf[pos] = val & 255;
                }

                function writeVarint32(val, buf, pos) {
                  while (val > 127) {
                    buf[pos++] = val & 127 | 128;
                    val >>>= 7;
                  }

                  buf[pos] = val;
                }

                function VarintOp(len, val) {
                  this.len = len;
                  this.next = undefined$1;
                  this.val = val;
                }

                VarintOp.prototype = Object.create(Op.prototype);
                VarintOp.prototype.fn = writeVarint32;

                Writer.prototype.uint32 = function write_uint32(value) {
                  this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
                  return this;
                };

                Writer.prototype.int32 = function write_int32(value) {
                  return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
                };

                Writer.prototype.sint32 = function write_sint32(value) {
                  return this.uint32((value << 1 ^ value >> 31) >>> 0);
                };

                function writeVarint64(val, buf, pos) {
                  while (val.hi) {
                    buf[pos++] = val.lo & 127 | 128;
                    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
                    val.hi >>>= 7;
                  }

                  while (val.lo > 127) {
                    buf[pos++] = val.lo & 127 | 128;
                    val.lo = val.lo >>> 7;
                  }

                  buf[pos++] = val.lo;
                }

                Writer.prototype.uint64 = function write_uint64(value) {
                  var bits = LongBits.from(value);
                  return this._push(writeVarint64, bits.length(), bits);
                };

                Writer.prototype.int64 = Writer.prototype.uint64;

                Writer.prototype.sint64 = function write_sint64(value) {
                  var bits = LongBits.from(value).zzEncode();
                  return this._push(writeVarint64, bits.length(), bits);
                };

                Writer.prototype.bool = function write_bool(value) {
                  return this._push(writeByte, 1, value ? 1 : 0);
                };

                function writeFixed32(val, buf, pos) {
                  buf[pos] = val & 255;
                  buf[pos + 1] = val >>> 8 & 255;
                  buf[pos + 2] = val >>> 16 & 255;
                  buf[pos + 3] = val >>> 24;
                }

                Writer.prototype.fixed32 = function write_fixed32(value) {
                  return this._push(writeFixed32, 4, value >>> 0);
                };

                Writer.prototype.sfixed32 = Writer.prototype.fixed32;

                Writer.prototype.fixed64 = function write_fixed64(value) {
                  var bits = LongBits.from(value);
                  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
                };

                Writer.prototype.sfixed64 = Writer.prototype.fixed64;

                Writer.prototype["float"] = function write_float(value) {
                  return this._push(util["float"].writeFloatLE, 4, value);
                };

                Writer.prototype["double"] = function write_double(value) {
                  return this._push(util["float"].writeDoubleLE, 8, value);
                };

                var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
                  buf.set(val, pos);
                } : function writeBytes_for(val, buf, pos) {
                  for (var i = 0; i < val.length; ++i) {
                    buf[pos + i] = val[i];
                  }
                };

                Writer.prototype.bytes = function write_bytes(value) {
                  var len = value.length >>> 0;
                  if (!len) return this._push(writeByte, 1, 0);

                  if (util.isString(value)) {
                    var buf = Writer.alloc(len = base64.length(value));
                    base64.decode(value, buf, 0);
                    value = buf;
                  }

                  return this.uint32(len)._push(writeBytes, len, value);
                };

                Writer.prototype.string = function write_string(value) {
                  var len = utf8.length(value);
                  return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
                };

                Writer.prototype.fork = function fork() {
                  this.states = new State(this);
                  this.head = this.tail = new Op(noop, 0, 0);
                  this.len = 0;
                  return this;
                };

                Writer.prototype.reset = function reset() {
                  if (this.states) {
                    this.head = this.states.head;
                    this.tail = this.states.tail;
                    this.len = this.states.len;
                    this.states = this.states.next;
                  } else {
                    this.head = this.tail = new Op(noop, 0, 0);
                    this.len = 0;
                  }

                  return this;
                };

                Writer.prototype.ldelim = function ldelim() {
                  var head = this.head,
                      tail = this.tail,
                      len = this.len;
                  this.reset().uint32(len);

                  if (len) {
                    this.tail.next = head.next;
                    this.tail = tail;
                    this.len += len;
                  }

                  return this;
                };

                Writer.prototype.finish = function finish() {
                  var head = this.head.next,
                      buf = this.constructor.alloc(this.len),
                      pos = 0;

                  while (head) {
                    head.fn(head.val, buf, pos);
                    pos += head.len;
                    head = head.next;
                  }

                  return buf;
                };

                Writer._configure = function (BufferWriter_) {
                  BufferWriter = BufferWriter_;
                };
              }, {
                39: 39
              }],
              43: [function (require, module, exports) {
                module.exports = BufferWriter;

                var Writer = require(42);

                (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

                var util = require(39);

                var Buffer = util.Buffer;

                function BufferWriter() {
                  Writer.call(this);
                }

                BufferWriter.alloc = function alloc_buffer(size) {
                  return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
                };

                var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
                  buf.set(val, pos);
                } : function writeBytesBuffer_copy(val, buf, pos) {
                  if (val.copy) val.copy(buf, pos, 0, val.length);else for (var i = 0; i < val.length;) {
                    buf[pos++] = val[i++];
                  }
                };

                BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
                  if (util.isString(value)) value = util._Buffer_from(value, "base64");
                  var len = value.length >>> 0;
                  this.uint32(len);
                  if (len) this._push(writeBytesBuffer, len, value);
                  return this;
                };

                function writeStringBuffer(val, buf, pos) {
                  if (val.length < 40) util.utf8.write(val, buf, pos);else buf.utf8Write(val, pos);
                }

                BufferWriter.prototype.string = function write_string_buffer(value) {
                  var len = Buffer.byteLength(value);
                  this.uint32(len);
                  if (len) this._push(writeStringBuffer, len, value);
                  return this;
                };
              }, {
                39: 39,
                42: 42
              }]
            }, {}, [19]);
          })(typeof window === "object" && window || typeof self === "object" && self || this);
        })();

        _cjsExports = exports('default', module.exports);
      });

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);
    }
  };
});

System.register("chunks:///_virtual/StarFlyingCtrl.ts", ['cc', './_rollupPluginModLoBabelHelpers.js'], function (exports) {
  'use strict';

  var cclegacy, _decorator, Vec3, tween, math, Component, _inheritsLoose, _defineProperty, _assertThisInitialized;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Vec3 = module.Vec3;
      tween = module.tween;
      math = module.math;
      Component = module.Component;
    }, function (module) {
      _inheritsLoose = module.inheritsLoose;
      _defineProperty = module.defineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }],
    execute: function () {
      var _dec, _class, _temp;

      cclegacy._RF.push({}, "47988rSR2pAyINSGwTg71+3", "StarFlyingCtrl", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var StarFlyingCtrl = exports('StarFlyingCtrl', (_dec = ccclass('StarFlyingCtrl'), _dec(_class = (_temp = /*#__PURE__*/function (_Component) {
        _inheritsLoose(StarFlyingCtrl, _Component);

        function StarFlyingCtrl() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this), "_tweenBounce", null);

          _defineProperty(_assertThisInitialized(_this), "_offsetPos", new Vec3());

          _defineProperty(_assertThisInitialized(_this), "_endWorPos", null);

          _defineProperty(_assertThisInitialized(_this), "_targetWorPos", new Vec3());

          _defineProperty(_assertThisInitialized(_this), "_totalFlyTime", 0);

          _defineProperty(_assertThisInitialized(_this), "_curFlyTime", 0);

          _defineProperty(_assertThisInitialized(_this), "_raiseTimes", 1);

          _defineProperty(_assertThisInitialized(_this), "_bouncePos", new Vec3(0, 0, 0));

          _defineProperty(_assertThisInitialized(_this), "_bounceScale", new Vec3(0.2, 0.2, 0.2));

          _defineProperty(_assertThisInitialized(_this), "cb", null);

          _defineProperty(_assertThisInitialized(_this), "isFlying", false);

          return _this;
        }

        var _proto = StarFlyingCtrl.prototype;

        _proto.start = function start() {} // 星星飞行
        ;

        _proto.starFlying = function starFlying(targetPos, cb) {
          var _this2 = this;

          this._endWorPos = targetPos; // this._endWorPos.x = this.node.worldPosition.x;
          // this._endWorPos.y = this.node.worldPosition.y;
          // this._endWorPos.z = this.node.worldPosition.z;

          this.cb = cb; //先弹跳
          // console.log("StarFlyingCtrl starFlying node = " + this.node.worldPosition + " _endWorPos = " + this._endWorPos + "  scale= " + this.node.scale);

          var nodeScale = this.node.scale;
          tween(this.node).to(math.random() * 1, {
            scale: new Vec3(3, 3, 3),
            worldPosition: this._endWorPos
          }).call(function () {
            if (_this2.cb) _this2.cb();

            _this2.node.removeFromParent();
          }).start(); // let starFlying = tween(this.node);
          // starFlying = tween(this.node)
          //     .by(0.3, {
          //         position: this.node.worldPosition.add(this._bouncePos),
          //         scale: this._bounceScale
          //     }, { easing: "bounceInOut" })
          //     .call(() => {
          //         //播放粒子特效，不要勾选粒子的prewarm属性，免得出现概率性没有播放拖尾
          //         //再吸入
          //         this.isFlying = true;
          //         console.log("StarFlyingCtrl starFlying node = " + this.node.worldPosition + " _endWorPos = " + this._endWorPos);
          //         tween(this.node).to(2, { position: this._endWorPos }).call(() => {
          //         }).start();
          //     })
          //     .start();
        };

        _proto._closeTween = function _closeTween() {
          if (this._tweenBounce) {
            this._tweenBounce.stop();

            this._tweenBounce = null;
          }
        };

        _proto.update = function update(deltaTime) {
          //奖品被玩家吸入
          if (this.isFlying && this._endWorPos) ;
        };

        return StarFlyingCtrl;
      }(Component), _temp)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/protobuf-bundles.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      loader.define(module.meta.url, function (exports$1, _require, module, __filename, __dirname) {
        var require = loader.createRequireWithReqMap({}, _require);

        (function () {
          var $protobuf = window.protobuf;
          $protobuf.roots["default"] = window; // Common aliases

          var $Reader = $protobuf.Reader,
              $Writer = $protobuf.Writer,
              $util = $protobuf.util; // Exported root namespace

          var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

          $root.Star = function () {
            /**
             * Namespace Star.
             * @exports Star
             * @namespace
             */
            var Star = {};

            Star.GridChooseReq = function () {
              /**
               * Properties of a GridChooseReq.
               * @memberof Star
               * @interface IGridChooseReq
               * @property {number|Long|null} [uid] GridChooseReq uid
               * @property {number|null} [roundNo] GridChooseReq roundNo
               * @property {number|null} [gridNo] GridChooseReq gridNo
               */

              /**
               * Constructs a new GridChooseReq.
               * @memberof Star
               * @classdesc Represents a GridChooseReq.
               * @implements IGridChooseReq
               * @constructor
               * @param {Star.IGridChooseReq=} [properties] Properties to set
               */
              function GridChooseReq(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * GridChooseReq uid.
               * @member {number|Long} uid
               * @memberof Star.GridChooseReq
               * @instance
               */


              GridChooseReq.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * GridChooseReq roundNo.
               * @member {number} roundNo
               * @memberof Star.GridChooseReq
               * @instance
               */

              GridChooseReq.prototype.roundNo = 0;
              /**
               * GridChooseReq gridNo.
               * @member {number} gridNo
               * @memberof Star.GridChooseReq
               * @instance
               */

              GridChooseReq.prototype.gridNo = 0;
              /**
               * Creates a new GridChooseReq instance using the specified properties.
               * @function create
               * @memberof Star.GridChooseReq
               * @static
               * @param {Star.IGridChooseReq=} [properties] Properties to set
               * @returns {Star.GridChooseReq} GridChooseReq instance
               */

              GridChooseReq.create = function create(properties) {
                return new GridChooseReq(properties);
              };
              /**
               * Encodes the specified GridChooseReq message. Does not implicitly {@link Star.GridChooseReq.verify|verify} messages.
               * @function encode
               * @memberof Star.GridChooseReq
               * @static
               * @param {Star.IGridChooseReq} message GridChooseReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              GridChooseReq.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.uid);
                if (message.roundNo != null && message.hasOwnProperty("roundNo")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int32(message.roundNo);
                if (message.gridNo != null && message.hasOwnProperty("gridNo")) writer.uint32(
                /* id 3, wireType 0 =*/
                24).int32(message.gridNo);
                return writer;
              };
              /**
               * Encodes the specified GridChooseReq message, length delimited. Does not implicitly {@link Star.GridChooseReq.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Star.GridChooseReq
               * @static
               * @param {Star.IGridChooseReq} message GridChooseReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              GridChooseReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a GridChooseReq message from the specified reader or buffer.
               * @function decode
               * @memberof Star.GridChooseReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Star.GridChooseReq} GridChooseReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              GridChooseReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Star.GridChooseReq();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.uid = reader.int64();
                      break;

                    case 2:
                      message.roundNo = reader.int32();
                      break;

                    case 3:
                      message.gridNo = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a GridChooseReq message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Star.GridChooseReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Star.GridChooseReq} GridChooseReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              GridChooseReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a GridChooseReq message.
               * @function verify
               * @memberof Star.GridChooseReq
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              GridChooseReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                if (message.roundNo != null && message.hasOwnProperty("roundNo")) if (!$util.isInteger(message.roundNo)) return "roundNo: integer expected";
                if (message.gridNo != null && message.hasOwnProperty("gridNo")) if (!$util.isInteger(message.gridNo)) return "gridNo: integer expected";
                return null;
              };

              return GridChooseReq;
            }();

            Star.GameStartNotify = function () {
              /**
               * Properties of a GameStartNotify.
               * @memberof Star
               * @interface IGameStartNotify
               * @property {number|Long|null} [battleId] GameStartNotify battleId
               * @property {Array.<Star.IUserInfo>|null} [currentDuel] GameStartNotify currentDuel
               * @property {Array.<Star.IUserInfo>|null} [nextDuel] GameStartNotify nextDuel
               * @property {number|null} [startType] GameStartNotify startType
               * @property {Star.IMapInfo|null} [map] GameStartNotify map
               * @property {number|null} [gameNo] GameStartNotify gameNo
               * @property {number|null} [roundNo] GameStartNotify roundNo
               * @property {number|null} [isPlayoff] GameStartNotify isPlayoff
               * @property {number|null} [roundConfirmTime] GameStartNotify roundConfirmTime
               */

              /**
               * Constructs a new GameStartNotify.
               * @memberof Star
               * @classdesc Represents a GameStartNotify.
               * @implements IGameStartNotify
               * @constructor
               * @param {Star.IGameStartNotify=} [properties] Properties to set
               */
              function GameStartNotify(properties) {
                this.currentDuel = [];
                this.nextDuel = [];
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * GameStartNotify battleId.
               * @member {number|Long} battleId
               * @memberof Star.GameStartNotify
               * @instance
               */


              GameStartNotify.prototype.battleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * GameStartNotify currentDuel.
               * @member {Array.<Star.IUserInfo>} currentDuel
               * @memberof Star.GameStartNotify
               * @instance
               */

              GameStartNotify.prototype.currentDuel = $util.emptyArray;
              /**
               * GameStartNotify nextDuel.
               * @member {Array.<Star.IUserInfo>} nextDuel
               * @memberof Star.GameStartNotify
               * @instance
               */

              GameStartNotify.prototype.nextDuel = $util.emptyArray;
              /**
               * GameStartNotify startType.
               * @member {number} startType
               * @memberof Star.GameStartNotify
               * @instance
               */

              GameStartNotify.prototype.startType = 0;
              /**
               * GameStartNotify map.
               * @member {Star.IMapInfo|null|undefined} map
               * @memberof Star.GameStartNotify
               * @instance
               */

              GameStartNotify.prototype.map = null;
              /**
               * GameStartNotify gameNo.
               * @member {number} gameNo
               * @memberof Star.GameStartNotify
               * @instance
               */

              GameStartNotify.prototype.gameNo = 0;
              /**
               * GameStartNotify roundNo.
               * @member {number} roundNo
               * @memberof Star.GameStartNotify
               * @instance
               */

              GameStartNotify.prototype.roundNo = 0;
              /**
               * GameStartNotify isPlayoff.
               * @member {number} isPlayoff
               * @memberof Star.GameStartNotify
               * @instance
               */

              GameStartNotify.prototype.isPlayoff = 0;
              /**
               * GameStartNotify roundConfirmTime.
               * @member {number} roundConfirmTime
               * @memberof Star.GameStartNotify
               * @instance
               */

              GameStartNotify.prototype.roundConfirmTime = 0;
              /**
               * Creates a new GameStartNotify instance using the specified properties.
               * @function create
               * @memberof Star.GameStartNotify
               * @static
               * @param {Star.IGameStartNotify=} [properties] Properties to set
               * @returns {Star.GameStartNotify} GameStartNotify instance
               */

              GameStartNotify.create = function create(properties) {
                return new GameStartNotify(properties);
              };
              /**
               * Encodes the specified GameStartNotify message. Does not implicitly {@link Star.GameStartNotify.verify|verify} messages.
               * @function encode
               * @memberof Star.GameStartNotify
               * @static
               * @param {Star.IGameStartNotify} message GameStartNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              GameStartNotify.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.battleId != null && message.hasOwnProperty("battleId")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.battleId);
                if (message.currentDuel != null && message.currentDuel.length) for (var i = 0; i < message.currentDuel.length; ++i) {
                  $root.Star.UserInfo.encode(message.currentDuel[i], writer.uint32(
                  /* id 2, wireType 2 =*/
                  18).fork()).ldelim();
                }
                if (message.nextDuel != null && message.nextDuel.length) for (var i = 0; i < message.nextDuel.length; ++i) {
                  $root.Star.UserInfo.encode(message.nextDuel[i], writer.uint32(
                  /* id 3, wireType 2 =*/
                  26).fork()).ldelim();
                }
                if (message.startType != null && message.hasOwnProperty("startType")) writer.uint32(
                /* id 4, wireType 0 =*/
                32).int32(message.startType);
                if (message.map != null && message.hasOwnProperty("map")) $root.Star.MapInfo.encode(message.map, writer.uint32(
                /* id 5, wireType 2 =*/
                42).fork()).ldelim();
                if (message.gameNo != null && message.hasOwnProperty("gameNo")) writer.uint32(
                /* id 6, wireType 0 =*/
                48).int32(message.gameNo);
                if (message.roundNo != null && message.hasOwnProperty("roundNo")) writer.uint32(
                /* id 7, wireType 0 =*/
                56).int32(message.roundNo);
                if (message.isPlayoff != null && message.hasOwnProperty("isPlayoff")) writer.uint32(
                /* id 8, wireType 0 =*/
                64).int32(message.isPlayoff);
                if (message.roundConfirmTime != null && message.hasOwnProperty("roundConfirmTime")) writer.uint32(
                /* id 9, wireType 0 =*/
                72).int32(message.roundConfirmTime);
                return writer;
              };
              /**
               * Encodes the specified GameStartNotify message, length delimited. Does not implicitly {@link Star.GameStartNotify.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Star.GameStartNotify
               * @static
               * @param {Star.IGameStartNotify} message GameStartNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              GameStartNotify.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a GameStartNotify message from the specified reader or buffer.
               * @function decode
               * @memberof Star.GameStartNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Star.GameStartNotify} GameStartNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              GameStartNotify.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Star.GameStartNotify();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.battleId = reader.int64();
                      break;

                    case 2:
                      if (!(message.currentDuel && message.currentDuel.length)) message.currentDuel = [];
                      message.currentDuel.push($root.Star.UserInfo.decode(reader, reader.uint32()));
                      break;

                    case 3:
                      if (!(message.nextDuel && message.nextDuel.length)) message.nextDuel = [];
                      message.nextDuel.push($root.Star.UserInfo.decode(reader, reader.uint32()));
                      break;

                    case 4:
                      message.startType = reader.int32();
                      break;

                    case 5:
                      message.map = $root.Star.MapInfo.decode(reader, reader.uint32());
                      break;

                    case 6:
                      message.gameNo = reader.int32();
                      break;

                    case 7:
                      message.roundNo = reader.int32();
                      break;

                    case 8:
                      message.isPlayoff = reader.int32();
                      break;

                    case 9:
                      message.roundConfirmTime = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a GameStartNotify message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Star.GameStartNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Star.GameStartNotify} GameStartNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              GameStartNotify.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a GameStartNotify message.
               * @function verify
               * @memberof Star.GameStartNotify
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              GameStartNotify.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.battleId != null && message.hasOwnProperty("battleId")) if (!$util.isInteger(message.battleId) && !(message.battleId && $util.isInteger(message.battleId.low) && $util.isInteger(message.battleId.high))) return "battleId: integer|Long expected";

                if (message.currentDuel != null && message.hasOwnProperty("currentDuel")) {
                  if (!Array.isArray(message.currentDuel)) return "currentDuel: array expected";

                  for (var i = 0; i < message.currentDuel.length; ++i) {
                    var error = $root.Star.UserInfo.verify(message.currentDuel[i]);
                    if (error) return "currentDuel." + error;
                  }
                }

                if (message.nextDuel != null && message.hasOwnProperty("nextDuel")) {
                  if (!Array.isArray(message.nextDuel)) return "nextDuel: array expected";

                  for (var i = 0; i < message.nextDuel.length; ++i) {
                    var error = $root.Star.UserInfo.verify(message.nextDuel[i]);
                    if (error) return "nextDuel." + error;
                  }
                }

                if (message.startType != null && message.hasOwnProperty("startType")) if (!$util.isInteger(message.startType)) return "startType: integer expected";

                if (message.map != null && message.hasOwnProperty("map")) {
                  var error = $root.Star.MapInfo.verify(message.map);
                  if (error) return "map." + error;
                }

                if (message.gameNo != null && message.hasOwnProperty("gameNo")) if (!$util.isInteger(message.gameNo)) return "gameNo: integer expected";
                if (message.roundNo != null && message.hasOwnProperty("roundNo")) if (!$util.isInteger(message.roundNo)) return "roundNo: integer expected";
                if (message.isPlayoff != null && message.hasOwnProperty("isPlayoff")) if (!$util.isInteger(message.isPlayoff)) return "isPlayoff: integer expected";
                if (message.roundConfirmTime != null && message.hasOwnProperty("roundConfirmTime")) if (!$util.isInteger(message.roundConfirmTime)) return "roundConfirmTime: integer expected";
                return null;
              };

              return GameStartNotify;
            }();

            Star.RoundStartNotify = function () {
              /**
               * Properties of a RoundStartNotify.
               * @memberof Star
               * @interface IRoundStartNotify
               * @property {number|null} [gameNo] RoundStartNotify gameNo
               * @property {number|null} [roundNo] RoundStartNotify roundNo
               * @property {Star.IMapInfo|null} [map] RoundStartNotify map
               * @property {number|null} [roundConfirmTime] RoundStartNotify roundConfirmTime
               */

              /**
               * Constructs a new RoundStartNotify.
               * @memberof Star
               * @classdesc Represents a RoundStartNotify.
               * @implements IRoundStartNotify
               * @constructor
               * @param {Star.IRoundStartNotify=} [properties] Properties to set
               */
              function RoundStartNotify(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * RoundStartNotify gameNo.
               * @member {number} gameNo
               * @memberof Star.RoundStartNotify
               * @instance
               */


              RoundStartNotify.prototype.gameNo = 0;
              /**
               * RoundStartNotify roundNo.
               * @member {number} roundNo
               * @memberof Star.RoundStartNotify
               * @instance
               */

              RoundStartNotify.prototype.roundNo = 0;
              /**
               * RoundStartNotify map.
               * @member {Star.IMapInfo|null|undefined} map
               * @memberof Star.RoundStartNotify
               * @instance
               */

              RoundStartNotify.prototype.map = null;
              /**
               * RoundStartNotify roundConfirmTime.
               * @member {number} roundConfirmTime
               * @memberof Star.RoundStartNotify
               * @instance
               */

              RoundStartNotify.prototype.roundConfirmTime = 0;
              /**
               * Creates a new RoundStartNotify instance using the specified properties.
               * @function create
               * @memberof Star.RoundStartNotify
               * @static
               * @param {Star.IRoundStartNotify=} [properties] Properties to set
               * @returns {Star.RoundStartNotify} RoundStartNotify instance
               */

              RoundStartNotify.create = function create(properties) {
                return new RoundStartNotify(properties);
              };
              /**
               * Encodes the specified RoundStartNotify message. Does not implicitly {@link Star.RoundStartNotify.verify|verify} messages.
               * @function encode
               * @memberof Star.RoundStartNotify
               * @static
               * @param {Star.IRoundStartNotify} message RoundStartNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              RoundStartNotify.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.gameNo != null && message.hasOwnProperty("gameNo")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int32(message.gameNo);
                if (message.roundNo != null && message.hasOwnProperty("roundNo")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int32(message.roundNo);
                if (message.map != null && message.hasOwnProperty("map")) $root.Star.MapInfo.encode(message.map, writer.uint32(
                /* id 3, wireType 2 =*/
                26).fork()).ldelim();
                if (message.roundConfirmTime != null && message.hasOwnProperty("roundConfirmTime")) writer.uint32(
                /* id 4, wireType 0 =*/
                32).int32(message.roundConfirmTime);
                return writer;
              };
              /**
               * Encodes the specified RoundStartNotify message, length delimited. Does not implicitly {@link Star.RoundStartNotify.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Star.RoundStartNotify
               * @static
               * @param {Star.IRoundStartNotify} message RoundStartNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              RoundStartNotify.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a RoundStartNotify message from the specified reader or buffer.
               * @function decode
               * @memberof Star.RoundStartNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Star.RoundStartNotify} RoundStartNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              RoundStartNotify.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Star.RoundStartNotify();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.gameNo = reader.int32();
                      break;

                    case 2:
                      message.roundNo = reader.int32();
                      break;

                    case 3:
                      message.map = $root.Star.MapInfo.decode(reader, reader.uint32());
                      break;

                    case 4:
                      message.roundConfirmTime = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a RoundStartNotify message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Star.RoundStartNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Star.RoundStartNotify} RoundStartNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              RoundStartNotify.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a RoundStartNotify message.
               * @function verify
               * @memberof Star.RoundStartNotify
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              RoundStartNotify.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.gameNo != null && message.hasOwnProperty("gameNo")) if (!$util.isInteger(message.gameNo)) return "gameNo: integer expected";
                if (message.roundNo != null && message.hasOwnProperty("roundNo")) if (!$util.isInteger(message.roundNo)) return "roundNo: integer expected";

                if (message.map != null && message.hasOwnProperty("map")) {
                  var error = $root.Star.MapInfo.verify(message.map);
                  if (error) return "map." + error;
                }

                if (message.roundConfirmTime != null && message.hasOwnProperty("roundConfirmTime")) if (!$util.isInteger(message.roundConfirmTime)) return "roundConfirmTime: integer expected";
                return null;
              };

              return RoundStartNotify;
            }();

            Star.RoundSettleNotify = function () {
              /**
               * Properties of a RoundSettleNotify.
               * @memberof Star
               * @interface IRoundSettleNotify
               * @property {Array.<Star.IRoundSettleInfo>|null} [roundSettle] RoundSettleNotify roundSettle
               */

              /**
               * Constructs a new RoundSettleNotify.
               * @memberof Star
               * @classdesc Represents a RoundSettleNotify.
               * @implements IRoundSettleNotify
               * @constructor
               * @param {Star.IRoundSettleNotify=} [properties] Properties to set
               */
              function RoundSettleNotify(properties) {
                this.roundSettle = [];
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * RoundSettleNotify roundSettle.
               * @member {Array.<Star.IRoundSettleInfo>} roundSettle
               * @memberof Star.RoundSettleNotify
               * @instance
               */


              RoundSettleNotify.prototype.roundSettle = $util.emptyArray;
              /**
               * Creates a new RoundSettleNotify instance using the specified properties.
               * @function create
               * @memberof Star.RoundSettleNotify
               * @static
               * @param {Star.IRoundSettleNotify=} [properties] Properties to set
               * @returns {Star.RoundSettleNotify} RoundSettleNotify instance
               */

              RoundSettleNotify.create = function create(properties) {
                return new RoundSettleNotify(properties);
              };
              /**
               * Encodes the specified RoundSettleNotify message. Does not implicitly {@link Star.RoundSettleNotify.verify|verify} messages.
               * @function encode
               * @memberof Star.RoundSettleNotify
               * @static
               * @param {Star.IRoundSettleNotify} message RoundSettleNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              RoundSettleNotify.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.roundSettle != null && message.roundSettle.length) for (var i = 0; i < message.roundSettle.length; ++i) {
                  $root.Star.RoundSettleInfo.encode(message.roundSettle[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10).fork()).ldelim();
                }
                return writer;
              };
              /**
               * Encodes the specified RoundSettleNotify message, length delimited. Does not implicitly {@link Star.RoundSettleNotify.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Star.RoundSettleNotify
               * @static
               * @param {Star.IRoundSettleNotify} message RoundSettleNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              RoundSettleNotify.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a RoundSettleNotify message from the specified reader or buffer.
               * @function decode
               * @memberof Star.RoundSettleNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Star.RoundSettleNotify} RoundSettleNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              RoundSettleNotify.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Star.RoundSettleNotify();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      if (!(message.roundSettle && message.roundSettle.length)) message.roundSettle = [];
                      message.roundSettle.push($root.Star.RoundSettleInfo.decode(reader, reader.uint32()));
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a RoundSettleNotify message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Star.RoundSettleNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Star.RoundSettleNotify} RoundSettleNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              RoundSettleNotify.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a RoundSettleNotify message.
               * @function verify
               * @memberof Star.RoundSettleNotify
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              RoundSettleNotify.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";

                if (message.roundSettle != null && message.hasOwnProperty("roundSettle")) {
                  if (!Array.isArray(message.roundSettle)) return "roundSettle: array expected";

                  for (var i = 0; i < message.roundSettle.length; ++i) {
                    var error = $root.Star.RoundSettleInfo.verify(message.roundSettle[i]);
                    if (error) return "roundSettle." + error;
                  }
                }

                return null;
              };

              return RoundSettleNotify;
            }();

            Star.UserReEnterRes = function () {
              /**
               * Properties of a UserReEnterRes.
               * @memberof Star
               * @interface IUserReEnterRes
               * @property {number|null} [seqId] UserReEnterRes seqId
               * @property {number|Long|null} [battleId] UserReEnterRes battleId
               * @property {Array.<Star.IUserInfo>|null} [teamA] UserReEnterRes teamA
               * @property {Array.<Star.IUserInfo>|null} [teamB] UserReEnterRes teamB
               * @property {Star.IMapInfo|null} [map] UserReEnterRes map
               * @property {number|null} [roundStatus] UserReEnterRes roundStatus
               * @property {number|null} [gameNo] UserReEnterRes gameNo
               * @property {number|null} [roundNo] UserReEnterRes roundNo
               * @property {number|null} [isPlayoff] UserReEnterRes isPlayoff
               * @property {number|null} [roundCountdown] UserReEnterRes roundCountdown
               * @property {number|null} [roundConfirmTime] UserReEnterRes roundConfirmTime
               */

              /**
               * Constructs a new UserReEnterRes.
               * @memberof Star
               * @classdesc Represents a UserReEnterRes.
               * @implements IUserReEnterRes
               * @constructor
               * @param {Star.IUserReEnterRes=} [properties] Properties to set
               */
              function UserReEnterRes(properties) {
                this.teamA = [];
                this.teamB = [];
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * UserReEnterRes seqId.
               * @member {number} seqId
               * @memberof Star.UserReEnterRes
               * @instance
               */


              UserReEnterRes.prototype.seqId = 0;
              /**
               * UserReEnterRes battleId.
               * @member {number|Long} battleId
               * @memberof Star.UserReEnterRes
               * @instance
               */

              UserReEnterRes.prototype.battleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * UserReEnterRes teamA.
               * @member {Array.<Star.IUserInfo>} teamA
               * @memberof Star.UserReEnterRes
               * @instance
               */

              UserReEnterRes.prototype.teamA = $util.emptyArray;
              /**
               * UserReEnterRes teamB.
               * @member {Array.<Star.IUserInfo>} teamB
               * @memberof Star.UserReEnterRes
               * @instance
               */

              UserReEnterRes.prototype.teamB = $util.emptyArray;
              /**
               * UserReEnterRes map.
               * @member {Star.IMapInfo|null|undefined} map
               * @memberof Star.UserReEnterRes
               * @instance
               */

              UserReEnterRes.prototype.map = null;
              /**
               * UserReEnterRes roundStatus.
               * @member {number} roundStatus
               * @memberof Star.UserReEnterRes
               * @instance
               */

              UserReEnterRes.prototype.roundStatus = 0;
              /**
               * UserReEnterRes gameNo.
               * @member {number} gameNo
               * @memberof Star.UserReEnterRes
               * @instance
               */

              UserReEnterRes.prototype.gameNo = 0;
              /**
               * UserReEnterRes roundNo.
               * @member {number} roundNo
               * @memberof Star.UserReEnterRes
               * @instance
               */

              UserReEnterRes.prototype.roundNo = 0;
              /**
               * UserReEnterRes isPlayoff.
               * @member {number} isPlayoff
               * @memberof Star.UserReEnterRes
               * @instance
               */

              UserReEnterRes.prototype.isPlayoff = 0;
              /**
               * UserReEnterRes roundCountdown.
               * @member {number} roundCountdown
               * @memberof Star.UserReEnterRes
               * @instance
               */

              UserReEnterRes.prototype.roundCountdown = 0;
              /**
               * UserReEnterRes roundConfirmTime.
               * @member {number} roundConfirmTime
               * @memberof Star.UserReEnterRes
               * @instance
               */

              UserReEnterRes.prototype.roundConfirmTime = 0;
              /**
               * Creates a new UserReEnterRes instance using the specified properties.
               * @function create
               * @memberof Star.UserReEnterRes
               * @static
               * @param {Star.IUserReEnterRes=} [properties] Properties to set
               * @returns {Star.UserReEnterRes} UserReEnterRes instance
               */

              UserReEnterRes.create = function create(properties) {
                return new UserReEnterRes(properties);
              };
              /**
               * Encodes the specified UserReEnterRes message. Does not implicitly {@link Star.UserReEnterRes.verify|verify} messages.
               * @function encode
               * @memberof Star.UserReEnterRes
               * @static
               * @param {Star.IUserReEnterRes} message UserReEnterRes message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              UserReEnterRes.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.seqId != null && message.hasOwnProperty("seqId")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int32(message.seqId);
                if (message.battleId != null && message.hasOwnProperty("battleId")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.battleId);
                if (message.teamA != null && message.teamA.length) for (var i = 0; i < message.teamA.length; ++i) {
                  $root.Star.UserInfo.encode(message.teamA[i], writer.uint32(
                  /* id 3, wireType 2 =*/
                  26).fork()).ldelim();
                }
                if (message.teamB != null && message.teamB.length) for (var i = 0; i < message.teamB.length; ++i) {
                  $root.Star.UserInfo.encode(message.teamB[i], writer.uint32(
                  /* id 4, wireType 2 =*/
                  34).fork()).ldelim();
                }
                if (message.map != null && message.hasOwnProperty("map")) $root.Star.MapInfo.encode(message.map, writer.uint32(
                /* id 5, wireType 2 =*/
                42).fork()).ldelim();
                if (message.roundStatus != null && message.hasOwnProperty("roundStatus")) writer.uint32(
                /* id 6, wireType 0 =*/
                48).int32(message.roundStatus);
                if (message.gameNo != null && message.hasOwnProperty("gameNo")) writer.uint32(
                /* id 7, wireType 0 =*/
                56).int32(message.gameNo);
                if (message.roundNo != null && message.hasOwnProperty("roundNo")) writer.uint32(
                /* id 8, wireType 0 =*/
                64).int32(message.roundNo);
                if (message.isPlayoff != null && message.hasOwnProperty("isPlayoff")) writer.uint32(
                /* id 9, wireType 0 =*/
                72).int32(message.isPlayoff);
                if (message.roundCountdown != null && message.hasOwnProperty("roundCountdown")) writer.uint32(
                /* id 10, wireType 0 =*/
                80).int32(message.roundCountdown);
                if (message.roundConfirmTime != null && message.hasOwnProperty("roundConfirmTime")) writer.uint32(
                /* id 11, wireType 0 =*/
                88).int32(message.roundConfirmTime);
                return writer;
              };
              /**
               * Encodes the specified UserReEnterRes message, length delimited. Does not implicitly {@link Star.UserReEnterRes.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Star.UserReEnterRes
               * @static
               * @param {Star.IUserReEnterRes} message UserReEnterRes message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              UserReEnterRes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a UserReEnterRes message from the specified reader or buffer.
               * @function decode
               * @memberof Star.UserReEnterRes
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Star.UserReEnterRes} UserReEnterRes
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              UserReEnterRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Star.UserReEnterRes();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.seqId = reader.int32();
                      break;

                    case 2:
                      message.battleId = reader.int64();
                      break;

                    case 3:
                      if (!(message.teamA && message.teamA.length)) message.teamA = [];
                      message.teamA.push($root.Star.UserInfo.decode(reader, reader.uint32()));
                      break;

                    case 4:
                      if (!(message.teamB && message.teamB.length)) message.teamB = [];
                      message.teamB.push($root.Star.UserInfo.decode(reader, reader.uint32()));
                      break;

                    case 5:
                      message.map = $root.Star.MapInfo.decode(reader, reader.uint32());
                      break;

                    case 6:
                      message.roundStatus = reader.int32();
                      break;

                    case 7:
                      message.gameNo = reader.int32();
                      break;

                    case 8:
                      message.roundNo = reader.int32();
                      break;

                    case 9:
                      message.isPlayoff = reader.int32();
                      break;

                    case 10:
                      message.roundCountdown = reader.int32();
                      break;

                    case 11:
                      message.roundConfirmTime = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a UserReEnterRes message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Star.UserReEnterRes
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Star.UserReEnterRes} UserReEnterRes
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              UserReEnterRes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a UserReEnterRes message.
               * @function verify
               * @memberof Star.UserReEnterRes
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              UserReEnterRes.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.seqId != null && message.hasOwnProperty("seqId")) if (!$util.isInteger(message.seqId)) return "seqId: integer expected";
                if (message.battleId != null && message.hasOwnProperty("battleId")) if (!$util.isInteger(message.battleId) && !(message.battleId && $util.isInteger(message.battleId.low) && $util.isInteger(message.battleId.high))) return "battleId: integer|Long expected";

                if (message.teamA != null && message.hasOwnProperty("teamA")) {
                  if (!Array.isArray(message.teamA)) return "teamA: array expected";

                  for (var i = 0; i < message.teamA.length; ++i) {
                    var error = $root.Star.UserInfo.verify(message.teamA[i]);
                    if (error) return "teamA." + error;
                  }
                }

                if (message.teamB != null && message.hasOwnProperty("teamB")) {
                  if (!Array.isArray(message.teamB)) return "teamB: array expected";

                  for (var i = 0; i < message.teamB.length; ++i) {
                    var error = $root.Star.UserInfo.verify(message.teamB[i]);
                    if (error) return "teamB." + error;
                  }
                }

                if (message.map != null && message.hasOwnProperty("map")) {
                  var error = $root.Star.MapInfo.verify(message.map);
                  if (error) return "map." + error;
                }

                if (message.roundStatus != null && message.hasOwnProperty("roundStatus")) if (!$util.isInteger(message.roundStatus)) return "roundStatus: integer expected";
                if (message.gameNo != null && message.hasOwnProperty("gameNo")) if (!$util.isInteger(message.gameNo)) return "gameNo: integer expected";
                if (message.roundNo != null && message.hasOwnProperty("roundNo")) if (!$util.isInteger(message.roundNo)) return "roundNo: integer expected";
                if (message.isPlayoff != null && message.hasOwnProperty("isPlayoff")) if (!$util.isInteger(message.isPlayoff)) return "isPlayoff: integer expected";
                if (message.roundCountdown != null && message.hasOwnProperty("roundCountdown")) if (!$util.isInteger(message.roundCountdown)) return "roundCountdown: integer expected";
                if (message.roundConfirmTime != null && message.hasOwnProperty("roundConfirmTime")) if (!$util.isInteger(message.roundConfirmTime)) return "roundConfirmTime: integer expected";
                return null;
              };

              return UserReEnterRes;
            }();

            Star.UserStatusChangeNotify = function () {
              /**
               * Properties of a UserStatusChangeNotify.
               * @memberof Star
               * @interface IUserStatusChangeNotify
               * @property {number|Long|null} [uid] UserStatusChangeNotify uid
               * @property {Star.ChangeType|null} [changeType] UserStatusChangeNotify changeType
               */

              /**
               * Constructs a new UserStatusChangeNotify.
               * @memberof Star
               * @classdesc Represents a UserStatusChangeNotify.
               * @implements IUserStatusChangeNotify
               * @constructor
               * @param {Star.IUserStatusChangeNotify=} [properties] Properties to set
               */
              function UserStatusChangeNotify(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * UserStatusChangeNotify uid.
               * @member {number|Long} uid
               * @memberof Star.UserStatusChangeNotify
               * @instance
               */


              UserStatusChangeNotify.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * UserStatusChangeNotify changeType.
               * @member {Star.ChangeType} changeType
               * @memberof Star.UserStatusChangeNotify
               * @instance
               */

              UserStatusChangeNotify.prototype.changeType = 0;
              /**
               * Creates a new UserStatusChangeNotify instance using the specified properties.
               * @function create
               * @memberof Star.UserStatusChangeNotify
               * @static
               * @param {Star.IUserStatusChangeNotify=} [properties] Properties to set
               * @returns {Star.UserStatusChangeNotify} UserStatusChangeNotify instance
               */

              UserStatusChangeNotify.create = function create(properties) {
                return new UserStatusChangeNotify(properties);
              };
              /**
               * Encodes the specified UserStatusChangeNotify message. Does not implicitly {@link Star.UserStatusChangeNotify.verify|verify} messages.
               * @function encode
               * @memberof Star.UserStatusChangeNotify
               * @static
               * @param {Star.IUserStatusChangeNotify} message UserStatusChangeNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              UserStatusChangeNotify.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.uid);
                if (message.changeType != null && message.hasOwnProperty("changeType")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int32(message.changeType);
                return writer;
              };
              /**
               * Encodes the specified UserStatusChangeNotify message, length delimited. Does not implicitly {@link Star.UserStatusChangeNotify.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Star.UserStatusChangeNotify
               * @static
               * @param {Star.IUserStatusChangeNotify} message UserStatusChangeNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              UserStatusChangeNotify.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a UserStatusChangeNotify message from the specified reader or buffer.
               * @function decode
               * @memberof Star.UserStatusChangeNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Star.UserStatusChangeNotify} UserStatusChangeNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              UserStatusChangeNotify.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Star.UserStatusChangeNotify();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.uid = reader.int64();
                      break;

                    case 2:
                      message.changeType = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a UserStatusChangeNotify message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Star.UserStatusChangeNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Star.UserStatusChangeNotify} UserStatusChangeNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              UserStatusChangeNotify.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a UserStatusChangeNotify message.
               * @function verify
               * @memberof Star.UserStatusChangeNotify
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              UserStatusChangeNotify.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                if (message.changeType != null && message.hasOwnProperty("changeType")) switch (message.changeType) {
                  default:
                    return "changeType: enum value expected";

                  case 0:
                  case 1:
                    break;
                }
                return null;
              };

              return UserStatusChangeNotify;
            }();

            Star.GameResultNotify = function () {
              /**
               * Properties of a GameResultNotify.
               * @memberof Star
               * @interface IGameResultNotify
               * @property {Star.ITeamEndInfo|null} [winner] GameResultNotify winner
               * @property {Star.ITeamEndInfo|null} [loser] GameResultNotify loser
               */

              /**
               * Constructs a new GameResultNotify.
               * @memberof Star
               * @classdesc Represents a GameResultNotify.
               * @implements IGameResultNotify
               * @constructor
               * @param {Star.IGameResultNotify=} [properties] Properties to set
               */
              function GameResultNotify(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * GameResultNotify winner.
               * @member {Star.ITeamEndInfo|null|undefined} winner
               * @memberof Star.GameResultNotify
               * @instance
               */


              GameResultNotify.prototype.winner = null;
              /**
               * GameResultNotify loser.
               * @member {Star.ITeamEndInfo|null|undefined} loser
               * @memberof Star.GameResultNotify
               * @instance
               */

              GameResultNotify.prototype.loser = null;
              /**
               * Creates a new GameResultNotify instance using the specified properties.
               * @function create
               * @memberof Star.GameResultNotify
               * @static
               * @param {Star.IGameResultNotify=} [properties] Properties to set
               * @returns {Star.GameResultNotify} GameResultNotify instance
               */

              GameResultNotify.create = function create(properties) {
                return new GameResultNotify(properties);
              };
              /**
               * Encodes the specified GameResultNotify message. Does not implicitly {@link Star.GameResultNotify.verify|verify} messages.
               * @function encode
               * @memberof Star.GameResultNotify
               * @static
               * @param {Star.IGameResultNotify} message GameResultNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              GameResultNotify.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.winner != null && message.hasOwnProperty("winner")) $root.Star.TeamEndInfo.encode(message.winner, writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
                if (message.loser != null && message.hasOwnProperty("loser")) $root.Star.TeamEndInfo.encode(message.loser, writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
                return writer;
              };
              /**
               * Encodes the specified GameResultNotify message, length delimited. Does not implicitly {@link Star.GameResultNotify.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Star.GameResultNotify
               * @static
               * @param {Star.IGameResultNotify} message GameResultNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              GameResultNotify.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a GameResultNotify message from the specified reader or buffer.
               * @function decode
               * @memberof Star.GameResultNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Star.GameResultNotify} GameResultNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              GameResultNotify.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Star.GameResultNotify();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.winner = $root.Star.TeamEndInfo.decode(reader, reader.uint32());
                      break;

                    case 2:
                      message.loser = $root.Star.TeamEndInfo.decode(reader, reader.uint32());
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a GameResultNotify message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Star.GameResultNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Star.GameResultNotify} GameResultNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              GameResultNotify.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a GameResultNotify message.
               * @function verify
               * @memberof Star.GameResultNotify
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              GameResultNotify.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";

                if (message.winner != null && message.hasOwnProperty("winner")) {
                  var error = $root.Star.TeamEndInfo.verify(message.winner);
                  if (error) return "winner." + error;
                }

                if (message.loser != null && message.hasOwnProperty("loser")) {
                  var error = $root.Star.TeamEndInfo.verify(message.loser);
                  if (error) return "loser." + error;
                }

                return null;
              };

              return GameResultNotify;
            }();

            Star.Grid = function () {
              /**
               * Properties of a Grid.
               * @memberof Star
               * @interface IGrid
               * @property {number|null} [id] Grid id
               * @property {number|null} [type] Grid type
               * @property {number|Long|null} [uid] Grid uid
               * @property {number|null} [gold] Grid gold
               */

              /**
               * Constructs a new Grid.
               * @memberof Star
               * @classdesc Represents a Grid.
               * @implements IGrid
               * @constructor
               * @param {Star.IGrid=} [properties] Properties to set
               */
              function Grid(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * Grid id.
               * @member {number} id
               * @memberof Star.Grid
               * @instance
               */


              Grid.prototype.id = 0;
              /**
               * Grid type.
               * @member {number} type
               * @memberof Star.Grid
               * @instance
               */

              Grid.prototype.type = 0;
              /**
               * Grid uid.
               * @member {number|Long} uid
               * @memberof Star.Grid
               * @instance
               */

              Grid.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * Grid gold.
               * @member {number} gold
               * @memberof Star.Grid
               * @instance
               */

              Grid.prototype.gold = 0;
              /**
               * Creates a new Grid instance using the specified properties.
               * @function create
               * @memberof Star.Grid
               * @static
               * @param {Star.IGrid=} [properties] Properties to set
               * @returns {Star.Grid} Grid instance
               */

              Grid.create = function create(properties) {
                return new Grid(properties);
              };
              /**
               * Encodes the specified Grid message. Does not implicitly {@link Star.Grid.verify|verify} messages.
               * @function encode
               * @memberof Star.Grid
               * @static
               * @param {Star.IGrid} message Grid message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              Grid.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int32(message.id);
                if (message.type != null && message.hasOwnProperty("type")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int32(message.type);
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 3, wireType 0 =*/
                24).int64(message.uid);
                if (message.gold != null && message.hasOwnProperty("gold")) writer.uint32(
                /* id 4, wireType 0 =*/
                32).int32(message.gold);
                return writer;
              };
              /**
               * Encodes the specified Grid message, length delimited. Does not implicitly {@link Star.Grid.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Star.Grid
               * @static
               * @param {Star.IGrid} message Grid message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              Grid.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a Grid message from the specified reader or buffer.
               * @function decode
               * @memberof Star.Grid
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Star.Grid} Grid
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              Grid.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Star.Grid();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.id = reader.int32();
                      break;

                    case 2:
                      message.type = reader.int32();
                      break;

                    case 3:
                      message.uid = reader.int64();
                      break;

                    case 4:
                      message.gold = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a Grid message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Star.Grid
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Star.Grid} Grid
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              Grid.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a Grid message.
               * @function verify
               * @memberof Star.Grid
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              Grid.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) if (!$util.isInteger(message.id)) return "id: integer expected";
                if (message.type != null && message.hasOwnProperty("type")) if (!$util.isInteger(message.type)) return "type: integer expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                if (message.gold != null && message.hasOwnProperty("gold")) if (!$util.isInteger(message.gold)) return "gold: integer expected";
                return null;
              };

              return Grid;
            }();

            Star.MapInfo = function () {
              /**
               * Properties of a MapInfo.
               * @memberof Star
               * @interface IMapInfo
               * @property {Array.<Star.IGrid>|null} [gridList] MapInfo gridList
               */

              /**
               * Constructs a new MapInfo.
               * @memberof Star
               * @classdesc Represents a MapInfo.
               * @implements IMapInfo
               * @constructor
               * @param {Star.IMapInfo=} [properties] Properties to set
               */
              function MapInfo(properties) {
                this.gridList = [];
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * MapInfo gridList.
               * @member {Array.<Star.IGrid>} gridList
               * @memberof Star.MapInfo
               * @instance
               */


              MapInfo.prototype.gridList = $util.emptyArray;
              /**
               * Creates a new MapInfo instance using the specified properties.
               * @function create
               * @memberof Star.MapInfo
               * @static
               * @param {Star.IMapInfo=} [properties] Properties to set
               * @returns {Star.MapInfo} MapInfo instance
               */

              MapInfo.create = function create(properties) {
                return new MapInfo(properties);
              };
              /**
               * Encodes the specified MapInfo message. Does not implicitly {@link Star.MapInfo.verify|verify} messages.
               * @function encode
               * @memberof Star.MapInfo
               * @static
               * @param {Star.IMapInfo} message MapInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              MapInfo.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.gridList != null && message.gridList.length) for (var i = 0; i < message.gridList.length; ++i) {
                  $root.Star.Grid.encode(message.gridList[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10).fork()).ldelim();
                }
                return writer;
              };
              /**
               * Encodes the specified MapInfo message, length delimited. Does not implicitly {@link Star.MapInfo.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Star.MapInfo
               * @static
               * @param {Star.IMapInfo} message MapInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              MapInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a MapInfo message from the specified reader or buffer.
               * @function decode
               * @memberof Star.MapInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Star.MapInfo} MapInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              MapInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Star.MapInfo();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      if (!(message.gridList && message.gridList.length)) message.gridList = [];
                      message.gridList.push($root.Star.Grid.decode(reader, reader.uint32()));
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a MapInfo message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Star.MapInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Star.MapInfo} MapInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              MapInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a MapInfo message.
               * @function verify
               * @memberof Star.MapInfo
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              MapInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";

                if (message.gridList != null && message.hasOwnProperty("gridList")) {
                  if (!Array.isArray(message.gridList)) return "gridList: array expected";

                  for (var i = 0; i < message.gridList.length; ++i) {
                    var error = $root.Star.Grid.verify(message.gridList[i]);
                    if (error) return "gridList." + error;
                  }
                }

                return null;
              };

              return MapInfo;
            }();

            Star.UserInfo = function () {
              /**
               * Properties of a UserInfo.
               * @memberof Star
               * @interface IUserInfo
               * @property {number|Long|null} [uid] UserInfo uid
               * @property {number|Long|null} [anchorUid] UserInfo anchorUid
               * @property {string|null} [avatar] UserInfo avatar
               * @property {string|null} [username] UserInfo username
               * @property {number|null} [score] UserInfo score
               * @property {string|null} [roleName] UserInfo roleName
               * @property {string|null} [roleIcon] UserInfo roleIcon
               * @property {number|null} [isAnchor] UserInfo isAnchor
               * @property {number|null} [userOnlineStatus] UserInfo userOnlineStatus
               * @property {string|null} [roleId] UserInfo roleId
               */

              /**
               * Constructs a new UserInfo.
               * @memberof Star
               * @classdesc Represents a UserInfo.
               * @implements IUserInfo
               * @constructor
               * @param {Star.IUserInfo=} [properties] Properties to set
               */
              function UserInfo(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * UserInfo uid.
               * @member {number|Long} uid
               * @memberof Star.UserInfo
               * @instance
               */


              UserInfo.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * UserInfo anchorUid.
               * @member {number|Long} anchorUid
               * @memberof Star.UserInfo
               * @instance
               */

              UserInfo.prototype.anchorUid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * UserInfo avatar.
               * @member {string} avatar
               * @memberof Star.UserInfo
               * @instance
               */

              UserInfo.prototype.avatar = "";
              /**
               * UserInfo username.
               * @member {string} username
               * @memberof Star.UserInfo
               * @instance
               */

              UserInfo.prototype.username = "";
              /**
               * UserInfo score.
               * @member {number} score
               * @memberof Star.UserInfo
               * @instance
               */

              UserInfo.prototype.score = 0;
              /**
               * UserInfo roleName.
               * @member {string} roleName
               * @memberof Star.UserInfo
               * @instance
               */

              UserInfo.prototype.roleName = "";
              /**
               * UserInfo roleIcon.
               * @member {string} roleIcon
               * @memberof Star.UserInfo
               * @instance
               */

              UserInfo.prototype.roleIcon = "";
              /**
               * UserInfo isAnchor.
               * @member {number} isAnchor
               * @memberof Star.UserInfo
               * @instance
               */

              UserInfo.prototype.isAnchor = 0;
              /**
               * UserInfo userOnlineStatus.
               * @member {number} userOnlineStatus
               * @memberof Star.UserInfo
               * @instance
               */

              UserInfo.prototype.userOnlineStatus = 0;
              /**
               * UserInfo roleId.
               * @member {string} roleId
               * @memberof Star.UserInfo
               * @instance
               */

              UserInfo.prototype.roleId = "";
              /**
               * Creates a new UserInfo instance using the specified properties.
               * @function create
               * @memberof Star.UserInfo
               * @static
               * @param {Star.IUserInfo=} [properties] Properties to set
               * @returns {Star.UserInfo} UserInfo instance
               */

              UserInfo.create = function create(properties) {
                return new UserInfo(properties);
              };
              /**
               * Encodes the specified UserInfo message. Does not implicitly {@link Star.UserInfo.verify|verify} messages.
               * @function encode
               * @memberof Star.UserInfo
               * @static
               * @param {Star.IUserInfo} message UserInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              UserInfo.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.uid);
                if (message.anchorUid != null && message.hasOwnProperty("anchorUid")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.anchorUid);
                if (message.avatar != null && message.hasOwnProperty("avatar")) writer.uint32(
                /* id 3, wireType 2 =*/
                26).string(message.avatar);
                if (message.username != null && message.hasOwnProperty("username")) writer.uint32(
                /* id 4, wireType 2 =*/
                34).string(message.username);
                if (message.score != null && message.hasOwnProperty("score")) writer.uint32(
                /* id 5, wireType 0 =*/
                40).int32(message.score);
                if (message.roleName != null && message.hasOwnProperty("roleName")) writer.uint32(
                /* id 6, wireType 2 =*/
                50).string(message.roleName);
                if (message.roleIcon != null && message.hasOwnProperty("roleIcon")) writer.uint32(
                /* id 7, wireType 2 =*/
                58).string(message.roleIcon);
                if (message.isAnchor != null && message.hasOwnProperty("isAnchor")) writer.uint32(
                /* id 8, wireType 0 =*/
                64).int32(message.isAnchor);
                if (message.userOnlineStatus != null && message.hasOwnProperty("userOnlineStatus")) writer.uint32(
                /* id 9, wireType 0 =*/
                72).int32(message.userOnlineStatus);
                if (message.roleId != null && message.hasOwnProperty("roleId")) writer.uint32(
                /* id 10, wireType 2 =*/
                82).string(message.roleId);
                return writer;
              };
              /**
               * Encodes the specified UserInfo message, length delimited. Does not implicitly {@link Star.UserInfo.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Star.UserInfo
               * @static
               * @param {Star.IUserInfo} message UserInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              UserInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a UserInfo message from the specified reader or buffer.
               * @function decode
               * @memberof Star.UserInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Star.UserInfo} UserInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              UserInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Star.UserInfo();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.uid = reader.int64();
                      break;

                    case 2:
                      message.anchorUid = reader.int64();
                      break;

                    case 3:
                      message.avatar = reader.string();
                      break;

                    case 4:
                      message.username = reader.string();
                      break;

                    case 5:
                      message.score = reader.int32();
                      break;

                    case 6:
                      message.roleName = reader.string();
                      break;

                    case 7:
                      message.roleIcon = reader.string();
                      break;

                    case 8:
                      message.isAnchor = reader.int32();
                      break;

                    case 9:
                      message.userOnlineStatus = reader.int32();
                      break;

                    case 10:
                      message.roleId = reader.string();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a UserInfo message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Star.UserInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Star.UserInfo} UserInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              UserInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a UserInfo message.
               * @function verify
               * @memberof Star.UserInfo
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              UserInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                if (message.anchorUid != null && message.hasOwnProperty("anchorUid")) if (!$util.isInteger(message.anchorUid) && !(message.anchorUid && $util.isInteger(message.anchorUid.low) && $util.isInteger(message.anchorUid.high))) return "anchorUid: integer|Long expected";
                if (message.avatar != null && message.hasOwnProperty("avatar")) if (!$util.isString(message.avatar)) return "avatar: string expected";
                if (message.username != null && message.hasOwnProperty("username")) if (!$util.isString(message.username)) return "username: string expected";
                if (message.score != null && message.hasOwnProperty("score")) if (!$util.isInteger(message.score)) return "score: integer expected";
                if (message.roleName != null && message.hasOwnProperty("roleName")) if (!$util.isString(message.roleName)) return "roleName: string expected";
                if (message.roleIcon != null && message.hasOwnProperty("roleIcon")) if (!$util.isString(message.roleIcon)) return "roleIcon: string expected";
                if (message.isAnchor != null && message.hasOwnProperty("isAnchor")) if (!$util.isInteger(message.isAnchor)) return "isAnchor: integer expected";
                if (message.userOnlineStatus != null && message.hasOwnProperty("userOnlineStatus")) if (!$util.isInteger(message.userOnlineStatus)) return "userOnlineStatus: integer expected";
                if (message.roleId != null && message.hasOwnProperty("roleId")) if (!$util.isString(message.roleId)) return "roleId: string expected";
                return null;
              };

              return UserInfo;
            }();

            Star.TeamEndInfo = function () {
              /**
               * Properties of a TeamEndInfo.
               * @memberof Star
               * @interface ITeamEndInfo
               * @property {number|Long|null} [anchorUid] TeamEndInfo anchorUid
               * @property {number|Long|null} [mvp] TeamEndInfo mvp
               * @property {number|null} [score] TeamEndInfo score
               * @property {Array.<Star.IUserInfo>|null} [userInfo] TeamEndInfo userInfo
               */

              /**
               * Constructs a new TeamEndInfo.
               * @memberof Star
               * @classdesc Represents a TeamEndInfo.
               * @implements ITeamEndInfo
               * @constructor
               * @param {Star.ITeamEndInfo=} [properties] Properties to set
               */
              function TeamEndInfo(properties) {
                this.userInfo = [];
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * TeamEndInfo anchorUid.
               * @member {number|Long} anchorUid
               * @memberof Star.TeamEndInfo
               * @instance
               */


              TeamEndInfo.prototype.anchorUid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * TeamEndInfo mvp.
               * @member {number|Long} mvp
               * @memberof Star.TeamEndInfo
               * @instance
               */

              TeamEndInfo.prototype.mvp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * TeamEndInfo score.
               * @member {number} score
               * @memberof Star.TeamEndInfo
               * @instance
               */

              TeamEndInfo.prototype.score = 0;
              /**
               * TeamEndInfo userInfo.
               * @member {Array.<Star.IUserInfo>} userInfo
               * @memberof Star.TeamEndInfo
               * @instance
               */

              TeamEndInfo.prototype.userInfo = $util.emptyArray;
              /**
               * Creates a new TeamEndInfo instance using the specified properties.
               * @function create
               * @memberof Star.TeamEndInfo
               * @static
               * @param {Star.ITeamEndInfo=} [properties] Properties to set
               * @returns {Star.TeamEndInfo} TeamEndInfo instance
               */

              TeamEndInfo.create = function create(properties) {
                return new TeamEndInfo(properties);
              };
              /**
               * Encodes the specified TeamEndInfo message. Does not implicitly {@link Star.TeamEndInfo.verify|verify} messages.
               * @function encode
               * @memberof Star.TeamEndInfo
               * @static
               * @param {Star.ITeamEndInfo} message TeamEndInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              TeamEndInfo.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.anchorUid != null && message.hasOwnProperty("anchorUid")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.anchorUid);
                if (message.mvp != null && message.hasOwnProperty("mvp")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.mvp);
                if (message.score != null && message.hasOwnProperty("score")) writer.uint32(
                /* id 3, wireType 0 =*/
                24).int32(message.score);
                if (message.userInfo != null && message.userInfo.length) for (var i = 0; i < message.userInfo.length; ++i) {
                  $root.Star.UserInfo.encode(message.userInfo[i], writer.uint32(
                  /* id 4, wireType 2 =*/
                  34).fork()).ldelim();
                }
                return writer;
              };
              /**
               * Encodes the specified TeamEndInfo message, length delimited. Does not implicitly {@link Star.TeamEndInfo.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Star.TeamEndInfo
               * @static
               * @param {Star.ITeamEndInfo} message TeamEndInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              TeamEndInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a TeamEndInfo message from the specified reader or buffer.
               * @function decode
               * @memberof Star.TeamEndInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Star.TeamEndInfo} TeamEndInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              TeamEndInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Star.TeamEndInfo();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.anchorUid = reader.int64();
                      break;

                    case 2:
                      message.mvp = reader.int64();
                      break;

                    case 3:
                      message.score = reader.int32();
                      break;

                    case 4:
                      if (!(message.userInfo && message.userInfo.length)) message.userInfo = [];
                      message.userInfo.push($root.Star.UserInfo.decode(reader, reader.uint32()));
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a TeamEndInfo message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Star.TeamEndInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Star.TeamEndInfo} TeamEndInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              TeamEndInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a TeamEndInfo message.
               * @function verify
               * @memberof Star.TeamEndInfo
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              TeamEndInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.anchorUid != null && message.hasOwnProperty("anchorUid")) if (!$util.isInteger(message.anchorUid) && !(message.anchorUid && $util.isInteger(message.anchorUid.low) && $util.isInteger(message.anchorUid.high))) return "anchorUid: integer|Long expected";
                if (message.mvp != null && message.hasOwnProperty("mvp")) if (!$util.isInteger(message.mvp) && !(message.mvp && $util.isInteger(message.mvp.low) && $util.isInteger(message.mvp.high))) return "mvp: integer|Long expected";
                if (message.score != null && message.hasOwnProperty("score")) if (!$util.isInteger(message.score)) return "score: integer expected";

                if (message.userInfo != null && message.hasOwnProperty("userInfo")) {
                  if (!Array.isArray(message.userInfo)) return "userInfo: array expected";

                  for (var i = 0; i < message.userInfo.length; ++i) {
                    var error = $root.Star.UserInfo.verify(message.userInfo[i]);
                    if (error) return "userInfo." + error;
                  }
                }

                return null;
              };

              return TeamEndInfo;
            }();

            Star.RoundSettleInfo = function () {
              /**
               * Properties of a RoundSettleInfo.
               * @memberof Star
               * @interface IRoundSettleInfo
               * @property {number|Long|null} [uid] RoundSettleInfo uid
               * @property {number|null} [gridNo] RoundSettleInfo gridNo
               * @property {number|null} [gold] RoundSettleInfo gold
               * @property {number|null} [score] RoundSettleInfo score
               */

              /**
               * Constructs a new RoundSettleInfo.
               * @memberof Star
               * @classdesc Represents a RoundSettleInfo.
               * @implements IRoundSettleInfo
               * @constructor
               * @param {Star.IRoundSettleInfo=} [properties] Properties to set
               */
              function RoundSettleInfo(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * RoundSettleInfo uid.
               * @member {number|Long} uid
               * @memberof Star.RoundSettleInfo
               * @instance
               */


              RoundSettleInfo.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * RoundSettleInfo gridNo.
               * @member {number} gridNo
               * @memberof Star.RoundSettleInfo
               * @instance
               */

              RoundSettleInfo.prototype.gridNo = 0;
              /**
               * RoundSettleInfo gold.
               * @member {number} gold
               * @memberof Star.RoundSettleInfo
               * @instance
               */

              RoundSettleInfo.prototype.gold = 0;
              /**
               * RoundSettleInfo score.
               * @member {number} score
               * @memberof Star.RoundSettleInfo
               * @instance
               */

              RoundSettleInfo.prototype.score = 0;
              /**
               * Creates a new RoundSettleInfo instance using the specified properties.
               * @function create
               * @memberof Star.RoundSettleInfo
               * @static
               * @param {Star.IRoundSettleInfo=} [properties] Properties to set
               * @returns {Star.RoundSettleInfo} RoundSettleInfo instance
               */

              RoundSettleInfo.create = function create(properties) {
                return new RoundSettleInfo(properties);
              };
              /**
               * Encodes the specified RoundSettleInfo message. Does not implicitly {@link Star.RoundSettleInfo.verify|verify} messages.
               * @function encode
               * @memberof Star.RoundSettleInfo
               * @static
               * @param {Star.IRoundSettleInfo} message RoundSettleInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              RoundSettleInfo.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.uid);
                if (message.gridNo != null && message.hasOwnProperty("gridNo")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int32(message.gridNo);
                if (message.gold != null && message.hasOwnProperty("gold")) writer.uint32(
                /* id 3, wireType 0 =*/
                24).int32(message.gold);
                if (message.score != null && message.hasOwnProperty("score")) writer.uint32(
                /* id 4, wireType 0 =*/
                32).int32(message.score);
                return writer;
              };
              /**
               * Encodes the specified RoundSettleInfo message, length delimited. Does not implicitly {@link Star.RoundSettleInfo.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Star.RoundSettleInfo
               * @static
               * @param {Star.IRoundSettleInfo} message RoundSettleInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              RoundSettleInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a RoundSettleInfo message from the specified reader or buffer.
               * @function decode
               * @memberof Star.RoundSettleInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Star.RoundSettleInfo} RoundSettleInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              RoundSettleInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Star.RoundSettleInfo();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.uid = reader.int64();
                      break;

                    case 2:
                      message.gridNo = reader.int32();
                      break;

                    case 3:
                      message.gold = reader.int32();
                      break;

                    case 4:
                      message.score = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a RoundSettleInfo message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Star.RoundSettleInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Star.RoundSettleInfo} RoundSettleInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              RoundSettleInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a RoundSettleInfo message.
               * @function verify
               * @memberof Star.RoundSettleInfo
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              RoundSettleInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                if (message.gridNo != null && message.hasOwnProperty("gridNo")) if (!$util.isInteger(message.gridNo)) return "gridNo: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold")) if (!$util.isInteger(message.gold)) return "gold: integer expected";
                if (message.score != null && message.hasOwnProperty("score")) if (!$util.isInteger(message.score)) return "score: integer expected";
                return null;
              };

              return RoundSettleInfo;
            }();
            /**
             * ChangeType enum.
             * @name Star.ChangeType
             * @enum {string}
             * @property {number} OFFLINE=0 OFFLINE value
             * @property {number} ONLINE=1 ONLINE value
             */


            Star.ChangeType = function () {
              var valuesById = {},
                  values = Object.create(valuesById);
              values[valuesById[0] = "OFFLINE"] = 0;
              values[valuesById[1] = "ONLINE"] = 1;
              return values;
            }();

            return Star;
          }();

          $root.Message = function () {
            /**
             * Namespace Message.
             * @exports Message
             * @namespace
             */
            var Message = {};

            Message.CommandRsp = function () {
              /**
               * Properties of a CommandRsp.
               * @memberof Message
               * @interface ICommandRsp
               * @property {number|Long|null} [battleId] CommandRsp battleId
               * @property {number|Long|null} [command] CommandRsp command
               */

              /**
               * Constructs a new CommandRsp.
               * @memberof Message
               * @classdesc Represents a CommandRsp.
               * @implements ICommandRsp
               * @constructor
               * @param {Message.ICommandRsp=} [properties] Properties to set
               */
              function CommandRsp(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * CommandRsp battleId.
               * @member {number|Long} battleId
               * @memberof Message.CommandRsp
               * @instance
               */


              CommandRsp.prototype.battleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * CommandRsp command.
               * @member {number|Long} command
               * @memberof Message.CommandRsp
               * @instance
               */

              CommandRsp.prototype.command = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * Creates a new CommandRsp instance using the specified properties.
               * @function create
               * @memberof Message.CommandRsp
               * @static
               * @param {Message.ICommandRsp=} [properties] Properties to set
               * @returns {Message.CommandRsp} CommandRsp instance
               */

              CommandRsp.create = function create(properties) {
                return new CommandRsp(properties);
              };
              /**
               * Encodes the specified CommandRsp message. Does not implicitly {@link Message.CommandRsp.verify|verify} messages.
               * @function encode
               * @memberof Message.CommandRsp
               * @static
               * @param {Message.ICommandRsp} message CommandRsp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              CommandRsp.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.battleId != null && message.hasOwnProperty("battleId")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.battleId);
                if (message.command != null && message.hasOwnProperty("command")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.command);
                return writer;
              };
              /**
               * Encodes the specified CommandRsp message, length delimited. Does not implicitly {@link Message.CommandRsp.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.CommandRsp
               * @static
               * @param {Message.ICommandRsp} message CommandRsp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              CommandRsp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a CommandRsp message from the specified reader or buffer.
               * @function decode
               * @memberof Message.CommandRsp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.CommandRsp} CommandRsp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              CommandRsp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.CommandRsp();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.battleId = reader.int64();
                      break;

                    case 2:
                      message.command = reader.int64();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a CommandRsp message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.CommandRsp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.CommandRsp} CommandRsp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              CommandRsp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a CommandRsp message.
               * @function verify
               * @memberof Message.CommandRsp
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              CommandRsp.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.battleId != null && message.hasOwnProperty("battleId")) if (!$util.isInteger(message.battleId) && !(message.battleId && $util.isInteger(message.battleId.low) && $util.isInteger(message.battleId.high))) return "battleId: integer|Long expected";
                if (message.command != null && message.hasOwnProperty("command")) if (!$util.isInteger(message.command) && !(message.command && $util.isInteger(message.command.low) && $util.isInteger(message.command.high))) return "command: integer|Long expected";
                return null;
              };

              return CommandRsp;
            }();

            Message.EnterGameReq = function () {
              /**
               * Properties of an EnterGameReq.
               * @memberof Message
               * @interface IEnterGameReq
               * @property {string|null} [roomId] EnterGameReq roomId
               * @property {number|Long|null} [uid] EnterGameReq uid
               */

              /**
               * Constructs a new EnterGameReq.
               * @memberof Message
               * @classdesc Represents an EnterGameReq.
               * @implements IEnterGameReq
               * @constructor
               * @param {Message.IEnterGameReq=} [properties] Properties to set
               */
              function EnterGameReq(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * EnterGameReq roomId.
               * @member {string} roomId
               * @memberof Message.EnterGameReq
               * @instance
               */


              EnterGameReq.prototype.roomId = "";
              /**
               * EnterGameReq uid.
               * @member {number|Long} uid
               * @memberof Message.EnterGameReq
               * @instance
               */

              EnterGameReq.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * Creates a new EnterGameReq instance using the specified properties.
               * @function create
               * @memberof Message.EnterGameReq
               * @static
               * @param {Message.IEnterGameReq=} [properties] Properties to set
               * @returns {Message.EnterGameReq} EnterGameReq instance
               */

              EnterGameReq.create = function create(properties) {
                return new EnterGameReq(properties);
              };
              /**
               * Encodes the specified EnterGameReq message. Does not implicitly {@link Message.EnterGameReq.verify|verify} messages.
               * @function encode
               * @memberof Message.EnterGameReq
               * @static
               * @param {Message.IEnterGameReq} message EnterGameReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              EnterGameReq.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.roomId != null && message.hasOwnProperty("roomId")) writer.uint32(
                /* id 1, wireType 2 =*/
                10).string(message.roomId);
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.uid);
                return writer;
              };
              /**
               * Encodes the specified EnterGameReq message, length delimited. Does not implicitly {@link Message.EnterGameReq.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.EnterGameReq
               * @static
               * @param {Message.IEnterGameReq} message EnterGameReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              EnterGameReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes an EnterGameReq message from the specified reader or buffer.
               * @function decode
               * @memberof Message.EnterGameReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.EnterGameReq} EnterGameReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              EnterGameReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.EnterGameReq();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.roomId = reader.string();
                      break;

                    case 2:
                      message.uid = reader.int64();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes an EnterGameReq message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.EnterGameReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.EnterGameReq} EnterGameReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              EnterGameReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies an EnterGameReq message.
               * @function verify
               * @memberof Message.EnterGameReq
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              EnterGameReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.roomId != null && message.hasOwnProperty("roomId")) if (!$util.isString(message.roomId)) return "roomId: string expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                return null;
              };

              return EnterGameReq;
            }();

            Message.StartGameReq = function () {
              /**
               * Properties of a StartGameReq.
               * @memberof Message
               * @interface IStartGameReq
               * @property {string|null} [roomId] StartGameReq roomId
               * @property {number|Long|null} [uid] StartGameReq uid
               * @property {Array.<Message.IUserInfo>|null} [userInfos] StartGameReq userInfos
               * @property {Array.<Message.IRewardInfo>|null} [rewardInfos] StartGameReq rewardInfos
               * @property {string|null} [gameMode] StartGameReq gameMode
               */

              /**
               * Constructs a new StartGameReq.
               * @memberof Message
               * @classdesc Represents a StartGameReq.
               * @implements IStartGameReq
               * @constructor
               * @param {Message.IStartGameReq=} [properties] Properties to set
               */
              function StartGameReq(properties) {
                this.userInfos = [];
                this.rewardInfos = [];
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * StartGameReq roomId.
               * @member {string} roomId
               * @memberof Message.StartGameReq
               * @instance
               */


              StartGameReq.prototype.roomId = "";
              /**
               * StartGameReq uid.
               * @member {number|Long} uid
               * @memberof Message.StartGameReq
               * @instance
               */

              StartGameReq.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * StartGameReq userInfos.
               * @member {Array.<Message.IUserInfo>} userInfos
               * @memberof Message.StartGameReq
               * @instance
               */

              StartGameReq.prototype.userInfos = $util.emptyArray;
              /**
               * StartGameReq rewardInfos.
               * @member {Array.<Message.IRewardInfo>} rewardInfos
               * @memberof Message.StartGameReq
               * @instance
               */

              StartGameReq.prototype.rewardInfos = $util.emptyArray;
              /**
               * StartGameReq gameMode.
               * @member {string} gameMode
               * @memberof Message.StartGameReq
               * @instance
               */

              StartGameReq.prototype.gameMode = "";
              /**
               * Creates a new StartGameReq instance using the specified properties.
               * @function create
               * @memberof Message.StartGameReq
               * @static
               * @param {Message.IStartGameReq=} [properties] Properties to set
               * @returns {Message.StartGameReq} StartGameReq instance
               */

              StartGameReq.create = function create(properties) {
                return new StartGameReq(properties);
              };
              /**
               * Encodes the specified StartGameReq message. Does not implicitly {@link Message.StartGameReq.verify|verify} messages.
               * @function encode
               * @memberof Message.StartGameReq
               * @static
               * @param {Message.IStartGameReq} message StartGameReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              StartGameReq.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.roomId != null && message.hasOwnProperty("roomId")) writer.uint32(
                /* id 1, wireType 2 =*/
                10).string(message.roomId);
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.uid);
                if (message.userInfos != null && message.userInfos.length) for (var i = 0; i < message.userInfos.length; ++i) {
                  $root.Message.UserInfo.encode(message.userInfos[i], writer.uint32(
                  /* id 3, wireType 2 =*/
                  26).fork()).ldelim();
                }
                if (message.rewardInfos != null && message.rewardInfos.length) for (var i = 0; i < message.rewardInfos.length; ++i) {
                  $root.Message.RewardInfo.encode(message.rewardInfos[i], writer.uint32(
                  /* id 4, wireType 2 =*/
                  34).fork()).ldelim();
                }
                if (message.gameMode != null && message.hasOwnProperty("gameMode")) writer.uint32(
                /* id 5, wireType 2 =*/
                42).string(message.gameMode);
                return writer;
              };
              /**
               * Encodes the specified StartGameReq message, length delimited. Does not implicitly {@link Message.StartGameReq.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.StartGameReq
               * @static
               * @param {Message.IStartGameReq} message StartGameReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              StartGameReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a StartGameReq message from the specified reader or buffer.
               * @function decode
               * @memberof Message.StartGameReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.StartGameReq} StartGameReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              StartGameReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.StartGameReq();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.roomId = reader.string();
                      break;

                    case 2:
                      message.uid = reader.int64();
                      break;

                    case 3:
                      if (!(message.userInfos && message.userInfos.length)) message.userInfos = [];
                      message.userInfos.push($root.Message.UserInfo.decode(reader, reader.uint32()));
                      break;

                    case 4:
                      if (!(message.rewardInfos && message.rewardInfos.length)) message.rewardInfos = [];
                      message.rewardInfos.push($root.Message.RewardInfo.decode(reader, reader.uint32()));
                      break;

                    case 5:
                      message.gameMode = reader.string();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a StartGameReq message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.StartGameReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.StartGameReq} StartGameReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              StartGameReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a StartGameReq message.
               * @function verify
               * @memberof Message.StartGameReq
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              StartGameReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.roomId != null && message.hasOwnProperty("roomId")) if (!$util.isString(message.roomId)) return "roomId: string expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";

                if (message.userInfos != null && message.hasOwnProperty("userInfos")) {
                  if (!Array.isArray(message.userInfos)) return "userInfos: array expected";

                  for (var i = 0; i < message.userInfos.length; ++i) {
                    var error = $root.Message.UserInfo.verify(message.userInfos[i]);
                    if (error) return "userInfos." + error;
                  }
                }

                if (message.rewardInfos != null && message.hasOwnProperty("rewardInfos")) {
                  if (!Array.isArray(message.rewardInfos)) return "rewardInfos: array expected";

                  for (var i = 0; i < message.rewardInfos.length; ++i) {
                    var error = $root.Message.RewardInfo.verify(message.rewardInfos[i]);
                    if (error) return "rewardInfos." + error;
                  }
                }

                if (message.gameMode != null && message.hasOwnProperty("gameMode")) if (!$util.isString(message.gameMode)) return "gameMode: string expected";
                return null;
              };

              return StartGameReq;
            }();

            Message.FinishGameReq = function () {
              /**
               * Properties of a FinishGameReq.
               * @memberof Message
               * @interface IFinishGameReq
               * @property {number|Long|null} [battleId] FinishGameReq battleId
               * @property {number|Long|null} [gameId] FinishGameReq gameId
               * @property {number|null} [scoreCount] FinishGameReq scoreCount
               * @property {Message.BattleEndReason|null} [endReason] FinishGameReq endReason
               * @property {Array.<Message.IBattleMemberInfo>|null} [memberInfos] FinishGameReq memberInfos
               * @property {string|null} [extInfo] FinishGameReq extInfo
               */

              /**
               * Constructs a new FinishGameReq.
               * @memberof Message
               * @classdesc Represents a FinishGameReq.
               * @implements IFinishGameReq
               * @constructor
               * @param {Message.IFinishGameReq=} [properties] Properties to set
               */
              function FinishGameReq(properties) {
                this.memberInfos = [];
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * FinishGameReq battleId.
               * @member {number|Long} battleId
               * @memberof Message.FinishGameReq
               * @instance
               */


              FinishGameReq.prototype.battleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * FinishGameReq gameId.
               * @member {number|Long} gameId
               * @memberof Message.FinishGameReq
               * @instance
               */

              FinishGameReq.prototype.gameId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * FinishGameReq scoreCount.
               * @member {number} scoreCount
               * @memberof Message.FinishGameReq
               * @instance
               */

              FinishGameReq.prototype.scoreCount = 0;
              /**
               * FinishGameReq endReason.
               * @member {Message.BattleEndReason} endReason
               * @memberof Message.FinishGameReq
               * @instance
               */

              FinishGameReq.prototype.endReason = 0;
              /**
               * FinishGameReq memberInfos.
               * @member {Array.<Message.IBattleMemberInfo>} memberInfos
               * @memberof Message.FinishGameReq
               * @instance
               */

              FinishGameReq.prototype.memberInfos = $util.emptyArray;
              /**
               * FinishGameReq extInfo.
               * @member {string} extInfo
               * @memberof Message.FinishGameReq
               * @instance
               */

              FinishGameReq.prototype.extInfo = "";
              /**
               * Creates a new FinishGameReq instance using the specified properties.
               * @function create
               * @memberof Message.FinishGameReq
               * @static
               * @param {Message.IFinishGameReq=} [properties] Properties to set
               * @returns {Message.FinishGameReq} FinishGameReq instance
               */

              FinishGameReq.create = function create(properties) {
                return new FinishGameReq(properties);
              };
              /**
               * Encodes the specified FinishGameReq message. Does not implicitly {@link Message.FinishGameReq.verify|verify} messages.
               * @function encode
               * @memberof Message.FinishGameReq
               * @static
               * @param {Message.IFinishGameReq} message FinishGameReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              FinishGameReq.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.battleId != null && message.hasOwnProperty("battleId")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.battleId);
                if (message.gameId != null && message.hasOwnProperty("gameId")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.gameId);
                if (message.scoreCount != null && message.hasOwnProperty("scoreCount")) writer.uint32(
                /* id 3, wireType 0 =*/
                24).int32(message.scoreCount);
                if (message.endReason != null && message.hasOwnProperty("endReason")) writer.uint32(
                /* id 4, wireType 0 =*/
                32).int32(message.endReason);
                if (message.memberInfos != null && message.memberInfos.length) for (var i = 0; i < message.memberInfos.length; ++i) {
                  $root.Message.BattleMemberInfo.encode(message.memberInfos[i], writer.uint32(
                  /* id 5, wireType 2 =*/
                  42).fork()).ldelim();
                }
                if (message.extInfo != null && message.hasOwnProperty("extInfo")) writer.uint32(
                /* id 6, wireType 2 =*/
                50).string(message.extInfo);
                return writer;
              };
              /**
               * Encodes the specified FinishGameReq message, length delimited. Does not implicitly {@link Message.FinishGameReq.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.FinishGameReq
               * @static
               * @param {Message.IFinishGameReq} message FinishGameReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              FinishGameReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a FinishGameReq message from the specified reader or buffer.
               * @function decode
               * @memberof Message.FinishGameReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.FinishGameReq} FinishGameReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              FinishGameReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.FinishGameReq();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.battleId = reader.int64();
                      break;

                    case 2:
                      message.gameId = reader.int64();
                      break;

                    case 3:
                      message.scoreCount = reader.int32();
                      break;

                    case 4:
                      message.endReason = reader.int32();
                      break;

                    case 5:
                      if (!(message.memberInfos && message.memberInfos.length)) message.memberInfos = [];
                      message.memberInfos.push($root.Message.BattleMemberInfo.decode(reader, reader.uint32()));
                      break;

                    case 6:
                      message.extInfo = reader.string();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a FinishGameReq message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.FinishGameReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.FinishGameReq} FinishGameReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              FinishGameReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a FinishGameReq message.
               * @function verify
               * @memberof Message.FinishGameReq
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              FinishGameReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.battleId != null && message.hasOwnProperty("battleId")) if (!$util.isInteger(message.battleId) && !(message.battleId && $util.isInteger(message.battleId.low) && $util.isInteger(message.battleId.high))) return "battleId: integer|Long expected";
                if (message.gameId != null && message.hasOwnProperty("gameId")) if (!$util.isInteger(message.gameId) && !(message.gameId && $util.isInteger(message.gameId.low) && $util.isInteger(message.gameId.high))) return "gameId: integer|Long expected";
                if (message.scoreCount != null && message.hasOwnProperty("scoreCount")) if (!$util.isInteger(message.scoreCount)) return "scoreCount: integer expected";
                if (message.endReason != null && message.hasOwnProperty("endReason")) switch (message.endReason) {
                  default:
                    return "endReason: enum value expected";

                  case 0:
                  case 1:
                    break;
                }

                if (message.memberInfos != null && message.hasOwnProperty("memberInfos")) {
                  if (!Array.isArray(message.memberInfos)) return "memberInfos: array expected";

                  for (var i = 0; i < message.memberInfos.length; ++i) {
                    var error = $root.Message.BattleMemberInfo.verify(message.memberInfos[i]);
                    if (error) return "memberInfos." + error;
                  }
                }

                if (message.extInfo != null && message.hasOwnProperty("extInfo")) if (!$util.isString(message.extInfo)) return "extInfo: string expected";
                return null;
              };

              return FinishGameReq;
            }();

            Message.BattleLexiconReq = function () {
              /**
               * Properties of a BattleLexiconReq.
               * @memberof Message
               * @interface IBattleLexiconReq
               * @property {number|null} [gameId] BattleLexiconReq gameId
               * @property {number|null} [page] BattleLexiconReq page
               */

              /**
               * Constructs a new BattleLexiconReq.
               * @memberof Message
               * @classdesc Represents a BattleLexiconReq.
               * @implements IBattleLexiconReq
               * @constructor
               * @param {Message.IBattleLexiconReq=} [properties] Properties to set
               */
              function BattleLexiconReq(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * BattleLexiconReq gameId.
               * @member {number} gameId
               * @memberof Message.BattleLexiconReq
               * @instance
               */


              BattleLexiconReq.prototype.gameId = 0;
              /**
               * BattleLexiconReq page.
               * @member {number} page
               * @memberof Message.BattleLexiconReq
               * @instance
               */

              BattleLexiconReq.prototype.page = 0;
              /**
               * Creates a new BattleLexiconReq instance using the specified properties.
               * @function create
               * @memberof Message.BattleLexiconReq
               * @static
               * @param {Message.IBattleLexiconReq=} [properties] Properties to set
               * @returns {Message.BattleLexiconReq} BattleLexiconReq instance
               */

              BattleLexiconReq.create = function create(properties) {
                return new BattleLexiconReq(properties);
              };
              /**
               * Encodes the specified BattleLexiconReq message. Does not implicitly {@link Message.BattleLexiconReq.verify|verify} messages.
               * @function encode
               * @memberof Message.BattleLexiconReq
               * @static
               * @param {Message.IBattleLexiconReq} message BattleLexiconReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              BattleLexiconReq.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.gameId != null && message.hasOwnProperty("gameId")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int32(message.gameId);
                if (message.page != null && message.hasOwnProperty("page")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int32(message.page);
                return writer;
              };
              /**
               * Encodes the specified BattleLexiconReq message, length delimited. Does not implicitly {@link Message.BattleLexiconReq.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.BattleLexiconReq
               * @static
               * @param {Message.IBattleLexiconReq} message BattleLexiconReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              BattleLexiconReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a BattleLexiconReq message from the specified reader or buffer.
               * @function decode
               * @memberof Message.BattleLexiconReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.BattleLexiconReq} BattleLexiconReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              BattleLexiconReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.BattleLexiconReq();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.gameId = reader.int32();
                      break;

                    case 2:
                      message.page = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a BattleLexiconReq message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.BattleLexiconReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.BattleLexiconReq} BattleLexiconReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              BattleLexiconReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a BattleLexiconReq message.
               * @function verify
               * @memberof Message.BattleLexiconReq
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              BattleLexiconReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.gameId != null && message.hasOwnProperty("gameId")) if (!$util.isInteger(message.gameId)) return "gameId: integer expected";
                if (message.page != null && message.hasOwnProperty("page")) if (!$util.isInteger(message.page)) return "page: integer expected";
                return null;
              };

              return BattleLexiconReq;
            }();

            Message.DismissGameReq = function () {
              /**
               * Properties of a DismissGameReq.
               * @memberof Message
               * @interface IDismissGameReq
               * @property {number|Long|null} [battleId] DismissGameReq battleId
               * @property {number|Long|null} [uid] DismissGameReq uid
               * @property {string|null} [roomId] DismissGameReq roomId
               */

              /**
               * Constructs a new DismissGameReq.
               * @memberof Message
               * @classdesc Represents a DismissGameReq.
               * @implements IDismissGameReq
               * @constructor
               * @param {Message.IDismissGameReq=} [properties] Properties to set
               */
              function DismissGameReq(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * DismissGameReq battleId.
               * @member {number|Long} battleId
               * @memberof Message.DismissGameReq
               * @instance
               */


              DismissGameReq.prototype.battleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * DismissGameReq uid.
               * @member {number|Long} uid
               * @memberof Message.DismissGameReq
               * @instance
               */

              DismissGameReq.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * DismissGameReq roomId.
               * @member {string} roomId
               * @memberof Message.DismissGameReq
               * @instance
               */

              DismissGameReq.prototype.roomId = "";
              /**
               * Creates a new DismissGameReq instance using the specified properties.
               * @function create
               * @memberof Message.DismissGameReq
               * @static
               * @param {Message.IDismissGameReq=} [properties] Properties to set
               * @returns {Message.DismissGameReq} DismissGameReq instance
               */

              DismissGameReq.create = function create(properties) {
                return new DismissGameReq(properties);
              };
              /**
               * Encodes the specified DismissGameReq message. Does not implicitly {@link Message.DismissGameReq.verify|verify} messages.
               * @function encode
               * @memberof Message.DismissGameReq
               * @static
               * @param {Message.IDismissGameReq} message DismissGameReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              DismissGameReq.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.battleId != null && message.hasOwnProperty("battleId")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.battleId);
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.uid);
                if (message.roomId != null && message.hasOwnProperty("roomId")) writer.uint32(
                /* id 3, wireType 2 =*/
                26).string(message.roomId);
                return writer;
              };
              /**
               * Encodes the specified DismissGameReq message, length delimited. Does not implicitly {@link Message.DismissGameReq.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.DismissGameReq
               * @static
               * @param {Message.IDismissGameReq} message DismissGameReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              DismissGameReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a DismissGameReq message from the specified reader or buffer.
               * @function decode
               * @memberof Message.DismissGameReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.DismissGameReq} DismissGameReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              DismissGameReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.DismissGameReq();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.battleId = reader.int64();
                      break;

                    case 2:
                      message.uid = reader.int64();
                      break;

                    case 3:
                      message.roomId = reader.string();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a DismissGameReq message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.DismissGameReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.DismissGameReq} DismissGameReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              DismissGameReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a DismissGameReq message.
               * @function verify
               * @memberof Message.DismissGameReq
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              DismissGameReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.battleId != null && message.hasOwnProperty("battleId")) if (!$util.isInteger(message.battleId) && !(message.battleId && $util.isInteger(message.battleId.low) && $util.isInteger(message.battleId.high))) return "battleId: integer|Long expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                if (message.roomId != null && message.hasOwnProperty("roomId")) if (!$util.isString(message.roomId)) return "roomId: string expected";
                return null;
              };

              return DismissGameReq;
            }();

            Message.GatewayStatusReq = function () {
              /**
               * Properties of a GatewayStatusReq.
               * @memberof Message
               * @interface IGatewayStatusReq
               * @property {string|null} [roomId] GatewayStatusReq roomId
               * @property {number|Long|null} [uid] GatewayStatusReq uid
               */

              /**
               * Constructs a new GatewayStatusReq.
               * @memberof Message
               * @classdesc Represents a GatewayStatusReq.
               * @implements IGatewayStatusReq
               * @constructor
               * @param {Message.IGatewayStatusReq=} [properties] Properties to set
               */
              function GatewayStatusReq(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * GatewayStatusReq roomId.
               * @member {string} roomId
               * @memberof Message.GatewayStatusReq
               * @instance
               */


              GatewayStatusReq.prototype.roomId = "";
              /**
               * GatewayStatusReq uid.
               * @member {number|Long} uid
               * @memberof Message.GatewayStatusReq
               * @instance
               */

              GatewayStatusReq.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * Creates a new GatewayStatusReq instance using the specified properties.
               * @function create
               * @memberof Message.GatewayStatusReq
               * @static
               * @param {Message.IGatewayStatusReq=} [properties] Properties to set
               * @returns {Message.GatewayStatusReq} GatewayStatusReq instance
               */

              GatewayStatusReq.create = function create(properties) {
                return new GatewayStatusReq(properties);
              };
              /**
               * Encodes the specified GatewayStatusReq message. Does not implicitly {@link Message.GatewayStatusReq.verify|verify} messages.
               * @function encode
               * @memberof Message.GatewayStatusReq
               * @static
               * @param {Message.IGatewayStatusReq} message GatewayStatusReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              GatewayStatusReq.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.roomId != null && message.hasOwnProperty("roomId")) writer.uint32(
                /* id 1, wireType 2 =*/
                10).string(message.roomId);
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.uid);
                return writer;
              };
              /**
               * Encodes the specified GatewayStatusReq message, length delimited. Does not implicitly {@link Message.GatewayStatusReq.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.GatewayStatusReq
               * @static
               * @param {Message.IGatewayStatusReq} message GatewayStatusReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              GatewayStatusReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a GatewayStatusReq message from the specified reader or buffer.
               * @function decode
               * @memberof Message.GatewayStatusReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.GatewayStatusReq} GatewayStatusReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              GatewayStatusReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.GatewayStatusReq();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.roomId = reader.string();
                      break;

                    case 2:
                      message.uid = reader.int64();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a GatewayStatusReq message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.GatewayStatusReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.GatewayStatusReq} GatewayStatusReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              GatewayStatusReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a GatewayStatusReq message.
               * @function verify
               * @memberof Message.GatewayStatusReq
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              GatewayStatusReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.roomId != null && message.hasOwnProperty("roomId")) if (!$util.isString(message.roomId)) return "roomId: string expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                return null;
              };

              return GatewayStatusReq;
            }();

            Message.PrepareJoinGame = function () {
              /**
               * Properties of a PrepareJoinGame.
               * @memberof Message
               * @interface IPrepareJoinGame
               * @property {string|null} [roomId] PrepareJoinGame roomId
               * @property {number|Long|null} [uid] PrepareJoinGame uid
               * @property {Message.ReadyStatus|null} [readyStatus] PrepareJoinGame readyStatus
               */

              /**
               * Constructs a new PrepareJoinGame.
               * @memberof Message
               * @classdesc Represents a PrepareJoinGame.
               * @implements IPrepareJoinGame
               * @constructor
               * @param {Message.IPrepareJoinGame=} [properties] Properties to set
               */
              function PrepareJoinGame(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * PrepareJoinGame roomId.
               * @member {string} roomId
               * @memberof Message.PrepareJoinGame
               * @instance
               */


              PrepareJoinGame.prototype.roomId = "";
              /**
               * PrepareJoinGame uid.
               * @member {number|Long} uid
               * @memberof Message.PrepareJoinGame
               * @instance
               */

              PrepareJoinGame.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * PrepareJoinGame readyStatus.
               * @member {Message.ReadyStatus} readyStatus
               * @memberof Message.PrepareJoinGame
               * @instance
               */

              PrepareJoinGame.prototype.readyStatus = 0;
              /**
               * Creates a new PrepareJoinGame instance using the specified properties.
               * @function create
               * @memberof Message.PrepareJoinGame
               * @static
               * @param {Message.IPrepareJoinGame=} [properties] Properties to set
               * @returns {Message.PrepareJoinGame} PrepareJoinGame instance
               */

              PrepareJoinGame.create = function create(properties) {
                return new PrepareJoinGame(properties);
              };
              /**
               * Encodes the specified PrepareJoinGame message. Does not implicitly {@link Message.PrepareJoinGame.verify|verify} messages.
               * @function encode
               * @memberof Message.PrepareJoinGame
               * @static
               * @param {Message.IPrepareJoinGame} message PrepareJoinGame message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              PrepareJoinGame.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.roomId != null && message.hasOwnProperty("roomId")) writer.uint32(
                /* id 1, wireType 2 =*/
                10).string(message.roomId);
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.uid);
                if (message.readyStatus != null && message.hasOwnProperty("readyStatus")) writer.uint32(
                /* id 3, wireType 0 =*/
                24).int32(message.readyStatus);
                return writer;
              };
              /**
               * Encodes the specified PrepareJoinGame message, length delimited. Does not implicitly {@link Message.PrepareJoinGame.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.PrepareJoinGame
               * @static
               * @param {Message.IPrepareJoinGame} message PrepareJoinGame message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              PrepareJoinGame.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a PrepareJoinGame message from the specified reader or buffer.
               * @function decode
               * @memberof Message.PrepareJoinGame
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.PrepareJoinGame} PrepareJoinGame
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              PrepareJoinGame.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.PrepareJoinGame();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.roomId = reader.string();
                      break;

                    case 2:
                      message.uid = reader.int64();
                      break;

                    case 3:
                      message.readyStatus = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a PrepareJoinGame message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.PrepareJoinGame
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.PrepareJoinGame} PrepareJoinGame
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              PrepareJoinGame.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a PrepareJoinGame message.
               * @function verify
               * @memberof Message.PrepareJoinGame
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              PrepareJoinGame.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.roomId != null && message.hasOwnProperty("roomId")) if (!$util.isString(message.roomId)) return "roomId: string expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                if (message.readyStatus != null && message.hasOwnProperty("readyStatus")) switch (message.readyStatus) {
                  default:
                    return "readyStatus: enum value expected";

                  case 0:
                  case 1:
                    break;
                }
                return null;
              };

              return PrepareJoinGame;
            }();

            Message.KickingPeopleReq = function () {
              /**
               * Properties of a KickingPeopleReq.
               * @memberof Message
               * @interface IKickingPeopleReq
               * @property {number|Long|null} [uid] KickingPeopleReq uid
               * @property {string|null} [roomId] KickingPeopleReq roomId
               */

              /**
               * Constructs a new KickingPeopleReq.
               * @memberof Message
               * @classdesc Represents a KickingPeopleReq.
               * @implements IKickingPeopleReq
               * @constructor
               * @param {Message.IKickingPeopleReq=} [properties] Properties to set
               */
              function KickingPeopleReq(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * KickingPeopleReq uid.
               * @member {number|Long} uid
               * @memberof Message.KickingPeopleReq
               * @instance
               */


              KickingPeopleReq.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * KickingPeopleReq roomId.
               * @member {string} roomId
               * @memberof Message.KickingPeopleReq
               * @instance
               */

              KickingPeopleReq.prototype.roomId = "";
              /**
               * Creates a new KickingPeopleReq instance using the specified properties.
               * @function create
               * @memberof Message.KickingPeopleReq
               * @static
               * @param {Message.IKickingPeopleReq=} [properties] Properties to set
               * @returns {Message.KickingPeopleReq} KickingPeopleReq instance
               */

              KickingPeopleReq.create = function create(properties) {
                return new KickingPeopleReq(properties);
              };
              /**
               * Encodes the specified KickingPeopleReq message. Does not implicitly {@link Message.KickingPeopleReq.verify|verify} messages.
               * @function encode
               * @memberof Message.KickingPeopleReq
               * @static
               * @param {Message.IKickingPeopleReq} message KickingPeopleReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              KickingPeopleReq.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.uid);
                if (message.roomId != null && message.hasOwnProperty("roomId")) writer.uint32(
                /* id 2, wireType 2 =*/
                18).string(message.roomId);
                return writer;
              };
              /**
               * Encodes the specified KickingPeopleReq message, length delimited. Does not implicitly {@link Message.KickingPeopleReq.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.KickingPeopleReq
               * @static
               * @param {Message.IKickingPeopleReq} message KickingPeopleReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              KickingPeopleReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a KickingPeopleReq message from the specified reader or buffer.
               * @function decode
               * @memberof Message.KickingPeopleReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.KickingPeopleReq} KickingPeopleReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              KickingPeopleReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.KickingPeopleReq();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.uid = reader.int64();
                      break;

                    case 2:
                      message.roomId = reader.string();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a KickingPeopleReq message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.KickingPeopleReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.KickingPeopleReq} KickingPeopleReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              KickingPeopleReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a KickingPeopleReq message.
               * @function verify
               * @memberof Message.KickingPeopleReq
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              KickingPeopleReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                if (message.roomId != null && message.hasOwnProperty("roomId")) if (!$util.isString(message.roomId)) return "roomId: string expected";
                return null;
              };

              return KickingPeopleReq;
            }();

            Message.BattleMemberInfo = function () {
              /**
               * Properties of a BattleMemberInfo.
               * @memberof Message
               * @interface IBattleMemberInfo
               * @property {number|Long|null} [uid] BattleMemberInfo uid
               * @property {Message.Identity|null} [identity] BattleMemberInfo identity
               * @property {number|null} [battleScore] BattleMemberInfo battleScore
               * @property {number|null} [battleRank] BattleMemberInfo battleRank
               * @property {number|null} [expReceive] BattleMemberInfo expReceive
               * @property {Array.<Message.IRewardInfo>|null} [rewardInfos] BattleMemberInfo rewardInfos
               * @property {Message.BattleEndReason|null} [endReason] BattleMemberInfo endReason
               * @property {string|null} [extInfo] BattleMemberInfo extInfo
               */

              /**
               * Constructs a new BattleMemberInfo.
               * @memberof Message
               * @classdesc Represents a BattleMemberInfo.
               * @implements IBattleMemberInfo
               * @constructor
               * @param {Message.IBattleMemberInfo=} [properties] Properties to set
               */
              function BattleMemberInfo(properties) {
                this.rewardInfos = [];
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * BattleMemberInfo uid.
               * @member {number|Long} uid
               * @memberof Message.BattleMemberInfo
               * @instance
               */


              BattleMemberInfo.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * BattleMemberInfo identity.
               * @member {Message.Identity} identity
               * @memberof Message.BattleMemberInfo
               * @instance
               */

              BattleMemberInfo.prototype.identity = 0;
              /**
               * BattleMemberInfo battleScore.
               * @member {number} battleScore
               * @memberof Message.BattleMemberInfo
               * @instance
               */

              BattleMemberInfo.prototype.battleScore = 0;
              /**
               * BattleMemberInfo battleRank.
               * @member {number} battleRank
               * @memberof Message.BattleMemberInfo
               * @instance
               */

              BattleMemberInfo.prototype.battleRank = 0;
              /**
               * BattleMemberInfo expReceive.
               * @member {number} expReceive
               * @memberof Message.BattleMemberInfo
               * @instance
               */

              BattleMemberInfo.prototype.expReceive = 0;
              /**
               * BattleMemberInfo rewardInfos.
               * @member {Array.<Message.IRewardInfo>} rewardInfos
               * @memberof Message.BattleMemberInfo
               * @instance
               */

              BattleMemberInfo.prototype.rewardInfos = $util.emptyArray;
              /**
               * BattleMemberInfo endReason.
               * @member {Message.BattleEndReason} endReason
               * @memberof Message.BattleMemberInfo
               * @instance
               */

              BattleMemberInfo.prototype.endReason = 0;
              /**
               * BattleMemberInfo extInfo.
               * @member {string} extInfo
               * @memberof Message.BattleMemberInfo
               * @instance
               */

              BattleMemberInfo.prototype.extInfo = "";
              /**
               * Creates a new BattleMemberInfo instance using the specified properties.
               * @function create
               * @memberof Message.BattleMemberInfo
               * @static
               * @param {Message.IBattleMemberInfo=} [properties] Properties to set
               * @returns {Message.BattleMemberInfo} BattleMemberInfo instance
               */

              BattleMemberInfo.create = function create(properties) {
                return new BattleMemberInfo(properties);
              };
              /**
               * Encodes the specified BattleMemberInfo message. Does not implicitly {@link Message.BattleMemberInfo.verify|verify} messages.
               * @function encode
               * @memberof Message.BattleMemberInfo
               * @static
               * @param {Message.IBattleMemberInfo} message BattleMemberInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              BattleMemberInfo.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.uid);
                if (message.identity != null && message.hasOwnProperty("identity")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int32(message.identity);
                if (message.battleScore != null && message.hasOwnProperty("battleScore")) writer.uint32(
                /* id 3, wireType 0 =*/
                24).int32(message.battleScore);
                if (message.battleRank != null && message.hasOwnProperty("battleRank")) writer.uint32(
                /* id 4, wireType 0 =*/
                32).int32(message.battleRank);
                if (message.expReceive != null && message.hasOwnProperty("expReceive")) writer.uint32(
                /* id 5, wireType 0 =*/
                40).int32(message.expReceive);
                if (message.rewardInfos != null && message.rewardInfos.length) for (var i = 0; i < message.rewardInfos.length; ++i) {
                  $root.Message.RewardInfo.encode(message.rewardInfos[i], writer.uint32(
                  /* id 6, wireType 2 =*/
                  50).fork()).ldelim();
                }
                if (message.endReason != null && message.hasOwnProperty("endReason")) writer.uint32(
                /* id 7, wireType 0 =*/
                56).int32(message.endReason);
                if (message.extInfo != null && message.hasOwnProperty("extInfo")) writer.uint32(
                /* id 8, wireType 2 =*/
                66).string(message.extInfo);
                return writer;
              };
              /**
               * Encodes the specified BattleMemberInfo message, length delimited. Does not implicitly {@link Message.BattleMemberInfo.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.BattleMemberInfo
               * @static
               * @param {Message.IBattleMemberInfo} message BattleMemberInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              BattleMemberInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a BattleMemberInfo message from the specified reader or buffer.
               * @function decode
               * @memberof Message.BattleMemberInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.BattleMemberInfo} BattleMemberInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              BattleMemberInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.BattleMemberInfo();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.uid = reader.int64();
                      break;

                    case 2:
                      message.identity = reader.int32();
                      break;

                    case 3:
                      message.battleScore = reader.int32();
                      break;

                    case 4:
                      message.battleRank = reader.int32();
                      break;

                    case 5:
                      message.expReceive = reader.int32();
                      break;

                    case 6:
                      if (!(message.rewardInfos && message.rewardInfos.length)) message.rewardInfos = [];
                      message.rewardInfos.push($root.Message.RewardInfo.decode(reader, reader.uint32()));
                      break;

                    case 7:
                      message.endReason = reader.int32();
                      break;

                    case 8:
                      message.extInfo = reader.string();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a BattleMemberInfo message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.BattleMemberInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.BattleMemberInfo} BattleMemberInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              BattleMemberInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a BattleMemberInfo message.
               * @function verify
               * @memberof Message.BattleMemberInfo
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              BattleMemberInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                if (message.identity != null && message.hasOwnProperty("identity")) switch (message.identity) {
                  default:
                    return "identity: enum value expected";

                  case 0:
                  case 1:
                  case 2:
                  case 3:
                    break;
                }
                if (message.battleScore != null && message.hasOwnProperty("battleScore")) if (!$util.isInteger(message.battleScore)) return "battleScore: integer expected";
                if (message.battleRank != null && message.hasOwnProperty("battleRank")) if (!$util.isInteger(message.battleRank)) return "battleRank: integer expected";
                if (message.expReceive != null && message.hasOwnProperty("expReceive")) if (!$util.isInteger(message.expReceive)) return "expReceive: integer expected";

                if (message.rewardInfos != null && message.hasOwnProperty("rewardInfos")) {
                  if (!Array.isArray(message.rewardInfos)) return "rewardInfos: array expected";

                  for (var i = 0; i < message.rewardInfos.length; ++i) {
                    var error = $root.Message.RewardInfo.verify(message.rewardInfos[i]);
                    if (error) return "rewardInfos." + error;
                  }
                }

                if (message.endReason != null && message.hasOwnProperty("endReason")) switch (message.endReason) {
                  default:
                    return "endReason: enum value expected";

                  case 0:
                  case 1:
                    break;
                }
                if (message.extInfo != null && message.hasOwnProperty("extInfo")) if (!$util.isString(message.extInfo)) return "extInfo: string expected";
                return null;
              };

              return BattleMemberInfo;
            }();

            Message.GameSnapshotResp = function () {
              /**
               * Properties of a GameSnapshotResp.
               * @memberof Message
               * @interface IGameSnapshotResp
               * @property {number|Long|null} [battleId] GameSnapshotResp battleId
               * @property {Array.<Message.IUserInfo>|null} [userInfos] GameSnapshotResp userInfos
               * @property {Array.<Message.IRewardInfo>|null} [rewardInfos] GameSnapshotResp rewardInfos
               * @property {number|null} [maxPeople] GameSnapshotResp maxPeople
               * @property {number|Long|null} [ownerUid] GameSnapshotResp ownerUid
               * @property {Message.PlayType|null} [roomTemplate] GameSnapshotResp roomTemplate
               */

              /**
               * Constructs a new GameSnapshotResp.
               * @memberof Message
               * @classdesc Represents a GameSnapshotResp.
               * @implements IGameSnapshotResp
               * @constructor
               * @param {Message.IGameSnapshotResp=} [properties] Properties to set
               */
              function GameSnapshotResp(properties) {
                this.userInfos = [];
                this.rewardInfos = [];
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * GameSnapshotResp battleId.
               * @member {number|Long} battleId
               * @memberof Message.GameSnapshotResp
               * @instance
               */


              GameSnapshotResp.prototype.battleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * GameSnapshotResp userInfos.
               * @member {Array.<Message.IUserInfo>} userInfos
               * @memberof Message.GameSnapshotResp
               * @instance
               */

              GameSnapshotResp.prototype.userInfos = $util.emptyArray;
              /**
               * GameSnapshotResp rewardInfos.
               * @member {Array.<Message.IRewardInfo>} rewardInfos
               * @memberof Message.GameSnapshotResp
               * @instance
               */

              GameSnapshotResp.prototype.rewardInfos = $util.emptyArray;
              /**
               * GameSnapshotResp maxPeople.
               * @member {number} maxPeople
               * @memberof Message.GameSnapshotResp
               * @instance
               */

              GameSnapshotResp.prototype.maxPeople = 0;
              /**
               * GameSnapshotResp ownerUid.
               * @member {number|Long} ownerUid
               * @memberof Message.GameSnapshotResp
               * @instance
               */

              GameSnapshotResp.prototype.ownerUid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * GameSnapshotResp roomTemplate.
               * @member {Message.PlayType} roomTemplate
               * @memberof Message.GameSnapshotResp
               * @instance
               */

              GameSnapshotResp.prototype.roomTemplate = 0;
              /**
               * Creates a new GameSnapshotResp instance using the specified properties.
               * @function create
               * @memberof Message.GameSnapshotResp
               * @static
               * @param {Message.IGameSnapshotResp=} [properties] Properties to set
               * @returns {Message.GameSnapshotResp} GameSnapshotResp instance
               */

              GameSnapshotResp.create = function create(properties) {
                return new GameSnapshotResp(properties);
              };
              /**
               * Encodes the specified GameSnapshotResp message. Does not implicitly {@link Message.GameSnapshotResp.verify|verify} messages.
               * @function encode
               * @memberof Message.GameSnapshotResp
               * @static
               * @param {Message.IGameSnapshotResp} message GameSnapshotResp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              GameSnapshotResp.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.battleId != null && message.hasOwnProperty("battleId")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.battleId);
                if (message.userInfos != null && message.userInfos.length) for (var i = 0; i < message.userInfos.length; ++i) {
                  $root.Message.UserInfo.encode(message.userInfos[i], writer.uint32(
                  /* id 3, wireType 2 =*/
                  26).fork()).ldelim();
                }
                if (message.rewardInfos != null && message.rewardInfos.length) for (var i = 0; i < message.rewardInfos.length; ++i) {
                  $root.Message.RewardInfo.encode(message.rewardInfos[i], writer.uint32(
                  /* id 4, wireType 2 =*/
                  34).fork()).ldelim();
                }
                if (message.maxPeople != null && message.hasOwnProperty("maxPeople")) writer.uint32(
                /* id 5, wireType 0 =*/
                40).int32(message.maxPeople);
                if (message.ownerUid != null && message.hasOwnProperty("ownerUid")) writer.uint32(
                /* id 6, wireType 0 =*/
                48).int64(message.ownerUid);
                if (message.roomTemplate != null && message.hasOwnProperty("roomTemplate")) writer.uint32(
                /* id 7, wireType 0 =*/
                56).int32(message.roomTemplate);
                return writer;
              };
              /**
               * Encodes the specified GameSnapshotResp message, length delimited. Does not implicitly {@link Message.GameSnapshotResp.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.GameSnapshotResp
               * @static
               * @param {Message.IGameSnapshotResp} message GameSnapshotResp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              GameSnapshotResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a GameSnapshotResp message from the specified reader or buffer.
               * @function decode
               * @memberof Message.GameSnapshotResp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.GameSnapshotResp} GameSnapshotResp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              GameSnapshotResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.GameSnapshotResp();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.battleId = reader.int64();
                      break;

                    case 3:
                      if (!(message.userInfos && message.userInfos.length)) message.userInfos = [];
                      message.userInfos.push($root.Message.UserInfo.decode(reader, reader.uint32()));
                      break;

                    case 4:
                      if (!(message.rewardInfos && message.rewardInfos.length)) message.rewardInfos = [];
                      message.rewardInfos.push($root.Message.RewardInfo.decode(reader, reader.uint32()));
                      break;

                    case 5:
                      message.maxPeople = reader.int32();
                      break;

                    case 6:
                      message.ownerUid = reader.int64();
                      break;

                    case 7:
                      message.roomTemplate = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a GameSnapshotResp message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.GameSnapshotResp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.GameSnapshotResp} GameSnapshotResp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              GameSnapshotResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a GameSnapshotResp message.
               * @function verify
               * @memberof Message.GameSnapshotResp
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              GameSnapshotResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.battleId != null && message.hasOwnProperty("battleId")) if (!$util.isInteger(message.battleId) && !(message.battleId && $util.isInteger(message.battleId.low) && $util.isInteger(message.battleId.high))) return "battleId: integer|Long expected";

                if (message.userInfos != null && message.hasOwnProperty("userInfos")) {
                  if (!Array.isArray(message.userInfos)) return "userInfos: array expected";

                  for (var i = 0; i < message.userInfos.length; ++i) {
                    var error = $root.Message.UserInfo.verify(message.userInfos[i]);
                    if (error) return "userInfos." + error;
                  }
                }

                if (message.rewardInfos != null && message.hasOwnProperty("rewardInfos")) {
                  if (!Array.isArray(message.rewardInfos)) return "rewardInfos: array expected";

                  for (var i = 0; i < message.rewardInfos.length; ++i) {
                    var error = $root.Message.RewardInfo.verify(message.rewardInfos[i]);
                    if (error) return "rewardInfos." + error;
                  }
                }

                if (message.maxPeople != null && message.hasOwnProperty("maxPeople")) if (!$util.isInteger(message.maxPeople)) return "maxPeople: integer expected";
                if (message.ownerUid != null && message.hasOwnProperty("ownerUid")) if (!$util.isInteger(message.ownerUid) && !(message.ownerUid && $util.isInteger(message.ownerUid.low) && $util.isInteger(message.ownerUid.high))) return "ownerUid: integer|Long expected";
                if (message.roomTemplate != null && message.hasOwnProperty("roomTemplate")) switch (message.roomTemplate) {
                  default:
                    return "roomTemplate: enum value expected";

                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 7:
                  case 8:
                  case 20:
                  case 10:
                  case 11:
                    break;
                }
                return null;
              };

              return GameSnapshotResp;
            }();

            Message.SeatStatusResp = function () {
              /**
               * Properties of a SeatStatusResp.
               * @memberof Message
               * @interface ISeatStatusResp
               * @property {string|null} [roomId] SeatStatusResp roomId
               * @property {number|Long|null} [battleId] SeatStatusResp battleId
               * @property {Message.IUserInfo|null} [userInfo] SeatStatusResp userInfo
               * @property {Message.ExceptionStatus|null} [status] SeatStatusResp status
               */

              /**
               * Constructs a new SeatStatusResp.
               * @memberof Message
               * @classdesc Represents a SeatStatusResp.
               * @implements ISeatStatusResp
               * @constructor
               * @param {Message.ISeatStatusResp=} [properties] Properties to set
               */
              function SeatStatusResp(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * SeatStatusResp roomId.
               * @member {string} roomId
               * @memberof Message.SeatStatusResp
               * @instance
               */


              SeatStatusResp.prototype.roomId = "";
              /**
               * SeatStatusResp battleId.
               * @member {number|Long} battleId
               * @memberof Message.SeatStatusResp
               * @instance
               */

              SeatStatusResp.prototype.battleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * SeatStatusResp userInfo.
               * @member {Message.IUserInfo|null|undefined} userInfo
               * @memberof Message.SeatStatusResp
               * @instance
               */

              SeatStatusResp.prototype.userInfo = null;
              /**
               * SeatStatusResp status.
               * @member {Message.ExceptionStatus} status
               * @memberof Message.SeatStatusResp
               * @instance
               */

              SeatStatusResp.prototype.status = 0;
              /**
               * Creates a new SeatStatusResp instance using the specified properties.
               * @function create
               * @memberof Message.SeatStatusResp
               * @static
               * @param {Message.ISeatStatusResp=} [properties] Properties to set
               * @returns {Message.SeatStatusResp} SeatStatusResp instance
               */

              SeatStatusResp.create = function create(properties) {
                return new SeatStatusResp(properties);
              };
              /**
               * Encodes the specified SeatStatusResp message. Does not implicitly {@link Message.SeatStatusResp.verify|verify} messages.
               * @function encode
               * @memberof Message.SeatStatusResp
               * @static
               * @param {Message.ISeatStatusResp} message SeatStatusResp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              SeatStatusResp.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.roomId != null && message.hasOwnProperty("roomId")) writer.uint32(
                /* id 1, wireType 2 =*/
                10).string(message.roomId);
                if (message.battleId != null && message.hasOwnProperty("battleId")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.battleId);
                if (message.userInfo != null && message.hasOwnProperty("userInfo")) $root.Message.UserInfo.encode(message.userInfo, writer.uint32(
                /* id 3, wireType 2 =*/
                26).fork()).ldelim();
                if (message.status != null && message.hasOwnProperty("status")) writer.uint32(
                /* id 4, wireType 0 =*/
                32).int32(message.status);
                return writer;
              };
              /**
               * Encodes the specified SeatStatusResp message, length delimited. Does not implicitly {@link Message.SeatStatusResp.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.SeatStatusResp
               * @static
               * @param {Message.ISeatStatusResp} message SeatStatusResp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              SeatStatusResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a SeatStatusResp message from the specified reader or buffer.
               * @function decode
               * @memberof Message.SeatStatusResp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.SeatStatusResp} SeatStatusResp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              SeatStatusResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.SeatStatusResp();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.roomId = reader.string();
                      break;

                    case 2:
                      message.battleId = reader.int64();
                      break;

                    case 3:
                      message.userInfo = $root.Message.UserInfo.decode(reader, reader.uint32());
                      break;

                    case 4:
                      message.status = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a SeatStatusResp message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.SeatStatusResp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.SeatStatusResp} SeatStatusResp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              SeatStatusResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a SeatStatusResp message.
               * @function verify
               * @memberof Message.SeatStatusResp
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              SeatStatusResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.roomId != null && message.hasOwnProperty("roomId")) if (!$util.isString(message.roomId)) return "roomId: string expected";
                if (message.battleId != null && message.hasOwnProperty("battleId")) if (!$util.isInteger(message.battleId) && !(message.battleId && $util.isInteger(message.battleId.low) && $util.isInteger(message.battleId.high))) return "battleId: integer|Long expected";

                if (message.userInfo != null && message.hasOwnProperty("userInfo")) {
                  var error = $root.Message.UserInfo.verify(message.userInfo);
                  if (error) return "userInfo." + error;
                }

                if (message.status != null && message.hasOwnProperty("status")) switch (message.status) {
                  default:
                    return "status: enum value expected";

                  case 0:
                  case 1:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                    break;
                }
                return null;
              };

              return SeatStatusResp;
            }();

            Message.GameStatusResp = function () {
              /**
               * Properties of a GameStatusResp.
               * @memberof Message
               * @interface IGameStatusResp
               * @property {number|Long|null} [battleId] GameStatusResp battleId
               * @property {Message.GameStatus|null} [status] GameStatusResp status
               * @property {boolean|null} [success] GameStatusResp success
               * @property {string|null} [msg] GameStatusResp msg
               */

              /**
               * Constructs a new GameStatusResp.
               * @memberof Message
               * @classdesc Represents a GameStatusResp.
               * @implements IGameStatusResp
               * @constructor
               * @param {Message.IGameStatusResp=} [properties] Properties to set
               */
              function GameStatusResp(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * GameStatusResp battleId.
               * @member {number|Long} battleId
               * @memberof Message.GameStatusResp
               * @instance
               */


              GameStatusResp.prototype.battleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * GameStatusResp status.
               * @member {Message.GameStatus} status
               * @memberof Message.GameStatusResp
               * @instance
               */

              GameStatusResp.prototype.status = 0;
              /**
               * GameStatusResp success.
               * @member {boolean} success
               * @memberof Message.GameStatusResp
               * @instance
               */

              GameStatusResp.prototype.success = false;
              /**
               * GameStatusResp msg.
               * @member {string} msg
               * @memberof Message.GameStatusResp
               * @instance
               */

              GameStatusResp.prototype.msg = "";
              /**
               * Creates a new GameStatusResp instance using the specified properties.
               * @function create
               * @memberof Message.GameStatusResp
               * @static
               * @param {Message.IGameStatusResp=} [properties] Properties to set
               * @returns {Message.GameStatusResp} GameStatusResp instance
               */

              GameStatusResp.create = function create(properties) {
                return new GameStatusResp(properties);
              };
              /**
               * Encodes the specified GameStatusResp message. Does not implicitly {@link Message.GameStatusResp.verify|verify} messages.
               * @function encode
               * @memberof Message.GameStatusResp
               * @static
               * @param {Message.IGameStatusResp} message GameStatusResp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              GameStatusResp.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.battleId != null && message.hasOwnProperty("battleId")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.battleId);
                if (message.status != null && message.hasOwnProperty("status")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int32(message.status);
                if (message.success != null && message.hasOwnProperty("success")) writer.uint32(
                /* id 3, wireType 0 =*/
                24).bool(message.success);
                if (message.msg != null && message.hasOwnProperty("msg")) writer.uint32(
                /* id 4, wireType 2 =*/
                34).string(message.msg);
                return writer;
              };
              /**
               * Encodes the specified GameStatusResp message, length delimited. Does not implicitly {@link Message.GameStatusResp.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.GameStatusResp
               * @static
               * @param {Message.IGameStatusResp} message GameStatusResp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              GameStatusResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a GameStatusResp message from the specified reader or buffer.
               * @function decode
               * @memberof Message.GameStatusResp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.GameStatusResp} GameStatusResp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              GameStatusResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.GameStatusResp();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.battleId = reader.int64();
                      break;

                    case 2:
                      message.status = reader.int32();
                      break;

                    case 3:
                      message.success = reader.bool();
                      break;

                    case 4:
                      message.msg = reader.string();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a GameStatusResp message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.GameStatusResp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.GameStatusResp} GameStatusResp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              GameStatusResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a GameStatusResp message.
               * @function verify
               * @memberof Message.GameStatusResp
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              GameStatusResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.battleId != null && message.hasOwnProperty("battleId")) if (!$util.isInteger(message.battleId) && !(message.battleId && $util.isInteger(message.battleId.low) && $util.isInteger(message.battleId.high))) return "battleId: integer|Long expected";
                if (message.status != null && message.hasOwnProperty("status")) switch (message.status) {
                  default:
                    return "status: enum value expected";

                  case 0:
                  case 1:
                  case 2:
                    break;
                }
                if (message.success != null && message.hasOwnProperty("success")) if (typeof message.success !== "boolean") return "success: boolean expected";
                if (message.msg != null && message.hasOwnProperty("msg")) if (!$util.isString(message.msg)) return "msg: string expected";
                return null;
              };

              return GameStatusResp;
            }();

            Message.RewardConfig = function () {
              /**
               * Properties of a RewardConfig.
               * @memberof Message
               * @interface IRewardConfig
               * @property {string|null} [roomId] RewardConfig roomId
               * @property {Array.<Message.IRewardInfo>|null} [rewardInfos] RewardConfig rewardInfos
               */

              /**
               * Constructs a new RewardConfig.
               * @memberof Message
               * @classdesc Represents a RewardConfig.
               * @implements IRewardConfig
               * @constructor
               * @param {Message.IRewardConfig=} [properties] Properties to set
               */
              function RewardConfig(properties) {
                this.rewardInfos = [];
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * RewardConfig roomId.
               * @member {string} roomId
               * @memberof Message.RewardConfig
               * @instance
               */


              RewardConfig.prototype.roomId = "";
              /**
               * RewardConfig rewardInfos.
               * @member {Array.<Message.IRewardInfo>} rewardInfos
               * @memberof Message.RewardConfig
               * @instance
               */

              RewardConfig.prototype.rewardInfos = $util.emptyArray;
              /**
               * Creates a new RewardConfig instance using the specified properties.
               * @function create
               * @memberof Message.RewardConfig
               * @static
               * @param {Message.IRewardConfig=} [properties] Properties to set
               * @returns {Message.RewardConfig} RewardConfig instance
               */

              RewardConfig.create = function create(properties) {
                return new RewardConfig(properties);
              };
              /**
               * Encodes the specified RewardConfig message. Does not implicitly {@link Message.RewardConfig.verify|verify} messages.
               * @function encode
               * @memberof Message.RewardConfig
               * @static
               * @param {Message.IRewardConfig} message RewardConfig message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              RewardConfig.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.roomId != null && message.hasOwnProperty("roomId")) writer.uint32(
                /* id 1, wireType 2 =*/
                10).string(message.roomId);
                if (message.rewardInfos != null && message.rewardInfos.length) for (var i = 0; i < message.rewardInfos.length; ++i) {
                  $root.Message.RewardInfo.encode(message.rewardInfos[i], writer.uint32(
                  /* id 2, wireType 2 =*/
                  18).fork()).ldelim();
                }
                return writer;
              };
              /**
               * Encodes the specified RewardConfig message, length delimited. Does not implicitly {@link Message.RewardConfig.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.RewardConfig
               * @static
               * @param {Message.IRewardConfig} message RewardConfig message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              RewardConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a RewardConfig message from the specified reader or buffer.
               * @function decode
               * @memberof Message.RewardConfig
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.RewardConfig} RewardConfig
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              RewardConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.RewardConfig();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.roomId = reader.string();
                      break;

                    case 2:
                      if (!(message.rewardInfos && message.rewardInfos.length)) message.rewardInfos = [];
                      message.rewardInfos.push($root.Message.RewardInfo.decode(reader, reader.uint32()));
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a RewardConfig message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.RewardConfig
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.RewardConfig} RewardConfig
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              RewardConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a RewardConfig message.
               * @function verify
               * @memberof Message.RewardConfig
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              RewardConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.roomId != null && message.hasOwnProperty("roomId")) if (!$util.isString(message.roomId)) return "roomId: string expected";

                if (message.rewardInfos != null && message.hasOwnProperty("rewardInfos")) {
                  if (!Array.isArray(message.rewardInfos)) return "rewardInfos: array expected";

                  for (var i = 0; i < message.rewardInfos.length; ++i) {
                    var error = $root.Message.RewardInfo.verify(message.rewardInfos[i]);
                    if (error) return "rewardInfos." + error;
                  }
                }

                return null;
              };

              return RewardConfig;
            }();

            Message.SpeakNotify = function () {
              /**
               * Properties of a SpeakNotify.
               * @memberof Message
               * @interface ISpeakNotify
               * @property {number|Long|null} [uid] SpeakNotify uid
               * @property {string|null} [content] SpeakNotify content
               * @property {number|Long|null} [battleId] SpeakNotify battleId
               */

              /**
               * Constructs a new SpeakNotify.
               * @memberof Message
               * @classdesc Represents a SpeakNotify.
               * @implements ISpeakNotify
               * @constructor
               * @param {Message.ISpeakNotify=} [properties] Properties to set
               */
              function SpeakNotify(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * SpeakNotify uid.
               * @member {number|Long} uid
               * @memberof Message.SpeakNotify
               * @instance
               */


              SpeakNotify.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * SpeakNotify content.
               * @member {string} content
               * @memberof Message.SpeakNotify
               * @instance
               */

              SpeakNotify.prototype.content = "";
              /**
               * SpeakNotify battleId.
               * @member {number|Long} battleId
               * @memberof Message.SpeakNotify
               * @instance
               */

              SpeakNotify.prototype.battleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * Creates a new SpeakNotify instance using the specified properties.
               * @function create
               * @memberof Message.SpeakNotify
               * @static
               * @param {Message.ISpeakNotify=} [properties] Properties to set
               * @returns {Message.SpeakNotify} SpeakNotify instance
               */

              SpeakNotify.create = function create(properties) {
                return new SpeakNotify(properties);
              };
              /**
               * Encodes the specified SpeakNotify message. Does not implicitly {@link Message.SpeakNotify.verify|verify} messages.
               * @function encode
               * @memberof Message.SpeakNotify
               * @static
               * @param {Message.ISpeakNotify} message SpeakNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              SpeakNotify.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.uid);
                if (message.content != null && message.hasOwnProperty("content")) writer.uint32(
                /* id 2, wireType 2 =*/
                18).string(message.content);
                if (message.battleId != null && message.hasOwnProperty("battleId")) writer.uint32(
                /* id 3, wireType 0 =*/
                24).int64(message.battleId);
                return writer;
              };
              /**
               * Encodes the specified SpeakNotify message, length delimited. Does not implicitly {@link Message.SpeakNotify.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.SpeakNotify
               * @static
               * @param {Message.ISpeakNotify} message SpeakNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              SpeakNotify.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a SpeakNotify message from the specified reader or buffer.
               * @function decode
               * @memberof Message.SpeakNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.SpeakNotify} SpeakNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              SpeakNotify.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.SpeakNotify();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.uid = reader.int64();
                      break;

                    case 2:
                      message.content = reader.string();
                      break;

                    case 3:
                      message.battleId = reader.int64();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a SpeakNotify message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.SpeakNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.SpeakNotify} SpeakNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              SpeakNotify.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a SpeakNotify message.
               * @function verify
               * @memberof Message.SpeakNotify
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              SpeakNotify.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                if (message.content != null && message.hasOwnProperty("content")) if (!$util.isString(message.content)) return "content: string expected";
                if (message.battleId != null && message.hasOwnProperty("battleId")) if (!$util.isInteger(message.battleId) && !(message.battleId && $util.isInteger(message.battleId.low) && $util.isInteger(message.battleId.high))) return "battleId: integer|Long expected";
                return null;
              };

              return SpeakNotify;
            }();

            Message.SpectatorEnterRoom = function () {
              /**
               * Properties of a SpectatorEnterRoom.
               * @memberof Message
               * @interface ISpectatorEnterRoom
               * @property {number|Long|null} [uid] SpectatorEnterRoom uid
               * @property {number|Long|null} [battleId] SpectatorEnterRoom battleId
               */

              /**
               * Constructs a new SpectatorEnterRoom.
               * @memberof Message
               * @classdesc Represents a SpectatorEnterRoom.
               * @implements ISpectatorEnterRoom
               * @constructor
               * @param {Message.ISpectatorEnterRoom=} [properties] Properties to set
               */
              function SpectatorEnterRoom(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * SpectatorEnterRoom uid.
               * @member {number|Long} uid
               * @memberof Message.SpectatorEnterRoom
               * @instance
               */


              SpectatorEnterRoom.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * SpectatorEnterRoom battleId.
               * @member {number|Long} battleId
               * @memberof Message.SpectatorEnterRoom
               * @instance
               */

              SpectatorEnterRoom.prototype.battleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * Creates a new SpectatorEnterRoom instance using the specified properties.
               * @function create
               * @memberof Message.SpectatorEnterRoom
               * @static
               * @param {Message.ISpectatorEnterRoom=} [properties] Properties to set
               * @returns {Message.SpectatorEnterRoom} SpectatorEnterRoom instance
               */

              SpectatorEnterRoom.create = function create(properties) {
                return new SpectatorEnterRoom(properties);
              };
              /**
               * Encodes the specified SpectatorEnterRoom message. Does not implicitly {@link Message.SpectatorEnterRoom.verify|verify} messages.
               * @function encode
               * @memberof Message.SpectatorEnterRoom
               * @static
               * @param {Message.ISpectatorEnterRoom} message SpectatorEnterRoom message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              SpectatorEnterRoom.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.uid);
                if (message.battleId != null && message.hasOwnProperty("battleId")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.battleId);
                return writer;
              };
              /**
               * Encodes the specified SpectatorEnterRoom message, length delimited. Does not implicitly {@link Message.SpectatorEnterRoom.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.SpectatorEnterRoom
               * @static
               * @param {Message.ISpectatorEnterRoom} message SpectatorEnterRoom message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              SpectatorEnterRoom.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a SpectatorEnterRoom message from the specified reader or buffer.
               * @function decode
               * @memberof Message.SpectatorEnterRoom
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.SpectatorEnterRoom} SpectatorEnterRoom
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              SpectatorEnterRoom.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.SpectatorEnterRoom();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.uid = reader.int64();
                      break;

                    case 2:
                      message.battleId = reader.int64();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a SpectatorEnterRoom message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.SpectatorEnterRoom
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.SpectatorEnterRoom} SpectatorEnterRoom
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              SpectatorEnterRoom.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a SpectatorEnterRoom message.
               * @function verify
               * @memberof Message.SpectatorEnterRoom
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              SpectatorEnterRoom.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                if (message.battleId != null && message.hasOwnProperty("battleId")) if (!$util.isInteger(message.battleId) && !(message.battleId && $util.isInteger(message.battleId.low) && $util.isInteger(message.battleId.high))) return "battleId: integer|Long expected";
                return null;
              };

              return SpectatorEnterRoom;
            }();

            Message.MsgToast = function () {
              /**
               * Properties of a MsgToast.
               * @memberof Message
               * @interface IMsgToast
               * @property {string|null} [msg] MsgToast msg
               */

              /**
               * Constructs a new MsgToast.
               * @memberof Message
               * @classdesc Represents a MsgToast.
               * @implements IMsgToast
               * @constructor
               * @param {Message.IMsgToast=} [properties] Properties to set
               */
              function MsgToast(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * MsgToast msg.
               * @member {string} msg
               * @memberof Message.MsgToast
               * @instance
               */


              MsgToast.prototype.msg = "";
              /**
               * Creates a new MsgToast instance using the specified properties.
               * @function create
               * @memberof Message.MsgToast
               * @static
               * @param {Message.IMsgToast=} [properties] Properties to set
               * @returns {Message.MsgToast} MsgToast instance
               */

              MsgToast.create = function create(properties) {
                return new MsgToast(properties);
              };
              /**
               * Encodes the specified MsgToast message. Does not implicitly {@link Message.MsgToast.verify|verify} messages.
               * @function encode
               * @memberof Message.MsgToast
               * @static
               * @param {Message.IMsgToast} message MsgToast message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              MsgToast.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.msg != null && message.hasOwnProperty("msg")) writer.uint32(
                /* id 1, wireType 2 =*/
                10).string(message.msg);
                return writer;
              };
              /**
               * Encodes the specified MsgToast message, length delimited. Does not implicitly {@link Message.MsgToast.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.MsgToast
               * @static
               * @param {Message.IMsgToast} message MsgToast message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              MsgToast.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a MsgToast message from the specified reader or buffer.
               * @function decode
               * @memberof Message.MsgToast
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.MsgToast} MsgToast
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              MsgToast.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.MsgToast();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.msg = reader.string();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a MsgToast message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.MsgToast
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.MsgToast} MsgToast
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              MsgToast.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a MsgToast message.
               * @function verify
               * @memberof Message.MsgToast
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              MsgToast.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.msg != null && message.hasOwnProperty("msg")) if (!$util.isString(message.msg)) return "msg: string expected";
                return null;
              };

              return MsgToast;
            }();

            Message.ExceptionNotify = function () {
              /**
               * Properties of an ExceptionNotify.
               * @memberof Message
               * @interface IExceptionNotify
               * @property {string|null} [notify] ExceptionNotify notify
               */

              /**
               * Constructs a new ExceptionNotify.
               * @memberof Message
               * @classdesc Represents an ExceptionNotify.
               * @implements IExceptionNotify
               * @constructor
               * @param {Message.IExceptionNotify=} [properties] Properties to set
               */
              function ExceptionNotify(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * ExceptionNotify notify.
               * @member {string} notify
               * @memberof Message.ExceptionNotify
               * @instance
               */


              ExceptionNotify.prototype.notify = "";
              /**
               * Creates a new ExceptionNotify instance using the specified properties.
               * @function create
               * @memberof Message.ExceptionNotify
               * @static
               * @param {Message.IExceptionNotify=} [properties] Properties to set
               * @returns {Message.ExceptionNotify} ExceptionNotify instance
               */

              ExceptionNotify.create = function create(properties) {
                return new ExceptionNotify(properties);
              };
              /**
               * Encodes the specified ExceptionNotify message. Does not implicitly {@link Message.ExceptionNotify.verify|verify} messages.
               * @function encode
               * @memberof Message.ExceptionNotify
               * @static
               * @param {Message.IExceptionNotify} message ExceptionNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              ExceptionNotify.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.notify != null && message.hasOwnProperty("notify")) writer.uint32(
                /* id 1, wireType 2 =*/
                10).string(message.notify);
                return writer;
              };
              /**
               * Encodes the specified ExceptionNotify message, length delimited. Does not implicitly {@link Message.ExceptionNotify.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.ExceptionNotify
               * @static
               * @param {Message.IExceptionNotify} message ExceptionNotify message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              ExceptionNotify.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes an ExceptionNotify message from the specified reader or buffer.
               * @function decode
               * @memberof Message.ExceptionNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.ExceptionNotify} ExceptionNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              ExceptionNotify.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.ExceptionNotify();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.notify = reader.string();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes an ExceptionNotify message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.ExceptionNotify
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.ExceptionNotify} ExceptionNotify
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              ExceptionNotify.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies an ExceptionNotify message.
               * @function verify
               * @memberof Message.ExceptionNotify
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              ExceptionNotify.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.notify != null && message.hasOwnProperty("notify")) if (!$util.isString(message.notify)) return "notify: string expected";
                return null;
              };

              return ExceptionNotify;
            }();

            Message.BattleLexiconResp = function () {
              /**
               * Properties of a BattleLexiconResp.
               * @memberof Message
               * @interface IBattleLexiconResp
               * @property {boolean|null} [end] BattleLexiconResp end
               * @property {Array.<Message.IBattleLexicon>|null} [battleLexicons] BattleLexiconResp battleLexicons
               */

              /**
               * Constructs a new BattleLexiconResp.
               * @memberof Message
               * @classdesc Represents a BattleLexiconResp.
               * @implements IBattleLexiconResp
               * @constructor
               * @param {Message.IBattleLexiconResp=} [properties] Properties to set
               */
              function BattleLexiconResp(properties) {
                this.battleLexicons = [];
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * BattleLexiconResp end.
               * @member {boolean} end
               * @memberof Message.BattleLexiconResp
               * @instance
               */


              BattleLexiconResp.prototype.end = false;
              /**
               * BattleLexiconResp battleLexicons.
               * @member {Array.<Message.IBattleLexicon>} battleLexicons
               * @memberof Message.BattleLexiconResp
               * @instance
               */

              BattleLexiconResp.prototype.battleLexicons = $util.emptyArray;
              /**
               * Creates a new BattleLexiconResp instance using the specified properties.
               * @function create
               * @memberof Message.BattleLexiconResp
               * @static
               * @param {Message.IBattleLexiconResp=} [properties] Properties to set
               * @returns {Message.BattleLexiconResp} BattleLexiconResp instance
               */

              BattleLexiconResp.create = function create(properties) {
                return new BattleLexiconResp(properties);
              };
              /**
               * Encodes the specified BattleLexiconResp message. Does not implicitly {@link Message.BattleLexiconResp.verify|verify} messages.
               * @function encode
               * @memberof Message.BattleLexiconResp
               * @static
               * @param {Message.IBattleLexiconResp} message BattleLexiconResp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              BattleLexiconResp.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.end != null && message.hasOwnProperty("end")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).bool(message.end);
                if (message.battleLexicons != null && message.battleLexicons.length) for (var i = 0; i < message.battleLexicons.length; ++i) {
                  $root.Message.BattleLexicon.encode(message.battleLexicons[i], writer.uint32(
                  /* id 2, wireType 2 =*/
                  18).fork()).ldelim();
                }
                return writer;
              };
              /**
               * Encodes the specified BattleLexiconResp message, length delimited. Does not implicitly {@link Message.BattleLexiconResp.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.BattleLexiconResp
               * @static
               * @param {Message.IBattleLexiconResp} message BattleLexiconResp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              BattleLexiconResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a BattleLexiconResp message from the specified reader or buffer.
               * @function decode
               * @memberof Message.BattleLexiconResp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.BattleLexiconResp} BattleLexiconResp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              BattleLexiconResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.BattleLexiconResp();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.end = reader.bool();
                      break;

                    case 2:
                      if (!(message.battleLexicons && message.battleLexicons.length)) message.battleLexicons = [];
                      message.battleLexicons.push($root.Message.BattleLexicon.decode(reader, reader.uint32()));
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a BattleLexiconResp message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.BattleLexiconResp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.BattleLexiconResp} BattleLexiconResp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              BattleLexiconResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a BattleLexiconResp message.
               * @function verify
               * @memberof Message.BattleLexiconResp
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              BattleLexiconResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.end != null && message.hasOwnProperty("end")) if (typeof message.end !== "boolean") return "end: boolean expected";

                if (message.battleLexicons != null && message.hasOwnProperty("battleLexicons")) {
                  if (!Array.isArray(message.battleLexicons)) return "battleLexicons: array expected";

                  for (var i = 0; i < message.battleLexicons.length; ++i) {
                    var error = $root.Message.BattleLexicon.verify(message.battleLexicons[i]);
                    if (error) return "battleLexicons." + error;
                  }
                }

                return null;
              };

              return BattleLexiconResp;
            }();

            Message.BattleLexicon = function () {
              /**
               * Properties of a BattleLexicon.
               * @memberof Message
               * @interface IBattleLexicon
               * @property {string|null} [category] BattleLexicon category
               * @property {string|null} [content] BattleLexicon content
               * @property {number|Long|null} [id] BattleLexicon id
               */

              /**
               * Constructs a new BattleLexicon.
               * @memberof Message
               * @classdesc Represents a BattleLexicon.
               * @implements IBattleLexicon
               * @constructor
               * @param {Message.IBattleLexicon=} [properties] Properties to set
               */
              function BattleLexicon(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * BattleLexicon category.
               * @member {string} category
               * @memberof Message.BattleLexicon
               * @instance
               */


              BattleLexicon.prototype.category = "";
              /**
               * BattleLexicon content.
               * @member {string} content
               * @memberof Message.BattleLexicon
               * @instance
               */

              BattleLexicon.prototype.content = "";
              /**
               * BattleLexicon id.
               * @member {number|Long} id
               * @memberof Message.BattleLexicon
               * @instance
               */

              BattleLexicon.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * Creates a new BattleLexicon instance using the specified properties.
               * @function create
               * @memberof Message.BattleLexicon
               * @static
               * @param {Message.IBattleLexicon=} [properties] Properties to set
               * @returns {Message.BattleLexicon} BattleLexicon instance
               */

              BattleLexicon.create = function create(properties) {
                return new BattleLexicon(properties);
              };
              /**
               * Encodes the specified BattleLexicon message. Does not implicitly {@link Message.BattleLexicon.verify|verify} messages.
               * @function encode
               * @memberof Message.BattleLexicon
               * @static
               * @param {Message.IBattleLexicon} message BattleLexicon message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              BattleLexicon.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.category != null && message.hasOwnProperty("category")) writer.uint32(
                /* id 1, wireType 2 =*/
                10).string(message.category);
                if (message.content != null && message.hasOwnProperty("content")) writer.uint32(
                /* id 2, wireType 2 =*/
                18).string(message.content);
                if (message.id != null && message.hasOwnProperty("id")) writer.uint32(
                /* id 3, wireType 0 =*/
                24).int64(message.id);
                return writer;
              };
              /**
               * Encodes the specified BattleLexicon message, length delimited. Does not implicitly {@link Message.BattleLexicon.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.BattleLexicon
               * @static
               * @param {Message.IBattleLexicon} message BattleLexicon message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              BattleLexicon.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a BattleLexicon message from the specified reader or buffer.
               * @function decode
               * @memberof Message.BattleLexicon
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.BattleLexicon} BattleLexicon
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              BattleLexicon.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.BattleLexicon();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.category = reader.string();
                      break;

                    case 2:
                      message.content = reader.string();
                      break;

                    case 3:
                      message.id = reader.int64();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a BattleLexicon message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.BattleLexicon
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.BattleLexicon} BattleLexicon
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              BattleLexicon.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a BattleLexicon message.
               * @function verify
               * @memberof Message.BattleLexicon
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              BattleLexicon.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.category != null && message.hasOwnProperty("category")) if (!$util.isString(message.category)) return "category: string expected";
                if (message.content != null && message.hasOwnProperty("content")) if (!$util.isString(message.content)) return "content: string expected";
                if (message.id != null && message.hasOwnProperty("id")) if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) return "id: integer|Long expected";
                return null;
              };

              return BattleLexicon;
            }();

            Message.UserInfo = function () {
              /**
               * Properties of a UserInfo.
               * @memberof Message
               * @interface IUserInfo
               * @property {number|Long|null} [uid] UserInfo uid
               * @property {string|null} [avatar] UserInfo avatar
               * @property {string|null} [nickname] UserInfo nickname
               * @property {string|null} [seatIndex] UserInfo seatIndex
               * @property {Message.Identity|null} [identity] UserInfo identity
               * @property {string|null} [ext] UserInfo ext
               * @property {Message.UserOnLineStatus|null} [status] UserInfo status
               * @property {boolean|null} [mute] UserInfo mute
               * @property {number|Long|null} [hostUid] UserInfo hostUid
               * @property {string|null} [roleName] UserInfo roleName
               * @property {string|null} [roleIcon] UserInfo roleIcon
               */

              /**
               * Constructs a new UserInfo.
               * @memberof Message
               * @classdesc Represents a UserInfo.
               * @implements IUserInfo
               * @constructor
               * @param {Message.IUserInfo=} [properties] Properties to set
               */
              function UserInfo(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * UserInfo uid.
               * @member {number|Long} uid
               * @memberof Message.UserInfo
               * @instance
               */


              UserInfo.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * UserInfo avatar.
               * @member {string} avatar
               * @memberof Message.UserInfo
               * @instance
               */

              UserInfo.prototype.avatar = "";
              /**
               * UserInfo nickname.
               * @member {string} nickname
               * @memberof Message.UserInfo
               * @instance
               */

              UserInfo.prototype.nickname = "";
              /**
               * UserInfo seatIndex.
               * @member {string} seatIndex
               * @memberof Message.UserInfo
               * @instance
               */

              UserInfo.prototype.seatIndex = "";
              /**
               * UserInfo identity.
               * @member {Message.Identity} identity
               * @memberof Message.UserInfo
               * @instance
               */

              UserInfo.prototype.identity = 0;
              /**
               * UserInfo ext.
               * @member {string} ext
               * @memberof Message.UserInfo
               * @instance
               */

              UserInfo.prototype.ext = "";
              /**
               * UserInfo status.
               * @member {Message.UserOnLineStatus} status
               * @memberof Message.UserInfo
               * @instance
               */

              UserInfo.prototype.status = 0;
              /**
               * UserInfo mute.
               * @member {boolean} mute
               * @memberof Message.UserInfo
               * @instance
               */

              UserInfo.prototype.mute = false;
              /**
               * UserInfo hostUid.
               * @member {number|Long} hostUid
               * @memberof Message.UserInfo
               * @instance
               */

              UserInfo.prototype.hostUid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * UserInfo roleName.
               * @member {string} roleName
               * @memberof Message.UserInfo
               * @instance
               */

              UserInfo.prototype.roleName = "";
              /**
               * UserInfo roleIcon.
               * @member {string} roleIcon
               * @memberof Message.UserInfo
               * @instance
               */

              UserInfo.prototype.roleIcon = "";
              /**
               * Creates a new UserInfo instance using the specified properties.
               * @function create
               * @memberof Message.UserInfo
               * @static
               * @param {Message.IUserInfo=} [properties] Properties to set
               * @returns {Message.UserInfo} UserInfo instance
               */

              UserInfo.create = function create(properties) {
                return new UserInfo(properties);
              };
              /**
               * Encodes the specified UserInfo message. Does not implicitly {@link Message.UserInfo.verify|verify} messages.
               * @function encode
               * @memberof Message.UserInfo
               * @static
               * @param {Message.IUserInfo} message UserInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              UserInfo.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.uid);
                if (message.avatar != null && message.hasOwnProperty("avatar")) writer.uint32(
                /* id 2, wireType 2 =*/
                18).string(message.avatar);
                if (message.nickname != null && message.hasOwnProperty("nickname")) writer.uint32(
                /* id 3, wireType 2 =*/
                26).string(message.nickname);
                if (message.seatIndex != null && message.hasOwnProperty("seatIndex")) writer.uint32(
                /* id 4, wireType 2 =*/
                34).string(message.seatIndex);
                if (message.identity != null && message.hasOwnProperty("identity")) writer.uint32(
                /* id 5, wireType 0 =*/
                40).int32(message.identity);
                if (message.ext != null && message.hasOwnProperty("ext")) writer.uint32(
                /* id 7, wireType 2 =*/
                58).string(message.ext);
                if (message.status != null && message.hasOwnProperty("status")) writer.uint32(
                /* id 8, wireType 0 =*/
                64).int32(message.status);
                if (message.mute != null && message.hasOwnProperty("mute")) writer.uint32(
                /* id 9, wireType 0 =*/
                72).bool(message.mute);
                if (message.hostUid != null && message.hasOwnProperty("hostUid")) writer.uint32(
                /* id 10, wireType 0 =*/
                80).int64(message.hostUid);
                if (message.roleName != null && message.hasOwnProperty("roleName")) writer.uint32(
                /* id 11, wireType 2 =*/
                90).string(message.roleName);
                if (message.roleIcon != null && message.hasOwnProperty("roleIcon")) writer.uint32(
                /* id 12, wireType 2 =*/
                98).string(message.roleIcon);
                return writer;
              };
              /**
               * Encodes the specified UserInfo message, length delimited. Does not implicitly {@link Message.UserInfo.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.UserInfo
               * @static
               * @param {Message.IUserInfo} message UserInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              UserInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a UserInfo message from the specified reader or buffer.
               * @function decode
               * @memberof Message.UserInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.UserInfo} UserInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              UserInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.UserInfo();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.uid = reader.int64();
                      break;

                    case 2:
                      message.avatar = reader.string();
                      break;

                    case 3:
                      message.nickname = reader.string();
                      break;

                    case 4:
                      message.seatIndex = reader.string();
                      break;

                    case 5:
                      message.identity = reader.int32();
                      break;

                    case 7:
                      message.ext = reader.string();
                      break;

                    case 8:
                      message.status = reader.int32();
                      break;

                    case 9:
                      message.mute = reader.bool();
                      break;

                    case 10:
                      message.hostUid = reader.int64();
                      break;

                    case 11:
                      message.roleName = reader.string();
                      break;

                    case 12:
                      message.roleIcon = reader.string();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a UserInfo message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.UserInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.UserInfo} UserInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              UserInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a UserInfo message.
               * @function verify
               * @memberof Message.UserInfo
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              UserInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                if (message.avatar != null && message.hasOwnProperty("avatar")) if (!$util.isString(message.avatar)) return "avatar: string expected";
                if (message.nickname != null && message.hasOwnProperty("nickname")) if (!$util.isString(message.nickname)) return "nickname: string expected";
                if (message.seatIndex != null && message.hasOwnProperty("seatIndex")) if (!$util.isString(message.seatIndex)) return "seatIndex: string expected";
                if (message.identity != null && message.hasOwnProperty("identity")) switch (message.identity) {
                  default:
                    return "identity: enum value expected";

                  case 0:
                  case 1:
                  case 2:
                  case 3:
                    break;
                }
                if (message.ext != null && message.hasOwnProperty("ext")) if (!$util.isString(message.ext)) return "ext: string expected";
                if (message.status != null && message.hasOwnProperty("status")) switch (message.status) {
                  default:
                    return "status: enum value expected";

                  case 0:
                  case 1:
                    break;
                }
                if (message.mute != null && message.hasOwnProperty("mute")) if (typeof message.mute !== "boolean") return "mute: boolean expected";
                if (message.hostUid != null && message.hasOwnProperty("hostUid")) if (!$util.isInteger(message.hostUid) && !(message.hostUid && $util.isInteger(message.hostUid.low) && $util.isInteger(message.hostUid.high))) return "hostUid: integer|Long expected";
                if (message.roleName != null && message.hasOwnProperty("roleName")) if (!$util.isString(message.roleName)) return "roleName: string expected";
                if (message.roleIcon != null && message.hasOwnProperty("roleIcon")) if (!$util.isString(message.roleIcon)) return "roleIcon: string expected";
                return null;
              };

              return UserInfo;
            }();

            Message.RewardInfo = function () {
              /**
               * Properties of a RewardInfo.
               * @memberof Message
               * @interface IRewardInfo
               * @property {number|Long|null} [giftId] RewardInfo giftId
               * @property {string|null} [title] RewardInfo title
               * @property {string|null} [img] RewardInfo img
               * @property {number|null} [num] RewardInfo num
               * @property {number|null} [price] RewardInfo price
               * @property {Message.RewardType|null} [rewardType] RewardInfo rewardType
               */

              /**
               * Constructs a new RewardInfo.
               * @memberof Message
               * @classdesc Represents a RewardInfo.
               * @implements IRewardInfo
               * @constructor
               * @param {Message.IRewardInfo=} [properties] Properties to set
               */
              function RewardInfo(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * RewardInfo giftId.
               * @member {number|Long} giftId
               * @memberof Message.RewardInfo
               * @instance
               */


              RewardInfo.prototype.giftId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * RewardInfo title.
               * @member {string} title
               * @memberof Message.RewardInfo
               * @instance
               */

              RewardInfo.prototype.title = "";
              /**
               * RewardInfo img.
               * @member {string} img
               * @memberof Message.RewardInfo
               * @instance
               */

              RewardInfo.prototype.img = "";
              /**
               * RewardInfo num.
               * @member {number} num
               * @memberof Message.RewardInfo
               * @instance
               */

              RewardInfo.prototype.num = 0;
              /**
               * RewardInfo price.
               * @member {number} price
               * @memberof Message.RewardInfo
               * @instance
               */

              RewardInfo.prototype.price = 0;
              /**
               * RewardInfo rewardType.
               * @member {Message.RewardType} rewardType
               * @memberof Message.RewardInfo
               * @instance
               */

              RewardInfo.prototype.rewardType = 0;
              /**
               * Creates a new RewardInfo instance using the specified properties.
               * @function create
               * @memberof Message.RewardInfo
               * @static
               * @param {Message.IRewardInfo=} [properties] Properties to set
               * @returns {Message.RewardInfo} RewardInfo instance
               */

              RewardInfo.create = function create(properties) {
                return new RewardInfo(properties);
              };
              /**
               * Encodes the specified RewardInfo message. Does not implicitly {@link Message.RewardInfo.verify|verify} messages.
               * @function encode
               * @memberof Message.RewardInfo
               * @static
               * @param {Message.IRewardInfo} message RewardInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              RewardInfo.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.giftId != null && message.hasOwnProperty("giftId")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.giftId);
                if (message.title != null && message.hasOwnProperty("title")) writer.uint32(
                /* id 2, wireType 2 =*/
                18).string(message.title);
                if (message.img != null && message.hasOwnProperty("img")) writer.uint32(
                /* id 3, wireType 2 =*/
                26).string(message.img);
                if (message.num != null && message.hasOwnProperty("num")) writer.uint32(
                /* id 4, wireType 0 =*/
                32).int32(message.num);
                if (message.price != null && message.hasOwnProperty("price")) writer.uint32(
                /* id 5, wireType 0 =*/
                40).int32(message.price);
                if (message.rewardType != null && message.hasOwnProperty("rewardType")) writer.uint32(
                /* id 6, wireType 0 =*/
                48).int32(message.rewardType);
                return writer;
              };
              /**
               * Encodes the specified RewardInfo message, length delimited. Does not implicitly {@link Message.RewardInfo.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.RewardInfo
               * @static
               * @param {Message.IRewardInfo} message RewardInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              RewardInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a RewardInfo message from the specified reader or buffer.
               * @function decode
               * @memberof Message.RewardInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.RewardInfo} RewardInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              RewardInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.RewardInfo();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.giftId = reader.int64();
                      break;

                    case 2:
                      message.title = reader.string();
                      break;

                    case 3:
                      message.img = reader.string();
                      break;

                    case 4:
                      message.num = reader.int32();
                      break;

                    case 5:
                      message.price = reader.int32();
                      break;

                    case 6:
                      message.rewardType = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a RewardInfo message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.RewardInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.RewardInfo} RewardInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              RewardInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a RewardInfo message.
               * @function verify
               * @memberof Message.RewardInfo
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              RewardInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.giftId != null && message.hasOwnProperty("giftId")) if (!$util.isInteger(message.giftId) && !(message.giftId && $util.isInteger(message.giftId.low) && $util.isInteger(message.giftId.high))) return "giftId: integer|Long expected";
                if (message.title != null && message.hasOwnProperty("title")) if (!$util.isString(message.title)) return "title: string expected";
                if (message.img != null && message.hasOwnProperty("img")) if (!$util.isString(message.img)) return "img: string expected";
                if (message.num != null && message.hasOwnProperty("num")) if (!$util.isInteger(message.num)) return "num: integer expected";
                if (message.price != null && message.hasOwnProperty("price")) if (!$util.isInteger(message.price)) return "price: integer expected";
                if (message.rewardType != null && message.hasOwnProperty("rewardType")) switch (message.rewardType) {
                  default:
                    return "rewardType: enum value expected";

                  case 0:
                  case 1:
                  case 2:
                  case 3:
                    break;
                }
                return null;
              };

              return RewardInfo;
            }();
            /**
             * UserOnLineStatus enum.
             * @name Message.UserOnLineStatus
             * @enum {string}
             * @property {number} USER_OFF_LINE=0 USER_OFF_LINE value
             * @property {number} USER_RETRY_LNE=1 USER_RETRY_LNE value
             */


            Message.UserOnLineStatus = function () {
              var valuesById = {},
                  values = Object.create(valuesById);
              values[valuesById[0] = "USER_OFF_LINE"] = 0;
              values[valuesById[1] = "USER_RETRY_LNE"] = 1;
              return values;
            }();
            /**
             * ExceptionStatus enum.
             * @name Message.ExceptionStatus
             * @enum {string}
             * @property {number} OFF_LINE=0 OFF_LINE value
             * @property {number} RETRY_LINE=1 RETRY_LINE value
             * @property {number} UP_SEAT=3 UP_SEAT value
             * @property {number} LEAVE_SEAT=4 LEAVE_SEAT value
             * @property {number} CLOSE_MIC=5 CLOSE_MIC value
             * @property {number} FORBID_MIC=6 FORBID_MIC value
             */


            Message.ExceptionStatus = function () {
              var valuesById = {},
                  values = Object.create(valuesById);
              values[valuesById[0] = "OFF_LINE"] = 0;
              values[valuesById[1] = "RETRY_LINE"] = 1;
              values[valuesById[3] = "UP_SEAT"] = 3;
              values[valuesById[4] = "LEAVE_SEAT"] = 4;
              values[valuesById[5] = "CLOSE_MIC"] = 5;
              values[valuesById[6] = "FORBID_MIC"] = 6;
              return values;
            }();
            /**
             * Identity enum.
             * @name Message.Identity
             * @enum {string}
             * @property {number} UNKNOWN_IDENTITY=0 UNKNOWN_IDENTITY value
             * @property {number} SOURCE=1 SOURCE value
             * @property {number} PARTICIPANT=2 PARTICIPANT value
             * @property {number} SPECTATOR=3 SPECTATOR value
             */


            Message.Identity = function () {
              var valuesById = {},
                  values = Object.create(valuesById);
              values[valuesById[0] = "UNKNOWN_IDENTITY"] = 0;
              values[valuesById[1] = "SOURCE"] = 1;
              values[valuesById[2] = "PARTICIPANT"] = 2;
              values[valuesById[3] = "SPECTATOR"] = 3;
              return values;
            }();
            /**
             * RewardType enum.
             * @name Message.RewardType
             * @enum {string}
             * @property {number} UNKNOWN_REWARD=0 UNKNOWN_REWARD value
             * @property {number} DIAMOND_GIFT=1 DIAMOND_GIFT value
             * @property {number} DIAMOND=2 DIAMOND value
             * @property {number} START_DIAMOND=3 START_DIAMOND value
             */


            Message.RewardType = function () {
              var valuesById = {},
                  values = Object.create(valuesById);
              values[valuesById[0] = "UNKNOWN_REWARD"] = 0;
              values[valuesById[1] = "DIAMOND_GIFT"] = 1;
              values[valuesById[2] = "DIAMOND"] = 2;
              values[valuesById[3] = "START_DIAMOND"] = 3;
              return values;
            }();
            /**
             * BattleEndReason enum.
             * @name Message.BattleEndReason
             * @enum {string}
             * @property {number} NORMAL_END=0 NORMAL_END value
             * @property {number} CLOSE_GAME=1 CLOSE_GAME value
             */


            Message.BattleEndReason = function () {
              var valuesById = {},
                  values = Object.create(valuesById);
              values[valuesById[0] = "NORMAL_END"] = 0;
              values[valuesById[1] = "CLOSE_GAME"] = 1;
              return values;
            }();
            /**
             * GameStatus enum.
             * @name Message.GameStatus
             * @enum {string}
             * @property {number} READY=0 READY value
             * @property {number} IN_GAME=1 IN_GAME value
             * @property {number} END_GAME=2 END_GAME value
             */


            Message.GameStatus = function () {
              var valuesById = {},
                  values = Object.create(valuesById);
              values[valuesById[0] = "READY"] = 0;
              values[valuesById[1] = "IN_GAME"] = 1;
              values[valuesById[2] = "END_GAME"] = 2;
              return values;
            }();
            /**
             * ReadyStatus enum.
             * @name Message.ReadyStatus
             * @enum {string}
             * @property {number} NO_READY=0 NO_READY value
             * @property {number} IN_READY=1 IN_READY value
             */


            Message.ReadyStatus = function () {
              var valuesById = {},
                  values = Object.create(valuesById);
              values[valuesById[0] = "NO_READY"] = 0;
              values[valuesById[1] = "IN_READY"] = 1;
              return values;
            }();
            /**
             * GameType enum.
             * @name Message.GameType
             * @enum {string}
             * @property {number} NORMAL=0 NORMAL value
             * @property {number} MACHINE=1 MACHINE value
             */


            Message.GameType = function () {
              var valuesById = {},
                  values = Object.create(valuesById);
              values[valuesById[0] = "NORMAL"] = 0;
              values[valuesById[1] = "MACHINE"] = 1;
              return values;
            }();
            /**
             * PlayType enum.
             * @name Message.PlayType
             * @enum {string}
             * @property {number} ERROR_TYPE=0 ERROR_TYPE value
             * @property {number} DISPATCH=1 DISPATCH value
             * @property {number} FRIENDS=2 FRIENDS value
             * @property {number} RECREATION=3 RECREATION value
             * @property {number} RADIO=4 RADIO value
             * @property {number} VOICE=5 VOICE value
             * @property {number} TICKTOCK=7 TICKTOCK value
             * @property {number} PICKSONG=8 PICKSONG value
             * @property {number} PERSONAL=20 PERSONAL value
             * @property {number} BLACK_ROOM=10 BLACK_ROOM value
             * @property {number} FLY_FISH_ROOM=11 FLY_FISH_ROOM value
             */


            Message.PlayType = function () {
              var valuesById = {},
                  values = Object.create(valuesById);
              values[valuesById[0] = "ERROR_TYPE"] = 0;
              values[valuesById[1] = "DISPATCH"] = 1;
              values[valuesById[2] = "FRIENDS"] = 2;
              values[valuesById[3] = "RECREATION"] = 3;
              values[valuesById[4] = "RADIO"] = 4;
              values[valuesById[5] = "VOICE"] = 5;
              values[valuesById[7] = "TICKTOCK"] = 7;
              values[valuesById[8] = "PICKSONG"] = 8;
              values[valuesById[20] = "PERSONAL"] = 20;
              values[valuesById[10] = "BLACK_ROOM"] = 10;
              values[valuesById[11] = "FLY_FISH_ROOM"] = 11;
              return values;
            }();

            Message.MsgPullReq = function () {
              /**
               * Properties of a MsgPullReq.
               * @memberof Message
               * @interface IMsgPullReq
               * @property {number|Long|null} [anchor] MsgPullReq anchor
               * @property {number|Long|null} [battleId] MsgPullReq battleId
               */

              /**
               * Constructs a new MsgPullReq.
               * @memberof Message
               * @classdesc Represents a MsgPullReq.
               * @implements IMsgPullReq
               * @constructor
               * @param {Message.IMsgPullReq=} [properties] Properties to set
               */
              function MsgPullReq(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * MsgPullReq anchor.
               * @member {number|Long} anchor
               * @memberof Message.MsgPullReq
               * @instance
               */


              MsgPullReq.prototype.anchor = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * MsgPullReq battleId.
               * @member {number|Long} battleId
               * @memberof Message.MsgPullReq
               * @instance
               */

              MsgPullReq.prototype.battleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * Creates a new MsgPullReq instance using the specified properties.
               * @function create
               * @memberof Message.MsgPullReq
               * @static
               * @param {Message.IMsgPullReq=} [properties] Properties to set
               * @returns {Message.MsgPullReq} MsgPullReq instance
               */

              MsgPullReq.create = function create(properties) {
                return new MsgPullReq(properties);
              };
              /**
               * Encodes the specified MsgPullReq message. Does not implicitly {@link Message.MsgPullReq.verify|verify} messages.
               * @function encode
               * @memberof Message.MsgPullReq
               * @static
               * @param {Message.IMsgPullReq} message MsgPullReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              MsgPullReq.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.anchor != null && message.hasOwnProperty("anchor")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.anchor);
                if (message.battleId != null && message.hasOwnProperty("battleId")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.battleId);
                return writer;
              };
              /**
               * Encodes the specified MsgPullReq message, length delimited. Does not implicitly {@link Message.MsgPullReq.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.MsgPullReq
               * @static
               * @param {Message.IMsgPullReq} message MsgPullReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              MsgPullReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a MsgPullReq message from the specified reader or buffer.
               * @function decode
               * @memberof Message.MsgPullReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.MsgPullReq} MsgPullReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              MsgPullReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.MsgPullReq();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.anchor = reader.int64();
                      break;

                    case 2:
                      message.battleId = reader.int64();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a MsgPullReq message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.MsgPullReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.MsgPullReq} MsgPullReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              MsgPullReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a MsgPullReq message.
               * @function verify
               * @memberof Message.MsgPullReq
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              MsgPullReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.anchor != null && message.hasOwnProperty("anchor")) if (!$util.isInteger(message.anchor) && !(message.anchor && $util.isInteger(message.anchor.low) && $util.isInteger(message.anchor.high))) return "anchor: integer|Long expected";
                if (message.battleId != null && message.hasOwnProperty("battleId")) if (!$util.isInteger(message.battleId) && !(message.battleId && $util.isInteger(message.battleId.low) && $util.isInteger(message.battleId.high))) return "battleId: integer|Long expected";
                return null;
              };

              return MsgPullReq;
            }();

            Message.MsgPullResp = function () {
              /**
               * Properties of a MsgPullResp.
               * @memberof Message
               * @interface IMsgPullResp
               * @property {Array.<Message.IMsgWithSeq>|null} [msgList] MsgPullResp msgList
               * @property {number|Long|null} [waitMs] MsgPullResp waitMs
               */

              /**
               * Constructs a new MsgPullResp.
               * @memberof Message
               * @classdesc Represents a MsgPullResp.
               * @implements IMsgPullResp
               * @constructor
               * @param {Message.IMsgPullResp=} [properties] Properties to set
               */
              function MsgPullResp(properties) {
                this.msgList = [];
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * MsgPullResp msgList.
               * @member {Array.<Message.IMsgWithSeq>} msgList
               * @memberof Message.MsgPullResp
               * @instance
               */


              MsgPullResp.prototype.msgList = $util.emptyArray;
              /**
               * MsgPullResp waitMs.
               * @member {number|Long} waitMs
               * @memberof Message.MsgPullResp
               * @instance
               */

              MsgPullResp.prototype.waitMs = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * Creates a new MsgPullResp instance using the specified properties.
               * @function create
               * @memberof Message.MsgPullResp
               * @static
               * @param {Message.IMsgPullResp=} [properties] Properties to set
               * @returns {Message.MsgPullResp} MsgPullResp instance
               */

              MsgPullResp.create = function create(properties) {
                return new MsgPullResp(properties);
              };
              /**
               * Encodes the specified MsgPullResp message. Does not implicitly {@link Message.MsgPullResp.verify|verify} messages.
               * @function encode
               * @memberof Message.MsgPullResp
               * @static
               * @param {Message.IMsgPullResp} message MsgPullResp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              MsgPullResp.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.msgList != null && message.msgList.length) for (var i = 0; i < message.msgList.length; ++i) {
                  $root.Message.MsgWithSeq.encode(message.msgList[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10).fork()).ldelim();
                }
                if (message.waitMs != null && message.hasOwnProperty("waitMs")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int64(message.waitMs);
                return writer;
              };
              /**
               * Encodes the specified MsgPullResp message, length delimited. Does not implicitly {@link Message.MsgPullResp.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.MsgPullResp
               * @static
               * @param {Message.IMsgPullResp} message MsgPullResp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              MsgPullResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a MsgPullResp message from the specified reader or buffer.
               * @function decode
               * @memberof Message.MsgPullResp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.MsgPullResp} MsgPullResp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              MsgPullResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.MsgPullResp();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      if (!(message.msgList && message.msgList.length)) message.msgList = [];
                      message.msgList.push($root.Message.MsgWithSeq.decode(reader, reader.uint32()));
                      break;

                    case 2:
                      message.waitMs = reader.int64();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a MsgPullResp message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.MsgPullResp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.MsgPullResp} MsgPullResp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              MsgPullResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a MsgPullResp message.
               * @function verify
               * @memberof Message.MsgPullResp
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              MsgPullResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";

                if (message.msgList != null && message.hasOwnProperty("msgList")) {
                  if (!Array.isArray(message.msgList)) return "msgList: array expected";

                  for (var i = 0; i < message.msgList.length; ++i) {
                    var error = $root.Message.MsgWithSeq.verify(message.msgList[i]);
                    if (error) return "msgList." + error;
                  }
                }

                if (message.waitMs != null && message.hasOwnProperty("waitMs")) if (!$util.isInteger(message.waitMs) && !(message.waitMs && $util.isInteger(message.waitMs.low) && $util.isInteger(message.waitMs.high))) return "waitMs: integer|Long expected";
                return null;
              };

              return MsgPullResp;
            }();

            Message.MsgWithSeq = function () {
              /**
               * Properties of a MsgWithSeq.
               * @memberof Message
               * @interface IMsgWithSeq
               * @property {number|Long|null} [seq] MsgWithSeq seq
               * @property {Uint8Array|null} [body] MsgWithSeq body
               * @property {number|null} [command] MsgWithSeq command
               */

              /**
               * Constructs a new MsgWithSeq.
               * @memberof Message
               * @classdesc Represents a MsgWithSeq.
               * @implements IMsgWithSeq
               * @constructor
               * @param {Message.IMsgWithSeq=} [properties] Properties to set
               */
              function MsgWithSeq(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * MsgWithSeq seq.
               * @member {number|Long} seq
               * @memberof Message.MsgWithSeq
               * @instance
               */


              MsgWithSeq.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * MsgWithSeq body.
               * @member {Uint8Array} body
               * @memberof Message.MsgWithSeq
               * @instance
               */

              MsgWithSeq.prototype.body = $util.newBuffer([]);
              /**
               * MsgWithSeq command.
               * @member {number} command
               * @memberof Message.MsgWithSeq
               * @instance
               */

              MsgWithSeq.prototype.command = 0;
              /**
               * Creates a new MsgWithSeq instance using the specified properties.
               * @function create
               * @memberof Message.MsgWithSeq
               * @static
               * @param {Message.IMsgWithSeq=} [properties] Properties to set
               * @returns {Message.MsgWithSeq} MsgWithSeq instance
               */

              MsgWithSeq.create = function create(properties) {
                return new MsgWithSeq(properties);
              };
              /**
               * Encodes the specified MsgWithSeq message. Does not implicitly {@link Message.MsgWithSeq.verify|verify} messages.
               * @function encode
               * @memberof Message.MsgWithSeq
               * @static
               * @param {Message.IMsgWithSeq} message MsgWithSeq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              MsgWithSeq.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.seq != null && message.hasOwnProperty("seq")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.seq);
                if (message.body != null && message.hasOwnProperty("body")) writer.uint32(
                /* id 2, wireType 2 =*/
                18).bytes(message.body);
                if (message.command != null && message.hasOwnProperty("command")) writer.uint32(
                /* id 3, wireType 0 =*/
                24).int32(message.command);
                return writer;
              };
              /**
               * Encodes the specified MsgWithSeq message, length delimited. Does not implicitly {@link Message.MsgWithSeq.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.MsgWithSeq
               * @static
               * @param {Message.IMsgWithSeq} message MsgWithSeq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              MsgWithSeq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a MsgWithSeq message from the specified reader or buffer.
               * @function decode
               * @memberof Message.MsgWithSeq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.MsgWithSeq} MsgWithSeq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              MsgWithSeq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.MsgWithSeq();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.seq = reader.int64();
                      break;

                    case 2:
                      message.body = reader.bytes();
                      break;

                    case 3:
                      message.command = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a MsgWithSeq message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.MsgWithSeq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.MsgWithSeq} MsgWithSeq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              MsgWithSeq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a MsgWithSeq message.
               * @function verify
               * @memberof Message.MsgWithSeq
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              MsgWithSeq.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.seq != null && message.hasOwnProperty("seq")) if (!$util.isInteger(message.seq) && !(message.seq && $util.isInteger(message.seq.low) && $util.isInteger(message.seq.high))) return "seq: integer|Long expected";
                if (message.body != null && message.hasOwnProperty("body")) if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body))) return "body: buffer expected";
                if (message.command != null && message.hasOwnProperty("command")) if (!$util.isInteger(message.command)) return "command: integer expected";
                return null;
              };

              return MsgWithSeq;
            }();

            Message.PushBroadcast = function () {
              /**
               * Properties of a PushBroadcast.
               * @memberof Message
               * @interface IPushBroadcast
               * @property {string|null} [roomId] PushBroadcast roomId
               * @property {number|null} [command] PushBroadcast command
               * @property {Uint8Array|null} [body] PushBroadcast body
               */

              /**
               * Constructs a new PushBroadcast.
               * @memberof Message
               * @classdesc Represents a PushBroadcast.
               * @implements IPushBroadcast
               * @constructor
               * @param {Message.IPushBroadcast=} [properties] Properties to set
               */
              function PushBroadcast(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * PushBroadcast roomId.
               * @member {string} roomId
               * @memberof Message.PushBroadcast
               * @instance
               */


              PushBroadcast.prototype.roomId = "";
              /**
               * PushBroadcast command.
               * @member {number} command
               * @memberof Message.PushBroadcast
               * @instance
               */

              PushBroadcast.prototype.command = 0;
              /**
               * PushBroadcast body.
               * @member {Uint8Array} body
               * @memberof Message.PushBroadcast
               * @instance
               */

              PushBroadcast.prototype.body = $util.newBuffer([]);
              /**
               * Creates a new PushBroadcast instance using the specified properties.
               * @function create
               * @memberof Message.PushBroadcast
               * @static
               * @param {Message.IPushBroadcast=} [properties] Properties to set
               * @returns {Message.PushBroadcast} PushBroadcast instance
               */

              PushBroadcast.create = function create(properties) {
                return new PushBroadcast(properties);
              };
              /**
               * Encodes the specified PushBroadcast message. Does not implicitly {@link Message.PushBroadcast.verify|verify} messages.
               * @function encode
               * @memberof Message.PushBroadcast
               * @static
               * @param {Message.IPushBroadcast} message PushBroadcast message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              PushBroadcast.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.roomId != null && message.hasOwnProperty("roomId")) writer.uint32(
                /* id 1, wireType 2 =*/
                10).string(message.roomId);
                if (message.command != null && message.hasOwnProperty("command")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int32(message.command);
                if (message.body != null && message.hasOwnProperty("body")) writer.uint32(
                /* id 3, wireType 2 =*/
                26).bytes(message.body);
                return writer;
              };
              /**
               * Encodes the specified PushBroadcast message, length delimited. Does not implicitly {@link Message.PushBroadcast.verify|verify} messages.
               * @function encodeDelimited
               * @memberof Message.PushBroadcast
               * @static
               * @param {Message.IPushBroadcast} message PushBroadcast message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              PushBroadcast.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a PushBroadcast message from the specified reader or buffer.
               * @function decode
               * @memberof Message.PushBroadcast
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {Message.PushBroadcast} PushBroadcast
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              PushBroadcast.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.Message.PushBroadcast();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.roomId = reader.string();
                      break;

                    case 2:
                      message.command = reader.int32();
                      break;

                    case 3:
                      message.body = reader.bytes();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a PushBroadcast message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof Message.PushBroadcast
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {Message.PushBroadcast} PushBroadcast
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              PushBroadcast.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a PushBroadcast message.
               * @function verify
               * @memberof Message.PushBroadcast
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              PushBroadcast.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.roomId != null && message.hasOwnProperty("roomId")) if (!$util.isString(message.roomId)) return "roomId: string expected";
                if (message.command != null && message.hasOwnProperty("command")) if (!$util.isInteger(message.command)) return "command: integer expected";
                if (message.body != null && message.hasOwnProperty("body")) if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body))) return "body: buffer expected";
                return null;
              };

              return PushBroadcast;
            }();

            return Message;
          }();

          $root.ProMessage = function () {
            /**
             * Namespace ProMessage.
             * @exports ProMessage
             * @namespace
             */
            var ProMessage = {};

            ProMessage.ServerLoginReq = function () {
              /**
               * Properties of a ServerLoginReq.
               * @memberof ProMessage
               * @interface IServerLoginReq
               * @property {number|Long|null} [uid] ServerLoginReq uid
               * @property {string|null} [osName] ServerLoginReq osName
               * @property {string|null} [ip] ServerLoginReq ip
               */

              /**
               * Constructs a new ServerLoginReq.
               * @memberof ProMessage
               * @classdesc Represents a ServerLoginReq.
               * @implements IServerLoginReq
               * @constructor
               * @param {ProMessage.IServerLoginReq=} [properties] Properties to set
               */
              function ServerLoginReq(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * ServerLoginReq uid.
               * @member {number|Long} uid
               * @memberof ProMessage.ServerLoginReq
               * @instance
               */


              ServerLoginReq.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * ServerLoginReq osName.
               * @member {string} osName
               * @memberof ProMessage.ServerLoginReq
               * @instance
               */

              ServerLoginReq.prototype.osName = "";
              /**
               * ServerLoginReq ip.
               * @member {string} ip
               * @memberof ProMessage.ServerLoginReq
               * @instance
               */

              ServerLoginReq.prototype.ip = "";
              /**
               * Creates a new ServerLoginReq instance using the specified properties.
               * @function create
               * @memberof ProMessage.ServerLoginReq
               * @static
               * @param {ProMessage.IServerLoginReq=} [properties] Properties to set
               * @returns {ProMessage.ServerLoginReq} ServerLoginReq instance
               */

              ServerLoginReq.create = function create(properties) {
                return new ServerLoginReq(properties);
              };
              /**
               * Encodes the specified ServerLoginReq message. Does not implicitly {@link ProMessage.ServerLoginReq.verify|verify} messages.
               * @function encode
               * @memberof ProMessage.ServerLoginReq
               * @static
               * @param {ProMessage.IServerLoginReq} message ServerLoginReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              ServerLoginReq.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.uid);
                if (message.osName != null && message.hasOwnProperty("osName")) writer.uint32(
                /* id 2, wireType 2 =*/
                18).string(message.osName);
                if (message.ip != null && message.hasOwnProperty("ip")) writer.uint32(
                /* id 3, wireType 2 =*/
                26).string(message.ip);
                return writer;
              };
              /**
               * Encodes the specified ServerLoginReq message, length delimited. Does not implicitly {@link ProMessage.ServerLoginReq.verify|verify} messages.
               * @function encodeDelimited
               * @memberof ProMessage.ServerLoginReq
               * @static
               * @param {ProMessage.IServerLoginReq} message ServerLoginReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              ServerLoginReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a ServerLoginReq message from the specified reader or buffer.
               * @function decode
               * @memberof ProMessage.ServerLoginReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {ProMessage.ServerLoginReq} ServerLoginReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              ServerLoginReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.ProMessage.ServerLoginReq();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.uid = reader.int64();
                      break;

                    case 2:
                      message.osName = reader.string();
                      break;

                    case 3:
                      message.ip = reader.string();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a ServerLoginReq message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof ProMessage.ServerLoginReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {ProMessage.ServerLoginReq} ServerLoginReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              ServerLoginReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a ServerLoginReq message.
               * @function verify
               * @memberof ProMessage.ServerLoginReq
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              ServerLoginReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                if (message.osName != null && message.hasOwnProperty("osName")) if (!$util.isString(message.osName)) return "osName: string expected";
                if (message.ip != null && message.hasOwnProperty("ip")) if (!$util.isString(message.ip)) return "ip: string expected";
                return null;
              };

              return ServerLoginReq;
            }();

            ProMessage.ServerLoginRes = function () {
              /**
               * Properties of a ServerLoginRes.
               * @memberof ProMessage
               * @interface IServerLoginRes
               */

              /**
               * Constructs a new ServerLoginRes.
               * @memberof ProMessage
               * @classdesc Represents a ServerLoginRes.
               * @implements IServerLoginRes
               * @constructor
               * @param {ProMessage.IServerLoginRes=} [properties] Properties to set
               */
              function ServerLoginRes(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * Creates a new ServerLoginRes instance using the specified properties.
               * @function create
               * @memberof ProMessage.ServerLoginRes
               * @static
               * @param {ProMessage.IServerLoginRes=} [properties] Properties to set
               * @returns {ProMessage.ServerLoginRes} ServerLoginRes instance
               */


              ServerLoginRes.create = function create(properties) {
                return new ServerLoginRes(properties);
              };
              /**
               * Encodes the specified ServerLoginRes message. Does not implicitly {@link ProMessage.ServerLoginRes.verify|verify} messages.
               * @function encode
               * @memberof ProMessage.ServerLoginRes
               * @static
               * @param {ProMessage.IServerLoginRes} message ServerLoginRes message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              ServerLoginRes.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                return writer;
              };
              /**
               * Encodes the specified ServerLoginRes message, length delimited. Does not implicitly {@link ProMessage.ServerLoginRes.verify|verify} messages.
               * @function encodeDelimited
               * @memberof ProMessage.ServerLoginRes
               * @static
               * @param {ProMessage.IServerLoginRes} message ServerLoginRes message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              ServerLoginRes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a ServerLoginRes message from the specified reader or buffer.
               * @function decode
               * @memberof ProMessage.ServerLoginRes
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {ProMessage.ServerLoginRes} ServerLoginRes
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              ServerLoginRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.ProMessage.ServerLoginRes();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a ServerLoginRes message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof ProMessage.ServerLoginRes
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {ProMessage.ServerLoginRes} ServerLoginRes
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              ServerLoginRes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a ServerLoginRes message.
               * @function verify
               * @memberof ProMessage.ServerLoginRes
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              ServerLoginRes.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                return null;
              };

              return ServerLoginRes;
            }();

            ProMessage.MessageState = function () {
              /**
               * Properties of a MessageState.
               * @memberof ProMessage
               * @interface IMessageState
               * @property {number|null} [code] MessageState code
               */

              /**
               * Constructs a new MessageState.
               * @memberof ProMessage
               * @classdesc Represents a MessageState.
               * @implements IMessageState
               * @constructor
               * @param {ProMessage.IMessageState=} [properties] Properties to set
               */
              function MessageState(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * MessageState code.
               * @member {number} code
               * @memberof ProMessage.MessageState
               * @instance
               */


              MessageState.prototype.code = 0;
              /**
               * Creates a new MessageState instance using the specified properties.
               * @function create
               * @memberof ProMessage.MessageState
               * @static
               * @param {ProMessage.IMessageState=} [properties] Properties to set
               * @returns {ProMessage.MessageState} MessageState instance
               */

              MessageState.create = function create(properties) {
                return new MessageState(properties);
              };
              /**
               * Encodes the specified MessageState message. Does not implicitly {@link ProMessage.MessageState.verify|verify} messages.
               * @function encode
               * @memberof ProMessage.MessageState
               * @static
               * @param {ProMessage.IMessageState} message MessageState message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              MessageState.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.code != null && message.hasOwnProperty("code")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int32(message.code);
                return writer;
              };
              /**
               * Encodes the specified MessageState message, length delimited. Does not implicitly {@link ProMessage.MessageState.verify|verify} messages.
               * @function encodeDelimited
               * @memberof ProMessage.MessageState
               * @static
               * @param {ProMessage.IMessageState} message MessageState message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              MessageState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a MessageState message from the specified reader or buffer.
               * @function decode
               * @memberof ProMessage.MessageState
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {ProMessage.MessageState} MessageState
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              MessageState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.ProMessage.MessageState();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.code = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a MessageState message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof ProMessage.MessageState
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {ProMessage.MessageState} MessageState
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              MessageState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a MessageState message.
               * @function verify
               * @memberof ProMessage.MessageState
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              MessageState.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.code != null && message.hasOwnProperty("code")) if (!$util.isInteger(message.code)) return "code: integer expected";
                return null;
              };

              return MessageState;
            }();

            ProMessage.ServerOfflineReq = function () {
              /**
               * Properties of a ServerOfflineReq.
               * @memberof ProMessage
               * @interface IServerOfflineReq
               * @property {number|Long|null} [uid] ServerOfflineReq uid
               */

              /**
               * Constructs a new ServerOfflineReq.
               * @memberof ProMessage
               * @classdesc Represents a ServerOfflineReq.
               * @implements IServerOfflineReq
               * @constructor
               * @param {ProMessage.IServerOfflineReq=} [properties] Properties to set
               */
              function ServerOfflineReq(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * ServerOfflineReq uid.
               * @member {number|Long} uid
               * @memberof ProMessage.ServerOfflineReq
               * @instance
               */


              ServerOfflineReq.prototype.uid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * Creates a new ServerOfflineReq instance using the specified properties.
               * @function create
               * @memberof ProMessage.ServerOfflineReq
               * @static
               * @param {ProMessage.IServerOfflineReq=} [properties] Properties to set
               * @returns {ProMessage.ServerOfflineReq} ServerOfflineReq instance
               */

              ServerOfflineReq.create = function create(properties) {
                return new ServerOfflineReq(properties);
              };
              /**
               * Encodes the specified ServerOfflineReq message. Does not implicitly {@link ProMessage.ServerOfflineReq.verify|verify} messages.
               * @function encode
               * @memberof ProMessage.ServerOfflineReq
               * @static
               * @param {ProMessage.IServerOfflineReq} message ServerOfflineReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              ServerOfflineReq.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.uid != null && message.hasOwnProperty("uid")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.uid);
                return writer;
              };
              /**
               * Encodes the specified ServerOfflineReq message, length delimited. Does not implicitly {@link ProMessage.ServerOfflineReq.verify|verify} messages.
               * @function encodeDelimited
               * @memberof ProMessage.ServerOfflineReq
               * @static
               * @param {ProMessage.IServerOfflineReq} message ServerOfflineReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              ServerOfflineReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a ServerOfflineReq message from the specified reader or buffer.
               * @function decode
               * @memberof ProMessage.ServerOfflineReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {ProMessage.ServerOfflineReq} ServerOfflineReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              ServerOfflineReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.ProMessage.ServerOfflineReq();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.uid = reader.int64();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a ServerOfflineReq message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof ProMessage.ServerOfflineReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {ProMessage.ServerOfflineReq} ServerOfflineReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              ServerOfflineReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a ServerOfflineReq message.
               * @function verify
               * @memberof ProMessage.ServerOfflineReq
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              ServerOfflineReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid")) if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high))) return "uid: integer|Long expected";
                return null;
              };

              return ServerOfflineReq;
            }();

            ProMessage.ServerOfflineRes = function () {
              /**
               * Properties of a ServerOfflineRes.
               * @memberof ProMessage
               * @interface IServerOfflineRes
               */

              /**
               * Constructs a new ServerOfflineRes.
               * @memberof ProMessage
               * @classdesc Represents a ServerOfflineRes.
               * @implements IServerOfflineRes
               * @constructor
               * @param {ProMessage.IServerOfflineRes=} [properties] Properties to set
               */
              function ServerOfflineRes(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * Creates a new ServerOfflineRes instance using the specified properties.
               * @function create
               * @memberof ProMessage.ServerOfflineRes
               * @static
               * @param {ProMessage.IServerOfflineRes=} [properties] Properties to set
               * @returns {ProMessage.ServerOfflineRes} ServerOfflineRes instance
               */


              ServerOfflineRes.create = function create(properties) {
                return new ServerOfflineRes(properties);
              };
              /**
               * Encodes the specified ServerOfflineRes message. Does not implicitly {@link ProMessage.ServerOfflineRes.verify|verify} messages.
               * @function encode
               * @memberof ProMessage.ServerOfflineRes
               * @static
               * @param {ProMessage.IServerOfflineRes} message ServerOfflineRes message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              ServerOfflineRes.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                return writer;
              };
              /**
               * Encodes the specified ServerOfflineRes message, length delimited. Does not implicitly {@link ProMessage.ServerOfflineRes.verify|verify} messages.
               * @function encodeDelimited
               * @memberof ProMessage.ServerOfflineRes
               * @static
               * @param {ProMessage.IServerOfflineRes} message ServerOfflineRes message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              ServerOfflineRes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a ServerOfflineRes message from the specified reader or buffer.
               * @function decode
               * @memberof ProMessage.ServerOfflineRes
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {ProMessage.ServerOfflineRes} ServerOfflineRes
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              ServerOfflineRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.ProMessage.ServerOfflineRes();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a ServerOfflineRes message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof ProMessage.ServerOfflineRes
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {ProMessage.ServerOfflineRes} ServerOfflineRes
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              ServerOfflineRes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a ServerOfflineRes message.
               * @function verify
               * @memberof ProMessage.ServerOfflineRes
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              ServerOfflineRes.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                return null;
              };

              return ServerOfflineRes;
            }();

            ProMessage.HeartBeatReq = function () {
              /**
               * Properties of a HeartBeatReq.
               * @memberof ProMessage
               * @interface IHeartBeatReq
               * @property {number|null} [index] HeartBeatReq index
               */

              /**
               * Constructs a new HeartBeatReq.
               * @memberof ProMessage
               * @classdesc Represents a HeartBeatReq.
               * @implements IHeartBeatReq
               * @constructor
               * @param {ProMessage.IHeartBeatReq=} [properties] Properties to set
               */
              function HeartBeatReq(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * HeartBeatReq index.
               * @member {number} index
               * @memberof ProMessage.HeartBeatReq
               * @instance
               */


              HeartBeatReq.prototype.index = 0;
              /**
               * Creates a new HeartBeatReq instance using the specified properties.
               * @function create
               * @memberof ProMessage.HeartBeatReq
               * @static
               * @param {ProMessage.IHeartBeatReq=} [properties] Properties to set
               * @returns {ProMessage.HeartBeatReq} HeartBeatReq instance
               */

              HeartBeatReq.create = function create(properties) {
                return new HeartBeatReq(properties);
              };
              /**
               * Encodes the specified HeartBeatReq message. Does not implicitly {@link ProMessage.HeartBeatReq.verify|verify} messages.
               * @function encode
               * @memberof ProMessage.HeartBeatReq
               * @static
               * @param {ProMessage.IHeartBeatReq} message HeartBeatReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              HeartBeatReq.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.index != null && message.hasOwnProperty("index")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int32(message.index);
                return writer;
              };
              /**
               * Encodes the specified HeartBeatReq message, length delimited. Does not implicitly {@link ProMessage.HeartBeatReq.verify|verify} messages.
               * @function encodeDelimited
               * @memberof ProMessage.HeartBeatReq
               * @static
               * @param {ProMessage.IHeartBeatReq} message HeartBeatReq message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              HeartBeatReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a HeartBeatReq message from the specified reader or buffer.
               * @function decode
               * @memberof ProMessage.HeartBeatReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {ProMessage.HeartBeatReq} HeartBeatReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              HeartBeatReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.ProMessage.HeartBeatReq();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.index = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a HeartBeatReq message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof ProMessage.HeartBeatReq
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {ProMessage.HeartBeatReq} HeartBeatReq
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              HeartBeatReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a HeartBeatReq message.
               * @function verify
               * @memberof ProMessage.HeartBeatReq
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              HeartBeatReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.index != null && message.hasOwnProperty("index")) if (!$util.isInteger(message.index)) return "index: integer expected";
                return null;
              };

              return HeartBeatReq;
            }();

            ProMessage.HeartBeatRes = function () {
              /**
               * Properties of a HeartBeatRes.
               * @memberof ProMessage
               * @interface IHeartBeatRes
               * @property {number|null} [index] HeartBeatRes index
               */

              /**
               * Constructs a new HeartBeatRes.
               * @memberof ProMessage
               * @classdesc Represents a HeartBeatRes.
               * @implements IHeartBeatRes
               * @constructor
               * @param {ProMessage.IHeartBeatRes=} [properties] Properties to set
               */
              function HeartBeatRes(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * HeartBeatRes index.
               * @member {number} index
               * @memberof ProMessage.HeartBeatRes
               * @instance
               */


              HeartBeatRes.prototype.index = 0;
              /**
               * Creates a new HeartBeatRes instance using the specified properties.
               * @function create
               * @memberof ProMessage.HeartBeatRes
               * @static
               * @param {ProMessage.IHeartBeatRes=} [properties] Properties to set
               * @returns {ProMessage.HeartBeatRes} HeartBeatRes instance
               */

              HeartBeatRes.create = function create(properties) {
                return new HeartBeatRes(properties);
              };
              /**
               * Encodes the specified HeartBeatRes message. Does not implicitly {@link ProMessage.HeartBeatRes.verify|verify} messages.
               * @function encode
               * @memberof ProMessage.HeartBeatRes
               * @static
               * @param {ProMessage.IHeartBeatRes} message HeartBeatRes message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              HeartBeatRes.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.index != null && message.hasOwnProperty("index")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int32(message.index);
                return writer;
              };
              /**
               * Encodes the specified HeartBeatRes message, length delimited. Does not implicitly {@link ProMessage.HeartBeatRes.verify|verify} messages.
               * @function encodeDelimited
               * @memberof ProMessage.HeartBeatRes
               * @static
               * @param {ProMessage.IHeartBeatRes} message HeartBeatRes message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              HeartBeatRes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a HeartBeatRes message from the specified reader or buffer.
               * @function decode
               * @memberof ProMessage.HeartBeatRes
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {ProMessage.HeartBeatRes} HeartBeatRes
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              HeartBeatRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.ProMessage.HeartBeatRes();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.index = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a HeartBeatRes message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof ProMessage.HeartBeatRes
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {ProMessage.HeartBeatRes} HeartBeatRes
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              HeartBeatRes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a HeartBeatRes message.
               * @function verify
               * @memberof ProMessage.HeartBeatRes
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              HeartBeatRes.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.index != null && message.hasOwnProperty("index")) if (!$util.isInteger(message.index)) return "index: integer expected";
                return null;
              };

              return HeartBeatRes;
            }();

            return ProMessage;
          }();
        })();

        _cjsExports = exports('default', module.exports);
      });

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);
    }
  };
});

System.register("chunks:///_virtual/PCBottomUI_Ctrl.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './index.cjs.js', './index.cjs.mjs_cjs=&original=.js', './UIMgr.ts', './EventMgr.ts', './GameConstants.ts', './AudioManager.ts', './BridgeMgr.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, LabelComponent, sys, macro, _inheritsLoose, _defineProperty, _assertThisInitialized, _cjsExports, UICtrl, EventMgr, Tips, ArrowState, SoundName, GameEnum, AudioManager, BridgeMgr;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      LabelComponent = module.LabelComponent;
      sys = module.sys;
      macro = module.macro;
    }, function (module) {
      _inheritsLoose = module.inheritsLoose;
      _defineProperty = module.defineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      _cjsExports = module.default;
    }, null, function (module) {
      UICtrl = module.UICtrl;
    }, function (module) {
      EventMgr = module.EventMgr;
    }, function (module) {
      Tips = module.Tips;
      ArrowState = module.ArrowState;
      SoundName = module.SoundName;
      GameEnum = module.GameEnum;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      BridgeMgr = module.BridgeMgr;
    }],
    execute: function () {
      var _dec, _class, _temp;

      cclegacy._RF.push({}, "68b5bv5CmhBzoYYvsaW1iDE", "PCBottomUI_Ctrl", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var Logger = _cjsExports.Logger;
      var PCBottomUI_Ctrl = exports('PCBottomUI_Ctrl', (_dec = ccclass('PCBottomUI_Ctrl'), _dec(_class = (_temp = /*#__PURE__*/function (_UICtrl) {
        _inheritsLoose(PCBottomUI_Ctrl, _UICtrl);

        function PCBottomUI_Ctrl() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _UICtrl.call.apply(_UICtrl, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this), "settleData", null);

          _defineProperty(_assertThisInitialized(_this), "isOverTimeAnimating", false);

          _defineProperty(_assertThisInitialized(_this), "rotateSpeed", 0.1);

          _defineProperty(_assertThisInitialized(_this), "currentSpeed", 0);

          _defineProperty(_assertThisInitialized(_this), "currentBtnIdx", 0);

          _defineProperty(_assertThisInitialized(_this), "nextBtnIdx", 0);

          _defineProperty(_assertThisInitialized(_this), "endBtnIdx", -1);

          _defineProperty(_assertThisInitialized(_this), "isFinalRotate", false);

          _defineProperty(_assertThisInitialized(_this), "currentNo", 10);

          _defineProperty(_assertThisInitialized(_this), "isLeftShow", false);

          _defineProperty(_assertThisInitialized(_this), "isRightShow", false);

          _defineProperty(_assertThisInitialized(_this), "isUpShow", false);

          _defineProperty(_assertThisInitialized(_this), "isDownShow", false);

          _defineProperty(_assertThisInitialized(_this), "isCenterShow", false);

          _defineProperty(_assertThisInitialized(_this), "tipsBG", null);

          _defineProperty(_assertThisInitialized(_this), "tipLabelNode", null);

          _defineProperty(_assertThisInitialized(_this), "tipLabel", null);

          return _this;
        }

        var _proto = PCBottomUI_Ctrl.prototype;

        _proto.onLoad = function onLoad() {
          _UICtrl.prototype.onLoad.call(this);

          this.tipsBG = this.view["tipsBG"];
          this.tipLabelNode = this.view["tipsBG/tipLabel"];
          this.tipLabel = this.tipLabelNode.getComponent(LabelComponent); // systemEvent.on(SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);
          //监听pc端按键事件

          BridgeMgr.Instance.listenPCKeyBoardEvent(this.onKeyDownCallBack.bind(this));
        } //更新快照数据
        ;

        _proto.updateSnapshotUI = function updateSnapshotUI() {
          this.tipLabel.string = Tips.tipRegStart;
        } //更新本局或本轮开始数据
        ;

        _proto.updateGameStartUI = function updateGameStartUI(data) {
          var _this2 = this;

          var tipReg = Tips.tipRegPre + data.roundCountdown.toString() + Tips.tipRegRear;

          var _label = data.isPlayoff == false ? tipReg : Tips.pcTipOverTime;

          this.currentNo = data.roundCountdown;

          if (data.myData.id) {
            //在本局，基于局面的选择控制按钮的显示隐藏
            if (data.isPlayoff == false) {
              //重连时间很短促的情况下就不要做这种提示了，时间太短，不适宜展示
              if (data.roundCountdown > 3) {
                var isShow = sys.localStorage.getItem("guideShowed");

                if (isShow != "1") {
                  this.showGuideAni();
                  sys.localStorage.setItem("guideShowed", "1");
                  this.scheduleOnce(function () {
                    _this2.hideGuideAni();
                  }, data.roundCountdown);
                }
              }

              this.updateOperateBtnState(ArrowState[data.myData.id][0], ArrowState[data.myData.id][1], ArrowState[data.myData.id][2], ArrowState[data.myData.id][3], false);
              this.updateTimeTips();
              this.schedule(this.updateTimeTips, 1, this.currentNo, -1);
              Logger.info("显示非加赛按钮,isPlayoff = ", data.isPlayoff, "  我的格子数据为：", JSON.stringify(data));
            } else {
              this.updateOperateBtnState(false, false, false, false, true);
              this.scheduleOnce(function () {
                if (_this2.isOverTimeAnimating) return;
                _this2.tipLabel.string = Tips.tipOverTimeIn;
              }, this.currentNo - 3);
              Logger.info("显示加赛按钮,isPlayoff = ", data.isPlayoff, "  我的格子数据为：", JSON.stringify(data));
            }
          } else {
            _label = Tips.tipRegNo; //不在本局

            Logger.info("不在本轮，无法操作,isPlayoff = ", data.isPlayoff, "  我的格子数据为：", JSON.stringify(data));
            this.updateOperateBtnState(false, false, false, false, false);
          }

          this.tipLabel.string = _label;
        };

        _proto.showGuideAni = function showGuideAni() {
          this.view["pcBtn"].active = true;
          this.tipsBG.active = false;
        };

        _proto.hideGuideAni = function hideGuideAni() {
          this.view["pcBtn"].active = false;
          this.tipsBG.active = true;
        };

        _proto.updateTimeTips = function updateTimeTips() {
          var _label = "请在 " + this.currentNo + "s 内做出选择";

          this.tipLabel.string = _label;
          this.currentNo--;
        };

        _proto.updateLabel = function updateLabel(str) {
          this.unschedule(this.updateTimeTips);
          this.tipLabel.string = str;
        } //加赛开关
        ;

        _proto.overTimeRunning = function overTimeRunning() {
          this.updateOperateBtnState(false, false, false, false, false);
          this.tipLabel.string = Tips.tipOverTimeIn;
        } //按钮移动降速
        ;

        _proto.slowDown = function slowDown(offsetIdx, settleData) {};

        _proto.update = function update(dt) {};

        _proto.onDestroy = function onDestroy() {// systemEvent.off(SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);
        } //更新操作按钮显示隐藏
        ;

        _proto.updateOperateBtnState = function updateOperateBtnState(leftShow, upShow, rightShow, downShow, centerShow) {
          if (this.isLeftShow == !leftShow) {
            this.isLeftShow = leftShow;
          }

          if (this.isRightShow == !rightShow) {
            this.isRightShow = rightShow;
          }

          if (this.isUpShow == !upShow) {
            this.isUpShow = upShow;
          }

          if (this.isDownShow == !downShow) {
            this.isDownShow = downShow;
          }

          if (this.isCenterShow == !centerShow) {
            this.isCenterShow = centerShow;
          }
        } //pc键按下事件监听
        ;

        _proto.onKeyDown = function onKeyDown(event) {
          switch (event.keyCode) {
            case macro.KEY.up:
              if (this.isUpShow) this.onPressUp();
              break;

            case macro.KEY.down:
              if (this.isDownShow) this.onPressDown();
              break;

            case macro.KEY.left:
              if (this.isLeftShow) this.onPressLeft();
              break;

            case macro.KEY.right:
              if (this.isRightShow) this.onPressRight();
              break;

            case macro.KEY.space:
              if (this.isCenterShow) this.onPressCenter();
              break;
          }
        };

        _proto.onKeyDownCallBack = function onKeyDownCallBack(data) {
          switch (data) {
            case 'Up':
              if (this.isUpShow) this.onPressUp();
              break;

            case 'Down':
              if (this.isDownShow) this.onPressDown();
              break;

            case 'Left':
              if (this.isLeftShow) this.onPressLeft();
              break;

            case 'Right':
              if (this.isRightShow) this.onPressRight();
              break;

            case 'Space':
              if (this.isCenterShow) this.onPressCenter();
              break;

            case 'W':
              if (this.isUpShow) this.onPressUp();
              break;

            case 'A':
              if (this.isLeftShow) this.onPressLeft();
              break;

            case 'S':
              if (this.isDownShow) this.onPressDown();
              break;

            case 'D':
              if (this.isRightShow) this.onPressRight();
              break;
          }
        };

        _proto.onPressUp = function onPressUp() {
          Logger.info("onPressUp");
          AudioManager.Instance.playSound(SoundName.EFFECT_CLICK); // SoundMgr.Instance.play_effect(SoundName.EFFECT_CLICK);

          this.hideGuideAni();
          EventMgr.Instance.Emit(GameEnum.EventPlayerPressedUp, null);
        };

        _proto.onPressDown = function onPressDown() {
          Logger.info("onPressDown");
          AudioManager.Instance.playSound(SoundName.EFFECT_CLICK); // SoundMgr.Instance.play_effect(SoundName.EFFECT_CLICK);

          this.hideGuideAni();
          EventMgr.Instance.Emit(GameEnum.EventPlayerPressedDown, null);
        };

        _proto.onPressLeft = function onPressLeft() {
          Logger.info("onPressLeft");
          AudioManager.Instance.playSound(SoundName.EFFECT_CLICK); // SoundMgr.Instance.play_effect(SoundName.EFFECT_CLICK);

          this.hideGuideAni();
          EventMgr.Instance.Emit(GameEnum.EventPlayerPressedLeft, null);
        };

        _proto.onPressRight = function onPressRight() {
          Logger.info("onPressRight");
          AudioManager.Instance.playSound(SoundName.EFFECT_CLICK); // SoundMgr.Instance.play_effect(SoundName.EFFECT_CLICK);

          this.hideGuideAni();
          EventMgr.Instance.Emit(GameEnum.EventPlayerPressedRight, null);
        };

        _proto.onPressCenter = function onPressCenter() {
          // 加赛逻辑
          Logger.info("加赛逻辑 onPressCenter");
          this.hideGuideAni();
          this.overTimeRunning();
        };

        return PCBottomUI_Ctrl;
      }(UICtrl), _temp)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/Decimal.ts", ['cc', './_rollupPluginModLoBabelHelpers.js'], function (exports) {
  'use strict';

  var cclegacy, _createClass, _defineProperty;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      _createClass = module.createClass;
      _defineProperty = module.defineProperty;
    }],
    execute: function () {
      cclegacy._RF.push({}, "69a5eZjbCxL/bID8lKEZ3Bj", "Decimal", undefined);

      var padEnd = function padEnd(string, maxLength, fillString) {
        if (string == null || maxLength == null) {
          return string;
        }

        var result = String(string);
        var targetLen = typeof maxLength === 'number' ? maxLength : parseInt(maxLength, 10);

        if (isNaN(targetLen) || !isFinite(targetLen)) {
          return result;
        }

        var length = result.length;

        if (length >= targetLen) {
          return result;
        }

        var filled = fillString == null ? '' : String(fillString);

        if (filled === '') {
          filled = ' ';
        }

        var fillLen = targetLen - length;

        while (filled.length < fillLen) {
          filled += filled;
        }

        var truncated = filled.length > fillLen ? filled.substr(0, fillLen) : filled;
        return result + truncated;
      }; // For example: if two exponents are more than 17 apart,
      // consider adding them together pointless, just return the larger one


      var MAX_SIGNIFICANT_DIGITS = 17; // Highest value you can safely put here is Number.MAX_SAFE_INTEGER-MAX_SIGNIFICANT_DIGITS

      var EXP_LIMIT = 9e15; // The largest exponent that can appear in a Number, though not all mantissas are valid here.

      var NUMBER_EXP_MAX = 308; // The smallest exponent that can appear in a Number, though not all mantissas are valid here.

      var NUMBER_EXP_MIN = -324; // Tolerance which is used for Number conversion to compensate floating-point error.

      var ROUND_TOLERANCE = 1e-10;

      var powerOf10 = function () {
        // We need this lookup table because Math.pow(10, exponent)
        // when exponent's absolute value is large is slightly inaccurate.
        // You can fix it with the power of math... or just make a lookup table.
        // Faster AND simpler
        var powersOf10 = [];

        for (var i = NUMBER_EXP_MIN + 1; i <= NUMBER_EXP_MAX; i++) {
          powersOf10.push(Number("1e" + i));
        }

        var indexOf0InPowersOf10 = 323;
        return function (power) {
          return powersOf10[power + indexOf0InPowersOf10];
        };
      }();

      var D = function D(value) {
        return value instanceof Decimal ? value : new Decimal(value);
      };

      var ME = function ME(mantissa, exponent) {
        return new Decimal().fromMantissaExponent(mantissa, exponent);
      };

      var ME_NN = function ME_NN(mantissa, exponent) {
        return new Decimal().fromMantissaExponent_noNormalize(mantissa, exponent);
      };

      function _affordGeometricSeries(resourcesAvailable, priceStart, priceRatio, currentOwned) {
        var actualStart = priceStart.mul(priceRatio.pow(currentOwned));
        return Decimal.floor(resourcesAvailable.div(actualStart).mul(priceRatio.sub(1)).add(1).log10() / priceRatio.log10());
      }

      function _sumGeometricSeries(numItems, priceStart, priceRatio, currentOwned) {
        return priceStart.mul(priceRatio.pow(currentOwned)).mul(Decimal.sub(1, priceRatio.pow(numItems))).div(Decimal.sub(1, priceRatio));
      }

      function _affordArithmeticSeries(resourcesAvailable, priceStart, priceAdd, currentOwned) {
        // n = (-(a-d/2) + sqrt((a-d/2)^2+2dS))/d
        // where a is actualStart, d is priceAdd and S is resourcesAvailable
        // then floor it and you're done!
        var actualStart = priceStart.add(currentOwned.mul(priceAdd));
        var b = actualStart.sub(priceAdd.div(2));
        var b2 = b.pow(2);
        return b.neg().add(b2.add(priceAdd.mul(resourcesAvailable).mul(2)).sqrt()).div(priceAdd).floor();
      }

      function _sumArithmeticSeries(numItems, priceStart, priceAdd, currentOwned) {
        var actualStart = priceStart.add(currentOwned.mul(priceAdd)); // (n/2)*(2*a+(n-1)*d)

        return numItems.div(2).mul(actualStart.mul(2).plus(numItems.sub(1).mul(priceAdd)));
      }

      function _efficiencyOfPurchase(cost, currentRpS, deltaRpS) {
        return cost.div(currentRpS).add(cost.div(deltaRpS));
      }
      /**
       * The Decimal's value is simply mantissa * 10^exponent.
       */


      var Decimal = exports('default', /*#__PURE__*/function () {
        Decimal.fromMantissaExponent = function fromMantissaExponent(mantissa, exponent) {
          return new Decimal().fromMantissaExponent(mantissa, exponent);
        };

        Decimal.fromMantissaExponent_noNormalize = function fromMantissaExponent_noNormalize(mantissa, exponent) {
          return new Decimal().fromMantissaExponent_noNormalize(mantissa, exponent);
        };

        Decimal.fromDecimal = function fromDecimal(value) {
          return new Decimal().fromDecimal(value);
        };

        Decimal.fromNumber = function fromNumber(value) {
          return new Decimal().fromNumber(value);
        };

        Decimal.fromString = function fromString(value) {
          return new Decimal().fromString(value);
        };

        Decimal.fromValue = function fromValue(value) {
          return new Decimal().fromValue(value);
        };

        Decimal.fromValue_noAlloc = function fromValue_noAlloc(value) {
          return value instanceof Decimal ? value : new Decimal(value);
        };

        Decimal.abs = function abs(value) {
          return D(value).abs();
        };

        Decimal.neg = function neg(value) {
          return D(value).neg();
        };

        Decimal.negate = function negate(value) {
          return D(value).neg();
        };

        Decimal.negated = function negated(value) {
          return D(value).neg();
        };

        Decimal.sign = function sign(value) {
          return D(value).sign();
        };

        Decimal.sgn = function sgn(value) {
          return D(value).sign();
        };

        Decimal.round = function round(value) {
          return D(value).round();
        };

        Decimal.floor = function floor(value) {
          return D(value).floor();
        };

        Decimal.ceil = function ceil(value) {
          return D(value).ceil();
        };

        Decimal.trunc = function trunc(value) {
          return D(value).trunc();
        };

        Decimal.add = function add(value, other) {
          return D(value).add(other);
        };

        Decimal.plus = function plus(value, other) {
          return D(value).add(other);
        };

        Decimal.sub = function sub(value, other) {
          return D(value).sub(other);
        };

        Decimal.subtract = function subtract(value, other) {
          return D(value).sub(other);
        };

        Decimal.minus = function minus(value, other) {
          return D(value).sub(other);
        };

        Decimal.mul = function mul(value, other) {
          return D(value).mul(other);
        };

        Decimal.multiply = function multiply(value, other) {
          return D(value).mul(other);
        };

        Decimal.times = function times(value, other) {
          return D(value).mul(other);
        };

        Decimal.div = function div(value, other) {
          return D(value).div(other);
        };

        Decimal.divide = function divide(value, other) {
          return D(value).div(other);
        };

        Decimal.recip = function recip(value) {
          return D(value).recip();
        };

        Decimal.reciprocal = function reciprocal(value) {
          return D(value).recip();
        };

        Decimal.reciprocate = function reciprocate(value) {
          return D(value).reciprocate();
        };

        Decimal.cmp = function cmp(value, other) {
          return D(value).cmp(other);
        };

        Decimal.compare = function compare(value, other) {
          return D(value).cmp(other);
        };

        Decimal.eq = function eq(value, other) {
          return D(value).eq(other);
        };

        Decimal.equals = function equals(value, other) {
          return D(value).eq(other);
        };

        Decimal.neq = function neq(value, other) {
          return D(value).neq(other);
        };

        Decimal.notEquals = function notEquals(value, other) {
          return D(value).notEquals(other);
        };

        Decimal.lt = function lt(value, other) {
          return D(value).lt(other);
        };

        Decimal.lte = function lte(value, other) {
          return D(value).lte(other);
        };

        Decimal.gt = function gt(value, other) {
          return D(value).gt(other);
        };

        Decimal.gte = function gte(value, other) {
          return D(value).gte(other);
        };

        Decimal.max = function max(value, other) {
          return D(value).max(other);
        };

        Decimal.min = function min(value, other) {
          return D(value).min(other);
        };

        Decimal.clamp = function clamp(value, min, max) {
          return D(value).clamp(min, max);
        };

        Decimal.clampMin = function clampMin(value, min) {
          return D(value).clampMin(min);
        };

        Decimal.clampMax = function clampMax(value, max) {
          return D(value).clampMax(max);
        };

        Decimal.cmp_tolerance = function cmp_tolerance(value, other, tolerance) {
          return D(value).cmp_tolerance(other, tolerance);
        };

        Decimal.compare_tolerance = function compare_tolerance(value, other, tolerance) {
          return D(value).cmp_tolerance(other, tolerance);
        };

        Decimal.eq_tolerance = function eq_tolerance(value, other, tolerance) {
          return D(value).eq_tolerance(other, tolerance);
        };

        Decimal.equals_tolerance = function equals_tolerance(value, other, tolerance) {
          return D(value).eq_tolerance(other, tolerance);
        };

        Decimal.neq_tolerance = function neq_tolerance(value, other, tolerance) {
          return D(value).neq_tolerance(other, tolerance);
        };

        Decimal.notEquals_tolerance = function notEquals_tolerance(value, other, tolerance) {
          return D(value).notEquals_tolerance(other, tolerance);
        };

        Decimal.lt_tolerance = function lt_tolerance(value, other, tolerance) {
          return D(value).lt_tolerance(other, tolerance);
        };

        Decimal.lte_tolerance = function lte_tolerance(value, other, tolerance) {
          return D(value).lte_tolerance(other, tolerance);
        };

        Decimal.gt_tolerance = function gt_tolerance(value, other, tolerance) {
          return D(value).gt_tolerance(other, tolerance);
        };

        Decimal.gte_tolerance = function gte_tolerance(value, other, tolerance) {
          return D(value).gte_tolerance(other, tolerance);
        };

        Decimal.log10 = function log10(value) {
          return D(value).log10();
        };

        Decimal.absLog10 = function absLog10(value) {
          return D(value).absLog10();
        };

        Decimal.pLog10 = function pLog10(value) {
          return D(value).pLog10();
        };

        Decimal.log = function log(value, base) {
          return D(value).log(base);
        };

        Decimal.log2 = function log2(value) {
          return D(value).log2();
        };

        Decimal.ln = function ln(value) {
          return D(value).ln();
        };

        Decimal.logarithm = function logarithm(value, base) {
          return D(value).logarithm(base);
        };

        Decimal.pow10 = function pow10(value) {
          if (Number.isInteger(value)) {
            return ME_NN(1, value);
          }

          return ME(Math.pow(10, value % 1), Math.trunc(value));
        };

        Decimal.pow = function pow(value, other) {
          // Fast track: 10^integer
          if (typeof value === "number" && value === 10 && typeof other === "number" && Number.isInteger(other)) {
            return ME_NN(1, other);
          }

          return D(value).pow(other);
        };

        Decimal.exp = function exp(value) {
          return D(value).exp();
        };

        Decimal.sqr = function sqr(value) {
          return D(value).sqr();
        };

        Decimal.sqrt = function sqrt(value) {
          return D(value).sqrt();
        };

        Decimal.cube = function cube(value) {
          return D(value).cube();
        };

        Decimal.cbrt = function cbrt(value) {
          return D(value).cbrt();
        };

        Decimal.dp = function dp(value) {
          return D(value).dp();
        };

        Decimal.decimalPlaces = function decimalPlaces(value) {
          return D(value).dp();
        }
        /**
         * If you're willing to spend 'resourcesAvailable' and want to buy something
         * with exponentially increasing cost each purchase (start at priceStart,
         * multiply by priceRatio, already own currentOwned), how much of it can you buy?
         * Adapted from Trimps source code.
         */
        ;

        Decimal.affordGeometricSeries = function affordGeometricSeries(resourcesAvailable, priceStart, priceRatio, currentOwned) {
          return _affordGeometricSeries(D(resourcesAvailable), D(priceStart), D(priceRatio), currentOwned);
        }
        /**
         * How much resource would it cost to buy (numItems) items if you already have currentOwned,
         * the initial price is priceStart and it multiplies by priceRatio each purchase?
         */
        ;

        Decimal.sumGeometricSeries = function sumGeometricSeries(numItems, priceStart, priceRatio, currentOwned) {
          return _sumGeometricSeries(numItems, D(priceStart), D(priceRatio), currentOwned);
        }
        /**
         * If you're willing to spend 'resourcesAvailable' and want to buy something with additively
         * increasing cost each purchase (start at priceStart, add by priceAdd, already own currentOwned),
         * how much of it can you buy?
         */
        ;

        Decimal.affordArithmeticSeries = function affordArithmeticSeries(resourcesAvailable, priceStart, priceAdd, currentOwned) {
          return _affordArithmeticSeries(D(resourcesAvailable), D(priceStart), D(priceAdd), D(currentOwned));
        }
        /**
         * How much resource would it cost to buy (numItems) items if you already have currentOwned,
         * the initial price is priceStart and it adds priceAdd each purchase?
         * Adapted from http://www.mathwords.com/a/arithmetic_series.htm
         */
        ;

        Decimal.sumArithmeticSeries = function sumArithmeticSeries(numItems, priceStart, priceAdd, currentOwned) {
          return _sumArithmeticSeries(D(numItems), D(priceStart), D(priceAdd), D(currentOwned));
        }
        /**
         * When comparing two purchases that cost (resource) and increase your resource/sec by (deltaRpS),
         * the lowest efficiency score is the better one to purchase.
         * From Frozen Cookies:
         * http://cookieclicker.wikia.com/wiki/Frozen_Cookies_(JavaScript_Add-on)#Efficiency.3F_What.27s_that.3F
         */
        ;

        Decimal.efficiencyOfPurchase = function efficiencyOfPurchase(cost, currentRpS, deltaRpS) {
          return _efficiencyOfPurchase(D(cost), D(currentRpS), D(deltaRpS));
        };

        Decimal.randomDecimalForTesting = function randomDecimalForTesting(absMaxExponent) {
          // NOTE: This doesn't follow any kind of sane random distribution, so use this for testing purposes only.
          // 5% of the time, have a mantissa of 0
          if (Math.random() * 20 < 1) {
            return ME_NN(0, 0);
          }

          var mantissa = Math.random() * 10; // 10% of the time, have a simple mantissa

          if (Math.random() * 10 < 1) {
            mantissa = Math.round(mantissa);
          }

          mantissa *= Math.sign(Math.random() * 2 - 1);
          var exponent = Math.floor(Math.random() * absMaxExponent * 2) - absMaxExponent;
          return ME(mantissa, exponent);
          /*
            Examples:
             randomly test pow:
             var a = Decimal.randomDecimalForTesting(1000);
            var pow = Math.random()*20-10;
            if (Math.random()*2 < 1) { pow = Math.round(pow); }
            var result = Decimal.pow(a, pow);
            ["(" + a.toString() + ")^" + pow.toString(), result.toString()]
             randomly test add:
             var a = Decimal.randomDecimalForTesting(1000);
            var b = Decimal.randomDecimalForTesting(17);
            var c = a.mul(b);
            var result = a.add(c);
            [a.toString() + "+" + c.toString(), result.toString()]
          */
        }
        /**
         * A number (double) with absolute value between [1, 10) OR exactly 0.
         * If mantissa is ever 10 or greater, it should be normalized
         * (divide by 10 and add 1 to exponent until it is less than 10,
         * or multiply by 10 and subtract 1 from exponent until it is 1 or greater).
         * Infinity/-Infinity/NaN will cause bad things to happen.
         */
        ;

        function Decimal(value) {
          _defineProperty(this, "mantissa", NaN);

          _defineProperty(this, "exponent", NaN);

          if (value === undefined) {
            this.m = 0;
            this.e = 0;
          } else if (value instanceof Decimal) {
            this.fromDecimal(value);
          } else if (typeof value === "number") {
            this.fromNumber(value);
          } else {
            this.fromString(value);
          }
        }
        /**
         * When mantissa is very denormalized, use this to normalize much faster.
         */


        var _proto = Decimal.prototype;

        _proto.normalize = function normalize() {
          if (this.m >= 1 && this.m < 10) {
            return this;
          } // TODO: I'm worried about mantissa being negative 0 here which is why I set it again, but it may never matter


          if (this.m === 0) {
            this.m = 0;
            this.e = 0;
            return this;
          }

          var tempExponent = Math.floor(Math.log10(Math.abs(this.m)));
          this.m = tempExponent === NUMBER_EXP_MIN ? this.m * 10 / 1e-323 : this.m / powerOf10(tempExponent);
          this.e += tempExponent;
          return this;
        };

        _proto.fromMantissaExponent = function fromMantissaExponent(mantissa, exponent) {
          // SAFETY: don't let in non-numbers
          if (!isFinite(mantissa) || !isFinite(exponent)) {
            mantissa = Number.NaN;
            exponent = Number.NaN;
            return this;
          }

          this.m = mantissa;
          this.e = exponent; // Non-normalized mantissas can easily get here, so this is mandatory.

          this.normalize();
          return this;
        }
        /**
         * Well, you know what you're doing!
         */
        ;

        _proto.fromMantissaExponent_noNormalize = function fromMantissaExponent_noNormalize(mantissa, exponent) {
          this.m = mantissa;
          this.e = exponent;
          return this;
        };

        _proto.fromDecimal = function fromDecimal(value) {
          this.m = value.m;
          this.e = value.e;
          return this;
        };

        _proto.fromNumber = function fromNumber(value) {
          // SAFETY: Handle Infinity and NaN in a somewhat meaningful way.
          if (isNaN(value)) {
            this.m = Number.NaN;
            this.e = Number.NaN;
          } else if (value === Number.POSITIVE_INFINITY) {
            this.m = 1;
            this.e = EXP_LIMIT;
          } else if (value === Number.NEGATIVE_INFINITY) {
            this.m = -1;
            this.e = EXP_LIMIT;
          } else if (value === 0) {
            this.m = 0;
            this.e = 0;
          } else {
            this.e = Math.floor(Math.log10(Math.abs(value))); // SAFETY: handle 5e-324, -5e-324 separately

            this.m = this.e === NUMBER_EXP_MIN ? value * 10 / 1e-323 : value / powerOf10(this.e); // SAFETY: Prevent weirdness.

            this.normalize();
          }

          return this;
        };

        _proto.fromString = function fromString(value) {
          if (value.indexOf("e") !== -1) {
            var parts = value.split("e");
            this.m = parseFloat(parts[0]);
            this.e = parseFloat(parts[1]); // Non-normalized mantissas can easily get here, so this is mandatory.

            this.normalize();
          } else if (value === "NaN") {
            this.m = Number.NaN;
            this.e = Number.NaN;
          } else {
            this.fromNumber(parseFloat(value));

            if (isNaN(this.m)) {
              throw Error("[DecimalError] Invalid argument: " + value);
            }
          }

          return this;
        };

        _proto.fromValue = function fromValue(value) {
          if (value instanceof Decimal) {
            return this.fromDecimal(value);
          }

          if (typeof value === "number") {
            return this.fromNumber(value);
          }

          if (typeof value === "string") {
            return this.fromString(value);
          }

          this.m = 0;
          this.e = 0;
          return this;
        };

        _proto.toNumber = function toNumber() {
          // Problem: new Decimal(116).toNumber() returns 115.99999999999999.
          // TODO: How to fix in general case? It's clear that if toNumber() is
          //  VERY close to an integer, we want exactly the integer.
          //  But it's not clear how to specifically write that.
          //  So I'll just settle with 'exponent >= 0 and difference between rounded
          //  and not rounded < 1e-9' as a quick fix.
          // var result = this.m*Math.pow(10, this.e);
          if (!isFinite(this.e)) {
            return Number.NaN;
          }

          if (this.e > NUMBER_EXP_MAX) {
            return this.m > 0 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
          }

          if (this.e < NUMBER_EXP_MIN) {
            return 0;
          } // SAFETY: again, handle 5e-324, -5e-324 separately


          if (this.e === NUMBER_EXP_MIN) {
            return this.m > 0 ? 5e-324 : -5e-324;
          }

          var result = this.m * powerOf10(this.e);

          if (!isFinite(result) || this.e < 0) {
            return result;
          }

          var resultRounded = Math.round(result);

          if (Math.abs(resultRounded - result) < ROUND_TOLERANCE) {
            return resultRounded;
          }

          return result;
        };

        _proto.mantissaWithDecimalPlaces = function mantissaWithDecimalPlaces(places) {
          // https://stackoverflow.com/a/37425022
          if (isNaN(this.m) || isNaN(this.e)) {
            return Number.NaN;
          }

          if (this.m === 0) {
            return 0;
          }

          var len = places + 1;
          var numDigits = Math.ceil(Math.log10(Math.abs(this.m)));
          var rounded = Math.round(this.m * Math.pow(10, len - numDigits)) * Math.pow(10, numDigits - len);
          return parseFloat(rounded.toFixed(Math.max(len - numDigits, 0)));
        };

        _proto.toString = function toString() {
          if (isNaN(this.m) || isNaN(this.e)) {
            return "NaN";
          }

          if (this.e >= EXP_LIMIT) {
            return this.m > 0 ? "Infinity" : "-Infinity";
          }

          if (this.e <= -EXP_LIMIT || this.m === 0) {
            return "0";
          }

          if (this.e < 21 && this.e > -7) {
            return this.toNumber().toString();
          }

          return this.m + "e" + (this.e >= 0 ? "+" : "") + this.e;
        };

        _proto.toExponential = function toExponential(places) {
          // https://stackoverflow.com/a/37425022
          // TODO: Some unfixed cases:
          //  new Decimal("1.2345e-999").toExponential()
          //  "1.23450000000000015e-999"
          //  new Decimal("1e-999").toExponential()
          //  "1.000000000000000000e-999"
          // TBH I'm tempted to just say it's a feature.
          // If you're doing pretty formatting then why don't you know how many decimal places you want...?
          if (isNaN(this.m) || isNaN(this.e)) {
            return "NaN";
          }

          if (this.e >= EXP_LIMIT) {
            return this.m > 0 ? "Infinity" : "-Infinity";
          }

          if (this.e <= -EXP_LIMIT || this.m === 0) {
            return "0" + (places > 0 ? padEnd(".", places + 1, "0") : "") + "e+0";
          } // two cases:
          // 1) exponent is < 308 and > -324: use basic toFixed
          // 2) everything else: we have to do it ourselves!


          if (this.e > NUMBER_EXP_MIN && this.e < NUMBER_EXP_MAX) {
            return this.toNumber().toExponential(places);
          }

          if (!isFinite(places)) {
            places = MAX_SIGNIFICANT_DIGITS;
          }

          var len = places + 1;
          var numDigits = Math.max(1, Math.ceil(Math.log10(Math.abs(this.m))));
          var rounded = Math.round(this.m * Math.pow(10, len - numDigits)) * Math.pow(10, numDigits - len);
          return rounded.toFixed(Math.max(len - numDigits, 0)) + "e" + (this.e >= 0 ? "+" : "") + this.e;
        };

        _proto.toFixed = function toFixed(places) {
          if (isNaN(this.m) || isNaN(this.e)) {
            return "NaN";
          }

          if (this.e >= EXP_LIMIT) {
            return this.m > 0 ? "Infinity" : "-Infinity";
          }

          if (this.e <= -EXP_LIMIT || this.m === 0) {
            return "0" + (places > 0 ? padEnd(".", places + 1, "0") : "");
          } // two cases:
          // 1) exponent is 17 or greater: just print out mantissa with the appropriate number of zeroes after it
          // 2) exponent is 16 or less: use basic toFixed
          // if (this.e >= MAX_SIGNIFICANT_DIGITS) {
          //   return this.m.toString()
          //     .replace(".", "")
          //     .padEnd(this.e + 1, "0") + (places > 0 ? padEnd(".", places + 1, "0") : "");
          // }


          return this.toNumber().toFixed(places);
        };

        _proto.toPrecision = function toPrecision(places) {
          if (this.e <= -7) {
            return this.toExponential(places - 1);
          }

          if (places > this.e) {
            return this.toFixed(places - this.e - 1);
          }

          return this.toExponential(places - 1);
        };

        _proto.valueOf = function valueOf() {
          return this.toString();
        };

        _proto.toJSON = function toJSON() {
          return this.toString();
        };

        _proto.toStringWithDecimalPlaces = function toStringWithDecimalPlaces(places) {
          return this.toExponential(places);
        };

        _proto.abs = function abs() {
          return ME_NN(Math.abs(this.m), this.e);
        };

        _proto.neg = function neg() {
          return ME_NN(-this.m, this.e);
        };

        _proto.negate = function negate() {
          return this.neg();
        };

        _proto.negated = function negated() {
          return this.neg();
        };

        _proto.sign = function sign() {
          return Math.sign(this.m);
        };

        _proto.sgn = function sgn() {
          return this.sign();
        };

        _proto.round = function round() {
          if (this.e < -1) {
            return new Decimal(0);
          }

          if (this.e < MAX_SIGNIFICANT_DIGITS) {
            return new Decimal(Math.round(this.toNumber()));
          }

          return this;
        };

        _proto.floor = function floor() {
          if (this.e < -1) {
            return Math.sign(this.m) >= 0 ? new Decimal(0) : new Decimal(-1);
          }

          if (this.e < MAX_SIGNIFICANT_DIGITS) {
            return new Decimal(Math.floor(this.toNumber()));
          }

          return this;
        };

        _proto.ceil = function ceil() {
          if (this.e < -1) {
            return Math.sign(this.m) > 0 ? new Decimal(1) : new Decimal(0);
          }

          if (this.e < MAX_SIGNIFICANT_DIGITS) {
            return new Decimal(Math.ceil(this.toNumber()));
          }

          return this;
        };

        _proto.trunc = function trunc() {
          if (this.e < 0) {
            return new Decimal(0);
          }

          if (this.e < MAX_SIGNIFICANT_DIGITS) {
            return new Decimal(Math.trunc(this.toNumber()));
          }

          return this;
        };

        _proto.add = function add(value) {
          // figure out which is bigger, shrink the mantissa of the smaller
          // by the difference in exponents, add mantissas, normalize and return
          // TODO: Optimizations and simplification may be possible, see https://github.com/Patashu/break_infinity.js/issues/8
          var decimal = D(value);

          if (this.m === 0) {
            return decimal;
          }

          if (decimal.m === 0) {
            return this;
          }

          var biggerDecimal;
          var smallerDecimal;

          if (this.e >= decimal.e) {
            biggerDecimal = this;
            smallerDecimal = decimal;
          } else {
            biggerDecimal = decimal;
            smallerDecimal = this;
          }

          if (biggerDecimal.e - smallerDecimal.e > MAX_SIGNIFICANT_DIGITS) {
            return biggerDecimal;
          } // Have to do this because adding numbers that were once integers but scaled down is imprecise.
          // Example: 299 + 18


          return ME(Math.round(1e14 * biggerDecimal.m + 1e14 * smallerDecimal.m * powerOf10(smallerDecimal.e - biggerDecimal.e)), biggerDecimal.e - 14);
        };

        _proto.plus = function plus(value) {
          return this.add(value);
        };

        _proto.sub = function sub(value) {
          return this.add(D(value).neg());
        };

        _proto.subtract = function subtract(value) {
          return this.sub(value);
        };

        _proto.minus = function minus(value) {
          return this.sub(value);
        };

        _proto.mul = function mul(value) {
          // This version avoids an extra conversion to Decimal, if possible. Since the
          // mantissa is -10...10, any number short of MAX/10 can be safely multiplied in
          if (typeof value === "number") {
            if (value < 1e307 && value > -1e307) {
              return ME(this.m * value, this.e);
            } // If the value is larger than 1e307, we can divide that out of mantissa (since it's
            // greater than 1, it won't underflow)


            return ME(this.m * 1e-307 * value, this.e + 307);
          }

          var decimal = typeof value === "string" ? new Decimal(value) : value;
          return ME(this.m * decimal.m, this.e + decimal.e);
        };

        _proto.multiply = function multiply(value) {
          return this.mul(value);
        };

        _proto.times = function times(value) {
          return this.mul(value);
        };

        _proto.div = function div(value) {
          return this.mul(D(value).recip());
        };

        _proto.divide = function divide(value) {
          return this.div(value);
        };

        _proto.divideBy = function divideBy(value) {
          return this.div(value);
        };

        _proto.dividedBy = function dividedBy(value) {
          return this.div(value);
        };

        _proto.recip = function recip() {
          return ME(1 / this.m, -this.e);
        };

        _proto.reciprocal = function reciprocal() {
          return this.recip();
        };

        _proto.reciprocate = function reciprocate() {
          return this.recip();
        }
        /**
         * -1 for less than value, 0 for equals value, 1 for greater than value
         */
        ;

        _proto.cmp = function cmp(value) {
          var decimal = D(value); // TODO: sign(a-b) might be better? https://github.com/Patashu/break_infinity.js/issues/12

          /*
          from smallest to largest:
           -3e100
          -1e100
          -3e99
          -1e99
          -3e0
          -1e0
          -3e-99
          -1e-99
          -3e-100
          -1e-100
          0
          1e-100
          3e-100
          1e-99
          3e-99
          1e0
          3e0
          1e99
          3e99
          1e100
          3e100
           */

          if (this.m === 0) {
            if (decimal.m === 0) {
              return 0;
            }

            if (decimal.m < 0) {
              return 1;
            }

            if (decimal.m > 0) {
              return -1;
            }
          }

          if (decimal.m === 0) {
            if (this.m < 0) {
              return -1;
            }

            if (this.m > 0) {
              return 1;
            }
          }

          if (this.m > 0) {
            if (decimal.m < 0) {
              return 1;
            }

            if (this.e > decimal.e) {
              return 1;
            }

            if (this.e < decimal.e) {
              return -1;
            }

            if (this.m > decimal.m) {
              return 1;
            }

            if (this.m < decimal.m) {
              return -1;
            }

            return 0;
          }

          if (this.m < 0) {
            if (decimal.m > 0) {
              return -1;
            }

            if (this.e > decimal.e) {
              return -1;
            }

            if (this.e < decimal.e) {
              return 1;
            }

            if (this.m > decimal.m) {
              return 1;
            }

            if (this.m < decimal.m) {
              return -1;
            }

            return 0;
          }

          throw Error("Unreachable code");
        };

        _proto.compare = function compare(value) {
          return this.cmp(value);
        };

        _proto.eq = function eq(value) {
          var decimal = D(value);
          return this.e === decimal.e && this.m === decimal.m;
        };

        _proto.equals = function equals(value) {
          return this.eq(value);
        };

        _proto.neq = function neq(value) {
          return !this.eq(value);
        };

        _proto.notEquals = function notEquals(value) {
          return this.neq(value);
        };

        _proto.lt = function lt(value) {
          var decimal = D(value);

          if (this.m === 0) {
            return decimal.m > 0;
          }

          if (decimal.m === 0) {
            return this.m <= 0;
          }

          if (this.e === decimal.e) {
            return this.m < decimal.m;
          }

          if (this.m > 0) {
            return decimal.m > 0 && this.e < decimal.e;
          }

          return decimal.m > 0 || this.e > decimal.e;
        };

        _proto.lte = function lte(value) {
          return !this.gt(value);
        };

        _proto.gt = function gt(value) {
          var decimal = D(value);

          if (this.m === 0) {
            return decimal.m < 0;
          }

          if (decimal.m === 0) {
            return this.m > 0;
          }

          if (this.e === decimal.e) {
            return this.m > decimal.m;
          }

          if (this.m > 0) {
            return decimal.m < 0 || this.e > decimal.e;
          }

          return decimal.m < 0 && this.e < decimal.e;
        };

        _proto.gte = function gte(value) {
          return !this.lt(value);
        };

        _proto.max = function max(value) {
          var decimal = D(value);
          return this.lt(decimal) ? decimal : this;
        };

        _proto.min = function min(value) {
          var decimal = D(value);
          return this.gt(decimal) ? decimal : this;
        };

        _proto.clamp = function clamp(min, max) {
          return this.max(min).min(max);
        };

        _proto.clampMin = function clampMin(min) {
          return this.max(min);
        };

        _proto.clampMax = function clampMax(max) {
          return this.min(max);
        };

        _proto.cmp_tolerance = function cmp_tolerance(value, tolerance) {
          var decimal = D(value);
          return this.eq_tolerance(decimal, tolerance) ? 0 : this.cmp(decimal);
        };

        _proto.compare_tolerance = function compare_tolerance(value, tolerance) {
          return this.cmp_tolerance(value, tolerance);
        }
        /**
         * Tolerance is a relative tolerance, multiplied by the greater of the magnitudes of the two arguments.
         * For example, if you put in 1e-9, then any number closer to the
         * larger number than (larger number)*1e-9 will be considered equal.
         */
        ;

        _proto.eq_tolerance = function eq_tolerance(value, tolerance) {
          var decimal = D(value); // https://stackoverflow.com/a/33024979
          // return abs(a-b) <= tolerance * max(abs(a), abs(b))

          return Decimal.lte(this.sub(decimal).abs(), Decimal.max(this.abs(), decimal.abs()).mul(tolerance));
        };

        _proto.equals_tolerance = function equals_tolerance(value, tolerance) {
          return this.eq_tolerance(value, tolerance);
        };

        _proto.neq_tolerance = function neq_tolerance(value, tolerance) {
          return !this.eq_tolerance(value, tolerance);
        };

        _proto.notEquals_tolerance = function notEquals_tolerance(value, tolerance) {
          return this.neq_tolerance(value, tolerance);
        };

        _proto.lt_tolerance = function lt_tolerance(value, tolerance) {
          var decimal = D(value);
          return !this.eq_tolerance(decimal, tolerance) && this.lt(decimal);
        };

        _proto.lte_tolerance = function lte_tolerance(value, tolerance) {
          var decimal = D(value);
          return this.eq_tolerance(decimal, tolerance) || this.lt(decimal);
        };

        _proto.gt_tolerance = function gt_tolerance(value, tolerance) {
          var decimal = D(value);
          return !this.eq_tolerance(decimal, tolerance) && this.gt(decimal);
        };

        _proto.gte_tolerance = function gte_tolerance(value, tolerance) {
          var decimal = D(value);
          return this.eq_tolerance(decimal, tolerance) || this.gt(decimal);
        };

        _proto.log10 = function log10() {
          return this.e + Math.log10(this.m);
        };

        _proto.absLog10 = function absLog10() {
          return this.e + Math.log10(Math.abs(this.m));
        };

        _proto.pLog10 = function pLog10() {
          return this.m <= 0 || this.e < 0 ? 0 : this.log10();
        };

        _proto.log = function log(base) {
          // UN-SAFETY: Most incremental game cases are log(number := 1 or greater, base := 2 or greater).
          // We assume this to be true and thus only need to return a number, not a Decimal,
          // and don't do any other kind of error checking.
          return Math.LN10 / Math.log(base) * this.log10();
        };

        _proto.log2 = function log2() {
          return 3.32192809488736234787 * this.log10();
        };

        _proto.ln = function ln() {
          return 2.30258509299404568402 * this.log10();
        };

        _proto.logarithm = function logarithm(base) {
          return this.log(base);
        };

        _proto.pow = function pow(value) {
          // UN-SAFETY: Accuracy not guaranteed beyond ~9~11 decimal places.
          // TODO: Decimal.pow(new Decimal(0.5), 0); or Decimal.pow(new Decimal(1), -1);
          //  makes an exponent of -0! Is a negative zero ever a problem?
          var numberValue = value instanceof Decimal ? value.toNumber() : value; // TODO: Fast track seems about neutral for performance.
          //  It might become faster if an integer pow is implemented,
          //  or it might not be worth doing (see https://github.com/Patashu/break_infinity.js/issues/4 )
          // Fast track: If (this.e*value) is an integer and mantissa^value
          // fits in a Number, we can do a very fast method.

          var temp = this.e * numberValue;
          var newMantissa;

          if (Number.isSafeInteger(temp)) {
            newMantissa = Math.pow(this.m, numberValue);

            if (isFinite(newMantissa) && newMantissa !== 0) {
              return ME(newMantissa, temp);
            }
          } // Same speed and usually more accurate.


          var newExponent = Math.trunc(temp);
          var residue = temp - newExponent;
          newMantissa = Math.pow(10, numberValue * Math.log10(this.m) + residue);

          if (isFinite(newMantissa) && newMantissa !== 0) {
            return ME(newMantissa, newExponent);
          } // return Decimal.exp(value*this.ln());
          // UN-SAFETY: This should return NaN when mantissa is negative and value is non-integer.


          var result = Decimal.pow10(numberValue * this.absLog10()); // this is 2x faster and gives same values AFAIK

          if (this.sign() === -1 && numberValue % 2 === 1) {
            return result.neg();
          }

          return result;
        };

        _proto.pow_base = function pow_base(value) {
          return D(value).pow(this);
        };

        _proto.factorial = function factorial() {
          // Using Stirling's Approximation.
          // https://en.wikipedia.org/wiki/Stirling%27s_approximation#Versions_suitable_for_calculators
          var n = this.toNumber() + 1;
          return Decimal.pow(n / Math.E * Math.sqrt(n * Math.sinh(1 / n) + 1 / (810 * Math.pow(n, 6))), n).mul(Math.sqrt(2 * Math.PI / n));
        };

        _proto.exp = function exp() {
          var x = this.toNumber(); // Fast track: if -706 < this < 709, we can use regular exp.

          if (-706 < x && x < 709) {
            return Decimal.fromNumber(Math.exp(x));
          }

          return Decimal.pow(Math.E, x);
        };

        _proto.sqr = function sqr() {
          return ME(Math.pow(this.m, 2), this.e * 2);
        };

        _proto.sqrt = function sqrt() {
          if (this.m < 0) {
            return new Decimal(Number.NaN);
          }

          if (this.e % 2 !== 0) {
            return ME(Math.sqrt(this.m) * 3.16227766016838, Math.floor(this.e / 2));
          } // Mod of a negative number is negative, so != means '1 or -1'


          return ME(Math.sqrt(this.m), Math.floor(this.e / 2));
        };

        _proto.cube = function cube() {
          return ME(Math.pow(this.m, 3), this.e * 3);
        };

        _proto.cbrt = function cbrt() {
          var sign = 1;
          var mantissa = this.m;

          if (mantissa < 0) {
            sign = -1;
            mantissa = -mantissa;
          }

          var newMantissa = sign * Math.pow(mantissa, 1 / 3);
          var mod = this.e % 3;

          if (mod === 1 || mod === -1) {
            return ME(newMantissa * 2.1544346900318837, Math.floor(this.e / 3));
          }

          if (mod !== 0) {
            return ME(newMantissa * 4.6415888336127789, Math.floor(this.e / 3));
          } // mod != 0 at this point means 'mod == 2 || mod == -2'


          return ME(newMantissa, Math.floor(this.e / 3));
        } // Some hyperbolic trig functions that happen to be easy
        ;

        _proto.sinh = function sinh() {
          return this.exp().sub(this.negate().exp()).div(2);
        };

        _proto.cosh = function cosh() {
          return this.exp().add(this.negate().exp()).div(2);
        };

        _proto.tanh = function tanh() {
          return this.sinh().div(this.cosh());
        };

        _proto.asinh = function asinh() {
          return Decimal.ln(this.add(this.sqr().add(1).sqrt()));
        };

        _proto.acosh = function acosh() {
          return Decimal.ln(this.add(this.sqr().sub(1).sqrt()));
        };

        _proto.atanh = function atanh() {
          if (this.abs().gte(1)) {
            return Number.NaN;
          }

          return Decimal.ln(this.add(1).div(new Decimal(1).sub(this))) / 2;
        }
        /**
         * Joke function from Realm Grinder
         */
        ;

        _proto.ascensionPenalty = function ascensionPenalty(ascensions) {
          if (ascensions === 0) {
            return this;
          }

          return this.pow(Math.pow(10, -ascensions));
        }
        /**
         * Joke function from Cookie Clicker. It's 'egg'
         */
        ;

        _proto.egg = function egg() {
          return this.add(9);
        };

        _proto.lessThanOrEqualTo = function lessThanOrEqualTo(other) {
          return this.cmp(other) < 1;
        };

        _proto.lessThan = function lessThan(other) {
          return this.cmp(other) < 0;
        };

        _proto.greaterThanOrEqualTo = function greaterThanOrEqualTo(other) {
          return this.cmp(other) > -1;
        };

        _proto.greaterThan = function greaterThan(other) {
          return this.cmp(other) > 0;
        };

        _proto.decimalPlaces = function decimalPlaces() {
          return this.dp();
        };

        _proto.dp = function dp() {
          if (!isFinite(this.mantissa)) {
            return NaN;
          }

          if (this.exponent >= MAX_SIGNIFICANT_DIGITS) {
            return 0;
          }

          var mantissa = this.mantissa;
          var places = -this.exponent;
          var e = 1;

          while (Math.abs(Math.round(mantissa * e) / e - mantissa) > ROUND_TOLERANCE) {
            e *= 10;
            places++;
          }

          return places > 0 ? places : 0;
        };

        _createClass(Decimal, [{
          key: "m",
          get: function get() {
            return this.mantissa;
          },
          set: function set(value) {
            this.mantissa = value;
          }
        }, {
          key: "e",
          get: function get() {
            return this.exponent;
          },
          set: function set(value) {
            this.exponent = value;
          }
        }, {
          key: "s",
          get: function get() {
            return this.sign();
          },
          set: function set(value) {
            if (value === 0) {
              this.e = 0;
              this.m = 0;
              return;
            }

            if (this.sgn() !== value) {
              this.m = -this.m;
            }
          }
        }], [{
          key: "MAX_VALUE",
          get: function get() {
            return MAX_VALUE;
          }
        }, {
          key: "MIN_VALUE",
          get: function get() {
            return MIN_VALUE;
          }
        }, {
          key: "NUMBER_MAX_VALUE",
          get: function get() {
            return NUMBER_MAX_VALUE;
          }
        }, {
          key: "NUMBER_MIN_VALUE",
          get: function get() {
            return NUMBER_MIN_VALUE;
          }
        }]);

        return Decimal;
      }());
      var MAX_VALUE = ME_NN(1, EXP_LIMIT);
      var MIN_VALUE = ME_NN(1, -EXP_LIMIT);
      var NUMBER_MAX_VALUE = D(Number.MAX_VALUE);
      var NUMBER_MIN_VALUE = D(Number.MIN_VALUE);

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MyBoxCollider.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './ColliderBase.ts'], function (exports) {
  'use strict';

  var cclegacy, _inheritsLoose, ColliderBase;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      ColliderBase = module.ColliderBase;
    }],
    execute: function () {
      cclegacy._RF.push({}, "6bd48euTgpOzqZmBAdcK9Ru", "MyBoxCollider", undefined);
      /**
       * @Author: liubeizhang
       * @Date: 2021-08-23 10:46:00 
       * 方形碰撞体
       */


      var MyBoxCollider = exports('MyBoxCollider', /*#__PURE__*/function (_ColliderBase) {
        _inheritsLoose(MyBoxCollider, _ColliderBase);

        function MyBoxCollider(cfg) {
          var _this;

          _this = _ColliderBase.call(this) || this;
          _this.name = cfg.mName;
          _this.mPos = cfg.mPos;
          _this.mSize = cfg.mSize;
          _this.mDir[0] = cfg.mAxis[0];
          _this.mDir[1] = cfg.mAxis[1];
          _this.mDir[2] = cfg.mAxis[2];
          return _this;
        }

        var _proto = MyBoxCollider.prototype;

        _proto.DetectBoxContact = function DetectBoxContact(col, normal, bordersAdjust) {
          return false;
        };

        _proto.DetectSphereContact = function DetectSphereContact(col, normal, bordersAdjust) {
          return false;
        };

        return MyBoxCollider;
      }(ColliderBase));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MainUI_Ctrl.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './index.cjs.js', './index.cjs.mjs_cjs=&original=.js', './UIMgr.ts', './GameConstants.ts', './BridgeMgr.ts', './UserHeader_Ctrl.ts', './GameApp.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, SpriteFrame, game, macro, resources, Prefab, instantiate, Vec3, _applyDecoratedDescriptor, _inheritsLoose, _defineProperty, _assertThisInitialized, _initializerDefineProperty, _cjsExports, UICtrl, RoleType, RoundStatus, GridType, BridgeMgr, UserHeader_Ctrl, GameApp;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      SpriteFrame = module.SpriteFrame;
      game = module.game;
      macro = module.macro;
      resources = module.resources;
      Prefab = module.Prefab;
      instantiate = module.instantiate;
      Vec3 = module.Vec3;
    }, function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _defineProperty = module.defineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      _cjsExports = module.default;
    }, null, function (module) {
      UICtrl = module.UICtrl;
    }, function (module) {
      RoleType = module.RoleType;
      RoundStatus = module.RoundStatus;
      GridType = module.GridType;
    }, function (module) {
      BridgeMgr = module.BridgeMgr;
    }, function (module) {
      UserHeader_Ctrl = module.UserHeader_Ctrl;
    }, function (module) {
      GameApp = module.GameApp;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor, _temp;

      cclegacy._RF.push({}, "755c4ydO4VKxK0zG/QB3Gm6", "MainUI_Ctrl", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var Logger = _cjsExports.Logger;
      var // 注意修改类名
      MainUI_Ctrl = exports('MainUI_Ctrl', (_dec = ccclass("MainUI_Ctrl"), _dec2 = property({
        type: SpriteFrame
      }), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function (_UICtrl) {
        _inheritsLoose(MainUI_Ctrl, _UICtrl);

        function MainUI_Ctrl() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _UICtrl.call.apply(_UICtrl, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this), "bottom", null);

          _defineProperty(_assertThisInitialized(_this), "bottomCtrl", null);

          _initializerDefineProperty(_assertThisInitialized(_this), "headLogoSp", _descriptor, _assertThisInitialized(_this));

          _defineProperty(_assertThisInitialized(_this), "headerLeft", []);

          _defineProperty(_assertThisInitialized(_this), "headerRight", []);

          _defineProperty(_assertThisInitialized(_this), "headerLeftMap", new Map());

          _defineProperty(_assertThisInitialized(_this), "headerRightMap", new Map());

          _defineProperty(_assertThisInitialized(_this), "lastSoundUidArr", []);

          _defineProperty(_assertThisInitialized(_this), "soundUidArr", []);

          _defineProperty(_assertThisInitialized(_this), "pcOffsetSetted", false);

          _defineProperty(_assertThisInitialized(_this), "playerDesignWidth", 750);

          _defineProperty(_assertThisInitialized(_this), "pcPlayerDesignOffset", 80);

          _defineProperty(_assertThisInitialized(_this), "pcPlayerDesignBottomOffset", 80);

          return _this;
        }

        var _proto = MainUI_Ctrl.prototype;

        _proto.onLoad = function onLoad() {
          var _game$canvas;

          _UICtrl.prototype.onLoad.call(this); // 设置焦点


          (_game$canvas = game.canvas) === null || _game$canvas === void 0 ? void 0 : _game$canvas.focus();
          this.bottom = this.view["bottom"]; // this.bottom.removeAllChildren();

          this.headerLeft.push(this.view["head/LayoutLeft/Node1"]);
          this.headerLeft.push(this.view["head/LayoutLeft/Node2"]);
          this.headerLeft.push(this.view["head/LayoutLeft/Node3"]);
          this.headerLeft.push(this.view["head/LayoutLeft/Node4"]);
          this.headerRight.push(this.view["head/LayoutRight/Node5"]);
          this.headerRight.push(this.view["head/LayoutRight/Node6"]);
          this.headerRight.push(this.view["head/LayoutRight/Node7"]);
          this.headerRight.push(this.view["head/LayoutRight/Node8"]); //监听静音事件

          BridgeMgr.Instance.listenMicStatus(this.updateMute.bind(this)); //监听麦位音波

          BridgeMgr.Instance.listenTalkInfo(this.playSoundAni.bind(this));
        };

        _proto.updateMute = function updateMute(data) {
          Logger.info("bridge 开闭麦回调数据", data);

          for (var i = 0; i < data.length; i++) {
            var head = this.headerLeftMap.get(data[i].uid);
            if (!head) head = this.headerRightMap.get(data[i].uid);

            if (head) {
              var headCtrl = head.getComponent(UserHeader_Ctrl);

              if (headCtrl) {
                var isMute = !data[i].status;
                Logger.info("bridge 开闭麦回调值 ", isMute);
                headCtrl.updateHeadMute(isMute);
              }
            }
          }
        } //麦位音浪处理
        ;

        _proto.playSoundAni = function playSoundAni(res) {
          var _this2 = this;

          Logger.info("bridge 麦位音波回调数据", res); // 安卓为字符串 ios为对象
          // let soundData = res.data

          if (typeof res === 'string') res = JSON.parse(res);
          if (res.length < 1) return;

          if (res.length === 1) {
            // app端逻辑 or pc
            var soundUser = res[0];
            if (this.soundUidArr.indexOf(soundUser) === -1) this.soundUidArr.push(soundUser);
            this.handleSoundSingle(soundUser);
          } else if (res.length > 1) {
            // pc
            res.forEach(function (soundUser) {
              if (_this2.soundUidArr.indexOf(soundUser) === -1) _this2.soundUidArr.push(soundUser);

              _this2.handleSoundSingle(soundUser);
            });
          }

          this.schedule(this.soundScheduleCallback, 0.8, macro.REPEAT_FOREVER);
        };

        _proto.soundScheduleCallback = function soundScheduleCallback() {
          // 优化
          if (this.lastSoundUidArr.length === 0 && this.soundUidArr.length === 0) return;
          if (this.soundUidArr.length > 0) this.handleSound(this.soundUidArr);else this.handleSoundReset(); // Logger.info('soundUidArr', this.soundUidArr)
          // clear

          this.lastSoundUidArr = this.soundUidArr;
          this.soundUidArr = [];
        } // 音浪显示控制 - 单个
        ;

        _proto.handleSoundSingle = function handleSoundSingle(uid) {
          var head = this.headerLeftMap.get(uid);
          if (!head) head = this.headerRightMap.get(uid);

          if (head) {
            var headCtrl = head.getComponent(UserHeader_Ctrl);

            if (headCtrl) {
              headCtrl.updateTalkSound();
            }
          }
        } // 音浪显示控制 - 多个
        ;

        _proto.handleSound = function handleSound(uidArr) {
          for (var i = 0; i < uidArr.length; i++) {
            var head = this.headerLeftMap.get(uidArr[i]);
            if (!head) head = this.headerRightMap.get(uidArr[i]);

            if (head) {
              var headCtrl = head.getComponent(UserHeader_Ctrl);

              if (headCtrl) {
                headCtrl.updateTalkSound();
              }
            }
          }
        } // 音浪显示控制 - 重置
        ;

        _proto.handleSoundReset = function handleSoundReset() {
          this.headerLeftMap.forEach(function (head) {
            if (head) {
              var headCtrl = head.getComponent(UserHeader_Ctrl);

              if (headCtrl) {
                headCtrl.disableTalkSound();
              }
            }
          });
          this.headerRightMap.forEach(function (head) {
            if (head) {
              var headCtrl = head.getComponent(UserHeader_Ctrl);

              if (headCtrl) {
                headCtrl.disableTalkSound();
              }
            }
          });
        } // 通过uid获取到具体的头像node
        ;

        _proto.getHeaderPos = function getHeaderPos(outPos, uid) {
          var scoreNode = null;

          for (var i = 0; i < this.headerLeft.length; i++) {
            var header = this.headerLeft[i];
            var headerCtl = header.getComponent(UserHeader_Ctrl);

            if (headerCtl && headerCtl.uid == uid) {
              scoreNode = headerCtl.getUIStarPos(outPos);
              return scoreNode;
            }
          }

          for (var _i = 0; _i < this.headerRight.length; _i++) {
            var _header = this.headerRight[_i];

            var _headerCtl = _header.getComponent(UserHeader_Ctrl);

            if (_headerCtl && _headerCtl.uid == uid) {
              scoreNode = _headerCtl.getUIStarPos(outPos);
              return scoreNode;
            }
          }
        };

        _proto.initBottomUI = function initBottomUI(playerType, cb) {
          var _this3 = this; //基于不同的玩家创建不同的


          var operateUIPath = "";
          var compName = "";

          if (playerType == RoleType.PLAYER) {
            operateUIPath = "ui_prefabs/PlayerBottomUI";
            compName = "PlayerBottomUI_Ctrl";
          } else if (playerType == RoleType.AUDIENCE) {
            operateUIPath = "ui_prefabs/AudienceBottomUI";
            compName = "AudienceBottomUI_Ctrl";
          } else if (playerType == RoleType.PC_PLAYER) {
            operateUIPath = "ui_prefabs/PCBottomUI";
            compName = "PCBottomUI_Ctrl";
          }

          resources.preload(operateUIPath, Prefab);
          resources.load(operateUIPath, Prefab, function (err, prefab) {
            var operateUI = instantiate(prefab);
            operateUI.parent = _this3.bottom;
            _this3.bottomCtrl = operateUI.addComponent(compName);

            _this3.bottomCtrl.updateSnapshotUI();

            if (_cjsExports.Bridge.app.isYppPC) {
              //设置pc 2d UI基于app端的偏移量来设置
              var windowWidth = GameApp.Instance.data.w || document.body && document.body.clientWidth;

              var _widthScale = _this3.playerDesignWidth / windowWidth;

              Logger.info("bridge 该用户是主播，位移头像ui ", _this3.pcPlayerDesignOffset / _widthScale, " 位移底部ui ", _this3.pcPlayerDesignBottomOffset / _widthScale);

              _this3.updatePCOffset(_this3.pcPlayerDesignOffset / _widthScale, _this3.pcPlayerDesignBottomOffset / _widthScale);
            }

            if (cb) cb();
          });
        };

        _proto.updateGameSnapshotRespUI = function updateGameSnapshotRespUI(udata) {
          this.updateHeaderData(udata.leftDuel, udata.rightDuel);
          this.updateHeaderRoleUI(udata.mapInfo);
        };

        _proto.updateReEnterRespUI = function updateReEnterRespUI(udata) {
          this.updateHeaderData(udata.leftDuel, udata.rightDuel);
          this.updateHeaderRoleUI(udata.mapInfo);
        };

        _proto.updateGameStartUI = function updateGameStartUI(udata) {
          this.updateHeaderRoleUI(udata.mapInfo);
        };

        _proto.updateBottomCountDown = function updateBottomCountDown(udata) {
          if (udata.roundStatus == RoundStatus.IN_GAME) this.bottomCtrl.updateGameStartUI(udata);
        };

        _proto.updateLabel = function updateLabel(str) {
          this.bottomCtrl.updateLabel(str);
        } //更新用户头像标识
        ;

        _proto.updateHeaderRoleUI = function updateHeaderRoleUI(data) {
          if (!data) return;
          this.resetAllHeaderUI();

          for (var i = 0; i < data.length; i++) {
            if (data[i].type != GridType.ROLE) continue;
            var head = this.headerLeftMap.get(data[i].uid);
            if (!head) head = this.headerRightMap.get(data[i].uid);

            if (head) {
              var headCtrl = head.getComponent(UserHeader_Ctrl);

              if (headCtrl) {
                var name = "player" + data[i].roleId + "Tex" + data[i].skinId;
                var sp = this.getRoleUI(name);
                headCtrl.updateRoleUI(sp);
              }
            }
          }
        };

        _proto.getRoleUI = function getRoleUI(name) {
          var sp = null;
          this.headLogoSp.forEach(function (element) {
            if (element.name == name) {
              sp = element;
            }
          });
          return sp;
        };

        _proto.resetAllHeaderUI = function resetAllHeaderUI() {
          this.headerLeftMap.forEach(function (value, key) {
            var headCtrl = value.getComponent(UserHeader_Ctrl);

            if (headCtrl) {
              headCtrl.resetRoleUI();
            }
          });
          this.headerRightMap.forEach(function (value, key) {
            var headCtrl = value.getComponent(UserHeader_Ctrl);

            if (headCtrl) {
              headCtrl.resetRoleUI();
            }
          });
        };

        _proto.hideOperate = function hideOperate() {
          this.bottomCtrl && this.bottomCtrl.updateOperateBtnState(false, false, false, false, false);
        };

        _proto.updateUserOnlineState = function updateUserOnlineState(uid, state) {
          var header = this.headerLeftMap.get(uid);
          if (!header) header = this.headerRightMap.get(uid);
          header.updateState(state);
        } //更新用户头像数据
        ;

        _proto.updateHeaderData = function updateHeaderData(left, right) {
          this.headerLeftMap.clear();

          for (var i = 0; i < this.view["head/LayoutLeft"].children.length; i++) {
            var header = this.view["head/LayoutLeft"].children[i];
            var headerCtl = header.getComponent(UserHeader_Ctrl);
            if (!headerCtl) header.addComponent(UserHeader_Ctrl);
            headerCtl.updateHeaderData(left[i]);
            this.headerLeftMap.set(headerCtl.uid, headerCtl);
          }

          this.headerRightMap.clear();

          for (var _i2 = 0; _i2 < this.view["head/LayoutRight"].children.length; _i2++) {
            var _header2 = this.view["head/LayoutRight"].children[_i2];

            var _headerCtl2 = _header2.getComponent(UserHeader_Ctrl);

            if (!_headerCtl2) _header2.addComponent(UserHeader_Ctrl);

            _headerCtl2.updateHeaderData(right[_i2]);

            this.headerRightMap.set(_headerCtl2.uid, _headerCtl2);
          }
        };

        _proto.updatePCOffset = function updatePCOffset(headOffeset, bottomOffset) {
          var head = this.view["head"];
          var bottom = this.view["bottom"];
          head.setPosition(new Vec3(head.position.x, head.position.y - headOffeset, head.position.z));
          bottom.setPosition(new Vec3(bottom.position.x, bottom.position.y - bottomOffset, bottom.position.z));
          this.pcOffsetSetted = true;
        };

        _proto.slowDown = function slowDown(offsetIdx, settleData) {
          if (this.bottomCtrl.slowDown) this.bottomCtrl.slowDown(offsetIdx, settleData);
        };

        _proto.updateFinalRotate = function updateFinalRotate() {
          this.bottomCtrl.isFinalRotate = true;
        };

        _proto.onDestroy = function onDestroy() {
          this.unschedule(this.soundScheduleCallback);
        };

        return MainUI_Ctrl;
      }(UICtrl), _temp), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "headLogoSp", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _class2)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ResMgr.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './index.cjs.js', './index.cjs.mjs_cjs=&original=.js', './helper.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, AudioClip, Prefab, Material, SpriteAtlas, assetManager, resources, error, Component, _defineProperty, _applyDecoratedDescriptor, _inheritsLoose, _assertThisInitialized, _initializerDefineProperty, _cjsExports, loadTime;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      AudioClip = module.AudioClip;
      Prefab = module.Prefab;
      Material = module.Material;
      SpriteAtlas = module.SpriteAtlas;
      assetManager = module.assetManager;
      resources = module.resources;
      error = module.error;
      Component = module.Component;
    }, function (module) {
      _defineProperty = module.defineProperty;
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _assertThisInitialized = module.assertThisInitialized;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      _cjsExports = module.default;
    }, null, function (module) {
      loadTime = module.loadTime;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _class3, _temp;

      cclegacy._RF.push({}, "7b0e36PneJO7qswActWTnBE", "ResMgr", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var Logger = _cjsExports.Logger;
      var ResMgr = exports('ResMgr', (_dec = ccclass("ResMgr"), _dec2 = property([AudioClip]), _dec3 = property([Prefab]), _dec4 = property([Prefab]), _dec5 = property([Prefab]), _dec6 = property([Material]), _dec7 = property([SpriteAtlas]), _dec(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(ResMgr, _Component);

        function ResMgr() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this), "progressFunc", null);

          _defineProperty(_assertThisInitialized(_this), "endFunc", null);

          _defineProperty(_assertThisInitialized(_this), "total", 0);

          _defineProperty(_assertThisInitialized(_this), "now", 0);

          _defineProperty(_assertThisInitialized(_this), "prefabDepRefCount", {});

          _initializerDefineProperty(_assertThisInitialized(_this), "preloadSounds", _descriptor, _assertThisInitialized(_this));

          _initializerDefineProperty(_assertThisInitialized(_this), "preloadScenes_3D", _descriptor2, _assertThisInitialized(_this));

          _initializerDefineProperty(_assertThisInitialized(_this), "preloadCharactors_3D", _descriptor3, _assertThisInitialized(_this));

          _initializerDefineProperty(_assertThisInitialized(_this), "preloadUIPrefabs", _descriptor4, _assertThisInitialized(_this));

          _initializerDefineProperty(_assertThisInitialized(_this), "preloadMaterials", _descriptor5, _assertThisInitialized(_this));

          _initializerDefineProperty(_assertThisInitialized(_this), "preloadUISpriteAtalas", _descriptor6, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = ResMgr.prototype;

        _proto.init = function init() {
          for (var i = 0; i < this.preloadScenes_3D.length; i++) {
            var dep = assetManager.dependUtil.getDepsRecursively(this.preloadScenes_3D[i].name);

            for (var i = 0; i < dep.length; i++) {
              this.incRefCount(dep[i]);
            }
          }

          for (var i = 0; i < this.preloadCharactors_3D.length; i++) {
            var dep = assetManager.dependUtil.getDepsRecursively(this.preloadCharactors_3D[i].name);

            for (var i = 0; i < dep.length; i++) {
              this.incRefCount(dep[i]);
            }
          }

          for (var i = 0; i < this.preloadUIPrefabs.length; i++) {
            var dep = assetManager.dependUtil.getDepsRecursively(this.preloadUIPrefabs[i].name);

            for (var i = 0; i < dep.length; i++) {
              this.incRefCount(dep[i]);
            }
          }

          for (var i = 0; i < this.preloadUISpriteAtalas.length; i++) {
            var dep = assetManager.dependUtil.getDepsRecursively(this.preloadUISpriteAtalas[i].name);

            for (var i = 0; i < dep.length; i++) {
              this.incRefCount(dep[i]);
            }
          }

          for (var i = 0; i < this.preloadSounds.length; i++) {
            var dep = assetManager.dependUtil.getDepsRecursively(this.preloadSounds[i].name);

            for (var i = 0; i < dep.length; i++) {
              this.incRefCount(dep[i]);
            }
          }

          for (var i = 0; i < this.preloadMaterials.length; i++) {
            var dep = assetManager.dependUtil.getDepsRecursively(this.preloadMaterials[i].name);

            for (var i = 0; i < dep.length; i++) {
              this.incRefCount(dep[i]);
            }
          }
        };

        _proto.onLoad = function onLoad() {
          if (ResMgr.Instance === null) {
            ResMgr.Instance = this;
          } else {
            this.destroy();
            return;
          } // this.init();

        };

        _proto.getAsset = function getAsset(name) {
          return resources.get(name);
        };

        _proto.releaseResPackage = function releaseResPackage(resPkg) {
          for (var key in resPkg) {
            for (var i = 0; i < resPkg[key].length; i++) {
              var dep = assetManager.dependUtil.getDepsRecursively(resPkg[key][i].name);

              for (var i = 0; i < dep.length; i++) {
                this.decRefCount(dep[i]);
              }

              assetManager.releaseAsset(resPkg[key][i]);
            }
          }
        };

        _proto.incRefCount = function incRefCount(url) {
          if (this.prefabDepRefCount[url]) {
            this.prefabDepRefCount[url] += 1;
          } else {
            this.prefabDepRefCount[url] = 1;
          }
        };

        _proto.decRefCount = function decRefCount(url) {
          if (this.prefabDepRefCount[url]) {
            // Logger.info("ref count", this.prefabDepRefCount[url]);
            this.prefabDepRefCount[url] -= 1;

            if (this.prefabDepRefCount[url] === 0) {
              assetManager.releaseAsset(url); // 这里删除得时候要使用release;
            }
          } else {
            Logger.info("error: url: " + url + " not loaded");
          }
        };

        _proto.loadRes = function loadRes(url, typeOfClass) {
          var _this2 = this;

          if (resources.get(url)) {
            // 资源有了直接返回
            this.now++;

            if (this.progressFunc) {
              this.progressFunc(this.now, this.total);
            }

            if (this.now >= this.total) {
              if (this.endFunc !== null) {
                this.endFunc();
              }
            }

            return;
          }

          resources.load(url, typeOfClass, function (error, asset) {
            loadTime("url:" + url + " \u8D44\u6E90");
            _this2.now++;

            if (error) {
              Logger.info("load Res " + url + " error: " + error);
            } else {
              var dep = assetManager.dependUtil.getDepsRecursively(asset);

              for (var i = 0; i < dep.length; i++) {
                _this2.incRefCount(dep[i]);
              }
            }

            if (_this2.progressFunc) {
              _this2.progressFunc(_this2.now, _this2.total);
            }

            if (_this2.now >= _this2.total) {
              if (_this2.endFunc !== null) {
                _this2.endFunc();
              }
            }
          });
        };

        _proto.getSpriteFrame = function getSpriteFrame(AltasUrl, spriteName) {
          var atlas = resources.get(AltasUrl, SpriteAtlas);

          if (!atlas) {
            return null;
          }

          return atlas.getSpriteFrame(spriteName);
        }
        /*
        资源包的模板
        var resPkg = {
        scenes_3D: [
            "maps/game",
        ],
          charactors_3D: [
          ],
          UI_Atalas: [
          ],
          
          Sounds: [
        ],
          UI_prefabs: [
          ]
        };
        */
        // { scenes_3D: [,路径, ], charactors_3D: [路径, ], UI_Atalas: [路径], UI_prefabs: [路径], Sounds: [路径]... }
        ;

        _proto.preloadResPackage = function preloadResPackage(resPkg, progressFunc, endFunc) {
          this.total = 0;
          this.now = 0;
          this.progressFunc = progressFunc;
          this.endFunc = endFunc;

          for (var key in resPkg) {
            this.total += resPkg[key].length;
          }

          if (this.total <= 0) {
            if (this.endFunc) {
              this.endFunc();
            }

            return;
          }

          if (resPkg.scenes_3D) {
            for (var i = 0; i < resPkg.scenes_3D.length; i++) {
              this.loadRes(resPkg.scenes_3D[i], Prefab);
            }
          }

          if (resPkg.charactors_3D) {
            for (var i = 0; i < resPkg.charactors_3D.length; i++) {
              this.loadRes(resPkg.charactors_3D[i], Prefab);
            }
          }

          if (resPkg.UI_prefabs) {
            for (var i = 0; i < resPkg.UI_prefabs.length; i++) {
              this.loadRes(resPkg.UI_prefabs[i], Prefab);
            }
          }

          if (resPkg.UI_Atalas) {
            for (var i = 0; i < resPkg.UI_Atalas.length; i++) {
              this.loadRes(resPkg.UI_Atalas[i], SpriteAtlas);
            }
          }

          if (resPkg.Sounds) {
            for (var i = 0; i < resPkg.Sounds.length; i++) {
              this.loadRes(resPkg.Sounds[i], AudioClip);
            }
          }

          if (resPkg.Materials) {
            for (var i = 0; i < resPkg.Materials.length; i++) {
              this.loadRes(resPkg.Materials[i], Material);
            }
          }
        }
        /**
         *  加载资源
         * @param url   资源路径
         * @param type  资源类型
         * @param cb    回调
         * @method loadRes
         * */
        ;

        ResMgr.loadRes = function loadRes(url, type, cb) {
          if (cb === void 0) {
            cb = function cb() {};
          }

          resources.load(url, function (err, res) {
            if (err) {
              error(err.message || err);
              cb(err, res);
              return;
            }

            cb && cb(null, res);
          });
        }
        /**
         * 获取特效prefab
         * @param modulePath 路径
         * @returns 
         */
        ;

        ResMgr.loadEffectRes = function loadEffectRes(modulePath) {
          var _this3 = this;

          return new Promise(function (resolve, reject) {
            var path = "prefab/effect/" + modulePath;
            var res = resources.get(path);

            if (res) {
              // 资源有了直接返回
              resolve && resolve(res);
              return;
            }

            _this3.loadRes(path, Prefab, function (err, prefab) {
              if (err) {
                console.error('effect load failed', modulePath);
                reject && reject();
                return;
              }

              resolve && resolve(prefab);
            });
          });
        }
        /**
         * 获取模型数据
         * @param modulePath 模型路径
         * @returns 
         */
        ;

        ResMgr.loadModelRes = function loadModelRes(modulePath) {
          var _this4 = this;

          return new Promise(function (resolve, reject) {
            var path = "prefab/" + modulePath;
            var res = resources.get(path);

            if (res) {
              // 资源有了直接返回
              resolve && resolve(res);
              return;
            }

            _this4.loadRes(path, Prefab, function (err, prefab) {
              if (err) {
                console.error("model load failed", modulePath);
                reject && reject();
                return;
              }

              resolve && resolve(prefab);
            });
          });
        }
        /**
         * 获取材质
         * @param matPath 路径
         * @returns 
         */
        ;

        ResMgr.loadMatRes = function loadMatRes(matPath) {
          var _this5 = this;

          return new Promise(function (resolve, reject) {
            var path = "prefab/" + matPath;
            var res = resources.get(path);

            if (res) {
              // 资源有了直接返回
              resolve && resolve(res);
              return;
            }

            _this5.loadRes(path, Material, function (err, mat) {
              if (err) {
                console.error('mat load failed', matPath);
                reject && reject();
                return;
              }

              resolve && resolve(mat);
            });
          });
        }
        /**
         * 获取多模型数据
         * @param path 资源路径
         * @param arrName 资源名称
         * @param progressCb 过程回调函数
         * @param completeCb 完成回调函数
         */
        ;

        ResMgr.loadModelResArr = function loadModelResArr(path, arrName, progressCb, completeCb) {
          var arrUrls = arrName.map(function (item) {
            return path + "/" + item;
          });
          resources.load(arrUrls, Prefab, progressCb, completeCb);
        };

        return ResMgr;
      }(Component), _defineProperty(_class3, "Instance", null), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "preloadSounds", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "preloadScenes_3D", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "preloadCharactors_3D", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "preloadUIPrefabs", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "preloadMaterials", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "preloadUISpriteAtalas", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2)) || _class)); // ResMgr.Instance = new ResMgr();

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/GameApp.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './index.cjs.js', './index.cjs.mjs_cjs=&original=.js', './helper.ts', './EventMgr.ts', './GameConstants.ts', './PoolMgr.ts', './ResourceUtil.ts', './AudioManager.ts', './GameDataMgr.ts', './MainUI_Ctrl.ts', './GridHandler.ts', './WebviewMgr.ts', './MesssageMgr.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, Node, game, dynamicAtlasManager, find, CanvasComponent, Camera, Vec3, math, Component, _defineProperty, _applyDecoratedDescriptor, _inheritsLoose, _assertThisInitialized, _initializerDefineProperty, _createClass, _cjsExports, loadTime, EventMgr, STAR_MODEL_PATH, SKIN_MODEL_PATH, RoleType, PoolManager, ResourceUtil, AudioManager, GameDataMgr, MainUI_Ctrl, GridHandler, WebviewMgr, MesssageMgr;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      game = module.game;
      dynamicAtlasManager = module.dynamicAtlasManager;
      find = module.find;
      CanvasComponent = module.CanvasComponent;
      Camera = module.Camera;
      Vec3 = module.Vec3;
      math = module.math;
      Component = module.Component;
    }, function (module) {
      _defineProperty = module.defineProperty;
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _assertThisInitialized = module.assertThisInitialized;
      _initializerDefineProperty = module.initializerDefineProperty;
      _createClass = module.createClass;
    }, function (module) {
      _cjsExports = module.default;
    }, null, function (module) {
      loadTime = module.loadTime;
    }, function (module) {
      EventMgr = module.EventMgr;
    }, function (module) {
      STAR_MODEL_PATH = module.STAR_MODEL_PATH;
      SKIN_MODEL_PATH = module.SKIN_MODEL_PATH;
      RoleType = module.RoleType;
    }, function (module) {
      PoolManager = module.PoolManager;
    }, function (module) {
      ResourceUtil = module.ResourceUtil;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      GameDataMgr = module.default;
    }, function (module) {
      MainUI_Ctrl = module.MainUI_Ctrl;
    }, function (module) {
      GridHandler = module.GridHandler;
    }, function (module) {
      WebviewMgr = module.default;
    }, function (module) {
      MesssageMgr = module.default;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor, _class3, _temp;

      cclegacy._RF.push({}, "81721A0s59C97O08pq287CP", "GameApp", undefined);

      var Logger = _cjsExports.Logger;
      /**
       * 
       * PK总倒计时：五分钟，流程优先，游戏流程结束后，返回游戏PK结束界面（可收起），PK倒计时结束后，判断是否加赛，然后PK逻辑结束。PK值加时逻辑保留，如果PK值平局（PK值，无平局加赛逻辑2021.8.26订正），则游戏不进入游戏加赛流程，总比分领先的队伍获得本次闯关PK的胜利
       * 游戏开始倒计时：5秒
       * 抢金币单回合确认时间：10秒
       * 游戏回合间隔：2秒
       * 加赛开始前倒计时：10秒
       *
       */

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var GameApp = exports('GameApp', (_dec = ccclass("GameApp"), _dec2 = property({
        type: Node
      }), _dec(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(GameApp, _Component);

        function GameApp() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this), "_data", null);

          _defineProperty(_assertThisInitialized(_this), "_message", null);

          _defineProperty(_assertThisInitialized(_this), "webview", null);

          _initializerDefineProperty(_assertThisInitialized(_this), "mainUI", _descriptor, _assertThisInitialized(_this));

          _defineProperty(_assertThisInitialized(_this), "mainUICtrl", null);

          _defineProperty(_assertThisInitialized(_this), "gridCtrl", null);

          _defineProperty(_assertThisInitialized(_this), "isUIsetted", false);

          _defineProperty(_assertThisInitialized(_this), "playerDesignWidth", 750);

          _defineProperty(_assertThisInitialized(_this), "playerDesignHeight", 996);

          _defineProperty(_assertThisInitialized(_this), "audienDesignHeight", 776);

          _defineProperty(_assertThisInitialized(_this), "pcPlayerDesignHeight", 815);

          _defineProperty(_assertThisInitialized(_this), "mainCamera", null);

          _defineProperty(_assertThisInitialized(_this), "uiCamera", null);

          _defineProperty(_assertThisInitialized(_this), "player1Prefab", null);

          _defineProperty(_assertThisInitialized(_this), "player2Prefab", null);

          _defineProperty(_assertThisInitialized(_this), "starPrefab", null);

          return _this;
        }

        var _proto = GameApp.prototype;

        _proto.onLoad = function onLoad() {
          var _this2 = this; //设置帧率为30帧


          game.frameRate = 30;

          if (GameApp.Instance === null) {
            GameApp.Instance = this;
          } else {
            this.destroy();
            return;
          } // start 初始化框架
          // this.node.addComponent(ResMgr).init();


          this.node.addComponent(EventMgr); //初始化音乐

          AudioManager.Instance.init(); // this.node.addComponent(SoundMgr);
          // for (let i = 1; i < 10; i++) {
          //     resources.preload("prefab/star/star" + i, Prefab);
          //     resources.load("prefab/star/star" + i, Prefab, (err, prefab) => {
          //         let star = instantiate(prefab) as Node;
          //         this.node.addChild(star);
          //         for (let j = 0; j < star.children.length; j++) {
          //             let _star = star.children[j];
          //             let tStr = "star " + i + " pos " + j + " = " + JSON.stringify(_star.position);
          //             console.log(tStr);
          //         }
          //     });
          // }
          //加载资源
          // ResMgr.Instance.preloadResPackage(resPkg, (now: any, total: any) => {
          // }, () => {
          //     //     loadTime('结束load prefab所有资源');
          //     //     this.enterGame();
          // });
          //预加载星星节点池

          ResourceUtil.loadModelRes(STAR_MODEL_PATH).then(function (prefab) {
            _this2.starPrefab = prefab;
            PoolManager.Instance.prePool(prefab, 40);
          });
          ResourceUtil.loadModelRes(SKIN_MODEL_PATH + "1").then(function (prefab) {
            _this2.player1Prefab = prefab;
            PoolManager.Instance.prePool(prefab, 2);
          });
          ResourceUtil.loadModelRes(SKIN_MODEL_PATH + "2").then(function (prefab) {
            _this2.player2Prefab = prefab;
            PoolManager.Instance.prePool(prefab, 2);
          });
          loadTime('游戏load');
        };

        _proto.start = function start() {
          var _canvas$getComponent;

          Logger.info("bridge GameApp init"); // macro.ENABLE_TRANSPARENT_CANVAS = true;

          dynamicAtlasManager.maxFrameSize = 750;
          var canvas = find("Canvas");
          this.uiCamera = (_canvas$getComponent = canvas.getComponent(CanvasComponent)) === null || _canvas$getComponent === void 0 ? void 0 : _canvas$getComponent.cameraComponent;
          var camera = find("Main Camera");
          this.mainCamera = camera.getComponent(Camera);
          var griNode = this.node.getChildByName("GridNode");
          this.gridCtrl = griNode.getComponent(GridHandler); // this.winEffect = find("Main Camera/winEffect")!;
          //游戏加载成功

          _cjsExports.PkBridge.gameLoadSuccess();

          Logger.info("bridge gameLoadSuccess");
          this.enterGame();
        };

        _proto.enterGame = function enterGame() {
          var _this3 = this;

          Logger.info("bridge enterGame ");
          this._data = new GameDataMgr();
          this._message = new MesssageMgr();
          this.webview = new WebviewMgr(); //从桥获取用户信息房间信息等

          this._data.init(function () {
            var _this3$mainUICtrl;

            Logger.info("GameApp 获取房间信息成功 ", _this3.data.roomId);
            _this3.mainUICtrl = _this3.mainUI.getComponent(MainUI_Ctrl); //初始化底部mainUI

            (_this3$mainUICtrl = _this3.mainUICtrl) === null || _this3$mainUICtrl === void 0 ? void 0 : _this3$mainUICtrl.initBottomUI(_this3.data.playerType, function () {
              //更新UI适配结果
              _this3.updateUIResolution(); //注册网络事件监听


              _this3._message.registerEvent(); // 建立网络连接


              console.error('开始链接');

              _this3._message.connect({
                uid: _this3._data.uId,
                roomId: _this3._data.roomId,
                token: _this3._data.token,
                viewerId: _this3._data.deviceId,
                isViewer: _this3._data.isViewer
              });
            });
          }); //test code
          // this._data.updateTestData();
          // this.mainUICtrl = this.mainUI.getComponent(MainUI_Ctrl);
          // //初始化底部mainUI
          // // this.data.playerType = RoleType.PC_PLAYER;
          // this.mainUICtrl?.initBottomUI(this.data.playerType, () => {
          //     //更新UI适配结果
          //     this.updateUIResolution();
          //     // GameAwesome.Bridge.app.isYppPC = true;
          //     // //-10201 游戏开始
          //     let snapData: any = {};
          //     snapData.battleId = Long.fromString("123456");
          //     snapData.userInfos = [
          //         { uid: Long.fromString("212581059431380021"), hostUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", mute: true, nickname: "", score: 13, roleName: "A", roleId: "7", roleIcon: "", status: 1 },
          //         { uid: Long.fromString("2"), hostUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", mute: true, nickname: "", score: 24, roleName: "B", roleId: "8", roleIcon: "", status: 1 },
          //         { uid: Long.fromString("5"), hostUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", mute: true, nickname: "", score: 57, roleName: "C", roleId: "3", roleIcon: "", status: 1 },
          //         { uid: Long.fromString("6"), hostUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", mute: false, nickname: "", score: 68, roleName: "D", roleId: "4", roleIcon: "", status: 1 },
          //         { uid: Long.fromString("3"), hostUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", mute: true, nickname: "", score: 45, roleName: "A", roleId: "3", roleIcon: "", status: 1 },
          //         { uid: Long.fromString("4"), hostUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", mute: false, nickname: "", score: 88, roleName: "B", roleId: "4", roleIcon: "", status: 1 },
          //         { uid: Long.fromString("7"), hostUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", mute: true, nickname: "", score: 32, roleName: "C", roleId: "7", roleIcon: "", status: 1 },
          //         { uid: Long.fromString("8"), hostUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", mute: false, nickname: "", score: 31, roleName: "D", roleId: "8", roleIcon: "", status: 1 },
          //     ];
          //     this._message.GameSnapshotResp(snapData);
          //     // -300 游戏开始
          //     this.scheduleOnce(() => {
          //         let gameStartData = {
          //             gameNo: 1,
          //             // 战斗ID
          //             battleId: Long.fromString("123456"),
          //             // 当前对局分组
          //             currentDuel: [
          //                 { uid: Long.fromString("212581059431380021"), anchorUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 13, roleName: "A", roleId: "1", roleIcon: "", isAnchor: true, userOnlineStatus: 1 },
          //                 { uid: Long.fromString("2"), anchorUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 24, roleName: "B", roleIcon: "", roleId: "2", isAnchor: false, userOnlineStatus: 1 },
          //                 { uid: Long.fromString("5"), anchorUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 57, roleName: "C", roleIcon: "", roleId: "5", isAnchor: true, userOnlineStatus: 1 },
          //                 { uid: Long.fromString("6"), anchorUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 68, roleName: "D", roleIcon: "", roleId: "6", isAnchor: false, userOnlineStatus: 1 },
          //             ],
          //             // 下一对局分组
          //             nextDuel: [
          //                 { uid: Long.fromString("3"), anchorUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 45, roleName: "A", roleId: "3", roleIcon: "", isAnchor: true, userOnlineStatus: 1 },
          //                 { uid: Long.fromString("4"), anchorUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 88, roleName: "B", roleId: "4", roleIcon: "", isAnchor: false, userOnlineStatus: 1 },
          //                 { uid: Long.fromString("7"), anchorUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 32, roleName: "C", roleId: "7", roleIcon: "", isAnchor: true, userOnlineStatus: 1 },
          //                 { uid: Long.fromString("8"), anchorUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 31, roleName: "D", roleId: "8", roleIcon: "", isAnchor: false, userOnlineStatus: 1 },
          //             ],
          //             // 开始方式，REGULAR_ROUND常规场 OVERTIME_ROUND加时场
          //             startType: 2,
          //             // 地图信息
          //             map: {
          //                 gridList: [
          //                     { id: 1, type: 1, uid: Long.fromString("1"), gold: 24 },
          //                     { id: 2, type: 2, uid: Long.fromString("212581059431380021"), gold: 0 },
          //                     { id: 3, type: 1, uid: Long.fromString("1"), gold: 21 },
          //                     { id: 4, type: 2, uid: Long.fromString("2"), gold: 0 },
          //                     { id: 5, type: 3, uid: Long.fromString("1"), gold: 1 },
          //                     { id: 6, type: 2, uid: Long.fromString("6"), gold: 0 },
          //                     { id: 7, type: 1, uid: Long.fromString("1"), gold: 2 },
          //                     { id: 8, type: 2, uid: Long.fromString("5"), gold: 0 },
          //                     { id: 9, type: 1, uid: Long.fromString("1"), gold: 33 },
          //                 ]
          //             },
          //             isPlayoff: 2
          //         };
          //         this._message.onGameStart(gameStartData);
          //     }, 3);
          //     // 用户离线
          //     this.scheduleOnce(() => {
          //         let userStatusData = {
          //             uid: Long.fromString("5"),
          //             changeType: 0
          //         };
          //         this._message.onUserStatusChange(userStatusData as any);
          //     }, 4);
          //     //第一局结算
          //     this.scheduleOnce(() => {
          //         let roundSettleData = {
          //             roundSettle: [
          //                 { uid: Long.fromString("212581059431380021"), gridNo: 5 },
          //                 { uid: Long.fromString("2"), gridNo: 7, gold: 9, score: 33 },
          //                 { uid: Long.fromString("5"), gridNo: 5 },
          //                 { uid: Long.fromString("6"), gridNo: 3, gold: 5, score: 73 },
          //             ]
          //         };
          //         this._message.onRoundSettle(roundSettleData);
          //     }, 18.4);
          //     // //用户状态变更为在线
          //     this.scheduleOnce(() => {
          //         let userStatusData = {
          //             uid: Long.fromString("5"),
          //             changeType: 1
          //         };
          //         this._message.onUserStatusChange(userStatusData as any);
          //     }, 8);
          //     //第二回合开始
          //     this.scheduleOnce(() => {
          //         let roundStartData = {
          //             // 第几局
          //             gameNo: 1,
          //             // 第几回合
          //             roundNo: 2,
          //             // 地图信息
          //             map: {
          //                 gridList: [
          //                     { id: 1, type: 1, uid: Long.fromString("1"), gold: 1 },
          //                     { id: 2, type: 2, uid: Long.fromString("212581059431380021"), gold: "" },
          //                     { id: 3, type: 1, uid: Long.fromString("1"), gold: 7 },
          //                     { id: 4, type: 2, uid: Long.fromString("2"), gold: 0 },
          //                     { id: 5, type: 1, uid: Long.fromString("1"), gold: 1 },
          //                     { id: 6, type: 2, uid: Long.fromString("6"), gold: 0 },
          //                     { id: 7, type: 1, uid: Long.fromString("1"), gold: 5 },
          //                     { id: 8, type: 2, uid: Long.fromString("5"), gold: 0 },
          //                     { id: 9, type: 1, uid: Long.fromString("1"), gold: 8 },
          //                 ]
          //             }
          //         };
          //         this._message.onRoundStart(roundStartData);
          //     }, 20.4);
          //     // //第二回合结算
          //     this.scheduleOnce(() => {
          //         let roundSettleData = {
          //             roundSettle: [
          //                 { uid: Long.fromString("212581059431380021"), gridNo: 1, gold: 1, score: 14 },
          //                 { uid: Long.fromString("2"), gridNo: 7, gold: 9, score: 77 },
          //                 { uid: Long.fromString("5"), gridNo: 7 },
          //                 { uid: Long.fromString("6"), gridNo: 5, gold: 5, score: 77 },
          //             ]
          //         };
          //         this._message.onRoundSettle(roundSettleData);
          //     }, 32);
          //     // //**************第二局开始*******************/
          //     // //-300 第二局游戏开始
          //     this.scheduleOnce(() => {
          //         let gameStartData = {
          //             gameNo: 2,
          //             // 战斗ID
          //             battleId: Long.fromString("123456"),
          //             // 当前对局分组
          //             currentDuel: [
          //                 { uid: Long.fromString("3"), anchorUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 13, roleName: "A", roleId: "3", roleIcon: "", isAnchor: false, userOnlineStatus: 1 },
          //                 { uid: Long.fromString("4"), anchorUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 24, roleName: "B", roleIcon: "", roleId: "4", isAnchor: false, userOnlineStatus: 1 },
          //                 { uid: Long.fromString("7"), anchorUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 57, roleName: "C", roleIcon: "", roleId: "7", isAnchor: false, userOnlineStatus: 0 },
          //                 { uid: Long.fromString("8"), anchorUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 68, roleName: "D", roleIcon: "", roleId: "8", isAnchor: false, userOnlineStatus: 1 },
          //             ],
          //             // 下一对局分组
          //             nextDuel: [],
          //             // 开始方式，REGULAR_ROUND常规场 OVERTIME_ROUND加时场
          //             startType: 2,
          //             // 地图信息
          //             map: {
          //                 gridList: [
          //                     { id: 1, type: 3, uid: Long.fromString("1"), gold: "11" },
          //                     { id: 2, type: 2, uid: Long.fromString("3"), gold: "" },
          //                     { id: 3, type: 1, uid: Long.fromString("1"), gold: "3" },
          //                     { id: 4, type: 2, uid: Long.fromString("4"), gold: "" },
          //                     { id: 5, type: 1, uid: Long.fromString("1"), gold: "2" },
          //                     { id: 6, type: 2, uid: Long.fromString("8"), gold: "" },
          //                     { id: 7, type: 1, uid: Long.fromString("1"), gold: "9" },
          //                     { id: 8, type: 2, uid: Long.fromString("7"), gold: "" },
          //                     { id: 9, type: 1, uid: Long.fromString("1"), gold: "7" },
          //                 ]
          //             },
          //             isPlayoff: 2
          //         };
          //         this._message.onGameStart(gameStartData);
          //     }, 37);
          //     //第二局 第一回合结算
          //     this.scheduleOnce(() => {
          //         let roundSettleData = {
          //             roundSettle: [
          //                 { uid: Long.fromString("3"), gridNo: 1 },
          //                 { uid: Long.fromString("4"), gridNo: 7, gold: 9, score: 77 },
          //                 { uid: Long.fromString("7"), gridNo: 7 },
          //                 { uid: Long.fromString("8"), gridNo: 5, gold: 5, score: 77 },
          //             ]
          //         };
          //         this._message.onRoundSettle(roundSettleData);
          //     }, 52.4);
          //     //第二回合开始
          //     this.scheduleOnce(() => {
          //         let roundStartData = {
          //             // 第几局
          //             gameNo: 2,
          //             // 第几回合
          //             roundNo: 2,
          //             // 地图信息
          //             map: {
          //                 gridList: [
          //                     { id: 1, type: 3, uid: Long.fromString("1"), gold: 1 },
          //                     { id: 2, type: 2, uid: Long.fromString("3"), gold: 0 },
          //                     { id: 3, type: 1, uid: Long.fromString("1"), gold: 4 },
          //                     { id: 4, type: 2, uid: Long.fromString("4"), gold: 0 },
          //                     { id: 5, type: 1, uid: Long.fromString("1"), gold: 6 },
          //                     { id: 6, type: 2, uid: Long.fromString("8"), gold: 0 },
          //                     { id: 7, type: 1, uid: Long.fromString("1"), gold: 8 },
          //                     { id: 8, type: 2, uid: Long.fromString("7"), gold: 0 },
          //                     { id: 9, type: 1, uid: Long.fromString("1"), gold: 5 },
          //                 ]
          //             }
          //         };
          //         this._message.onRoundStart(roundStartData);
          //     }, 54.4);
          //     //第二回合结算
          //     this.scheduleOnce(() => {
          //         let roundSettleData = {
          //             roundSettle: [
          //                 { uid: Long.fromString("3"), gridNo: 1 },
          //                 { uid: Long.fromString("4"), gridNo: 7, gold: 9, score: 77 },
          //                 { uid: Long.fromString("7"), gridNo: 7 },
          //                 { uid: Long.fromString("8"), gridNo: 9, gold: 5, score: 77 },
          //             ]
          //         };
          //         this._message.onRoundSettle(roundSettleData);
          //     }, 66);
          //     // //**************第二局结束*******************/
          //     // //**************加赛局开始*******************/
          //     //-300 第三局加赛游戏开始
          //     this.scheduleOnce(() => {
          //         let gameStartData = {
          //             gameNo: 3,
          //             // 战斗ID
          //             battleId: Long.fromString("123456"),
          //             // 当前对局分组
          //             currentDuel: [
          //                 { uid: Long.fromString("212581059431380021"), anchorUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 13, roleName: "A", roleId: "3", roleIcon: "", isAnchor: true, userOnlineStatus: 1 },
          //                 { uid: Long.fromString("5"), anchorUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 57, roleName: "C", roleIcon: "", roleId: "5", isAnchor: true, userOnlineStatus: 1 },
          //             ],
          //             // 下一对局分组
          //             nextDuel: [],
          //             // 开始方式，REGULAR_ROUND常规场 OVERTIME_ROUND加时场
          //             startType: 2,
          //             // 地图信息
          //             map: {
          //                 gridList: [
          //                     { id: 1, type: 3, uid: Long.fromString("1"), gold: 5 },
          //                     { id: 2, type: 2, uid: Long.fromString("212581059431380021"), gold: 0 },
          //                     { id: 3, type: 3, uid: Long.fromString("1"), gold: 3 },
          //                     { id: 4, type: 3, uid: Long.fromString("1"), gold: 0 },
          //                     { id: 5, type: 1, uid: Long.fromString("1"), gold: 9 },
          //                     { id: 6, type: 3, uid: Long.fromString("1"), gold: 0 },
          //                     { id: 7, type: 3, uid: Long.fromString("1"), gold: 9 },
          //                     { id: 8, type: 2, uid: Long.fromString("5"), gold: 0 },
          //                     { id: 9, type: 3, uid: Long.fromString("1"), gold: 7 },
          //                 ]
          //             },
          //             isPlayoff: 1
          //         };
          //         this._message.onGameStart(gameStartData);
          //     }, 71);
          //     // 第二回合结算
          //     this.scheduleOnce(() => {
          //         let roundSettleData = {
          //             roundSettle: [
          //                 { uid: Long.fromString("212581059431380021"), gridNo: 5 },
          //                 { uid: Long.fromString("5"), gridNo: 5 },
          //             ]
          //         };
          //         this._message.onRoundSettle(roundSettleData);
          //     }, 86.4);
          // //**************加赛局结束*******************/
          // this.scheduleOnce(() => {
          //     let gameSettleData = {
          //         winner: {
          //             anchorUid: "212581059431380021",
          //             mvp: "212581059431380021",
          //             score: 12,
          //             userInfo: [
          //                 { uid: "212581059431380021", anchorUid: "212581059431380021", avatar: "", username: "", score: "1", roleName: "", roleIcon: "", isAnchor: true, userOnlineStatus: "", isMvp: "" },
          //                 { uid: "2", anchorUid: "1", avatar: "", username: "", score: "2", roleName: "", roleIcon: "", isAnchor: false, userOnlineStatus: "", isMvp: "" },
          //                 { uid: "5", anchorUid: "5", avatar: "", username: "", score: "5", roleName: "", roleIcon: "", isAnchor: true, userOnlineStatus: "", isMvp: "" },
          //                 { uid: "6", anchorUid: "5", avatar: "", username: "", score: "6", roleName: "", roleIcon: "", isAnchor: false, userOnlineStatus: "", isMvp: "" },
          //             ]
          //         },
          //         loser: {
          //             anchorUid: "5",
          //             mvp: "5",
          //             score: 11,
          //             userInfo: [
          //                 { uid: "3", anchorUid: "1", avatar: "", username: "", score: "", roleName: "", roleIcon: "", isAnchor: false, userOnlineStatus: "", isMvp: "" },
          //                 { uid: "4", anchorUid: "1", avatar: "", username: "", score: "", roleName: "", roleIcon: "", isAnchor: false, userOnlineStatus: "", isMvp: "" },
          //                 { uid: "7", anchorUid: "5", avatar: "", username: "", score: "", roleName: "", roleIcon: "", isAnchor: false, userOnlineStatus: "", isMvp: "" },
          //                 { uid: "8", anchorUid: "5", avatar: "", username: "", score: "", roleName: "", roleIcon: "", isAnchor: false, userOnlineStatus: "", isMvp: "" },
          //             ]
          //         }
          //     };
          //     this._message.onGameSettle(gameSettleData);
          // });
          // this.scheduleOnce(() => {
          //     let reEnterData = {
          //         teamA: [
          //             { uid: Long.fromString("212581059431380021"), anchorUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 13, roleName: "A", roleId: "1", roleIcon: "", isAnchor: true, userOnlineStatus: 1 },
          //             { uid: Long.fromString("2"), anchorUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 24, roleName: "B", roleIcon: "", roleId: "2", isAnchor: false, userOnlineStatus: 1 },
          //             { uid: Long.fromString("3"), anchorUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 24, roleName: "A", roleId: "3", roleIcon: "", isAnchor: true, userOnlineStatus: 1 },
          //             { uid: Long.fromString("4"), anchorUid: Long.fromString("212581059431380021"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 24, roleName: "B", roleId: "4", roleIcon: "", isAnchor: false, userOnlineStatus: 1 },
          //         ],
          //         teamB: [
          //             { uid: Long.fromString("5"), anchorUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 57, roleName: "C", roleIcon: "", roleId: "5", isAnchor: true, userOnlineStatus: 1 },
          //             { uid: Long.fromString("6"), anchorUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 68, roleName: "D", roleIcon: "", roleId: "6", isAnchor: false, userOnlineStatus: 1 },
          //             { uid: Long.fromString("7"), anchorUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 57, roleName: "C", roleId: "7", roleIcon: "", isAnchor: true, userOnlineStatus: 1 },
          //             { uid: Long.fromString("8"), anchorUid: Long.fromString("5"), avatar: "https://tphoto.hellobixin.com/upload/9B902C1F-E86E-44F1-9795-97D3E690FB77.jpg", username: "", score: 68, roleName: "D", roleId: "8", roleIcon: "", isAnchor: false, userOnlineStatus: 1 },
          //         ],
          //         map: {
          //             gridList: [
          //                 { id: 1, type: 3, uid: Long.fromString("1"), gold: "2" },
          //                 { id: 2, type: 2, uid: Long.fromString("212581059431380021"), gold: "" },
          //                 { id: 3, type: 1, uid: Long.fromString("1"), gold: "5" },
          //                 { id: 4, type: 2, uid: Long.fromString("2"), gold: "" },
          //                 { id: 5, type: 3, uid: Long.fromString("1"), gold: "1" },
          //                 { id: 6, type: 2, uid: Long.fromString("6"), gold: "" },
          //                 { id: 7, type: 1, uid: Long.fromString("1"), gold: "9" },
          //                 { id: 8, type: 2, uid: Long.fromString("5"), gold: "" },
          //                 { id: 9, type: 1, uid: Long.fromString("1"), gold: "6" },
          //             ]
          //         },
          //         "roundStatus": 1,
          //         "gameNo": 1,
          //         "roundNo": 1,
          //         "isPlayoff": 2
          //     };
          //     this._message.onReEnter(reEnterData as any);
          // }, 4);
          // });

        } // 星星飞往头像框位置
        ;

        _proto.collectStar = function collectStar(data) {
          var _this$mainUICtrl, _this$mainUICtrl2;

          (_this$mainUICtrl = this.mainUICtrl) === null || _this$mainUICtrl === void 0 ? void 0 : _this$mainUICtrl.hideOperate(); // 获得头像具体的节点，然后做金币飞行动画

          var UIStarPos = new Vec3(0, 0, 0);
          var scoreNode = this.mainUICtrl.getHeaderPos(UIStarPos, data.uid);
          var screenPos = new Vec3(0, 0, 0);
          this.uiCamera.worldToScreen(UIStarPos, screenPos);
          GameApp.Instance.mainCamera.screenToWorld(screenPos, data.starPos); //执行玩家跳跃,金币飞行动画，更新UI金币值

          this.gridCtrl.moveModel(data, scoreNode);
          if (this.data.playerType == RoleType.AUDIENCE) (_this$mainUICtrl2 = this.mainUICtrl) === null || _this$mainUICtrl2 === void 0 ? void 0 : _this$mainUICtrl2.updateLabel("");
        };

        _proto.playWinEffect = function playWinEffect(uid) {
          if (uid == this.data.uId) ;
        } //UI适配处理，包括3d相机视角位置适配和底部操作热区适配
        ;

        _proto.updateUIResolution = function updateUIResolution() {
          this.gridCtrl.node.active = true;
          if (this.isUIsetted) return;
          this.isUIsetted = true;
          Logger.info("bridge GameAwesome.Bridge.app.isYppPC ", _cjsExports.Bridge.app.isYppPC);
          this.fix3dCameraFOV();
        } //基于不同设计分辨率动态调整3d相机fov，使得3d视角永远针对设计分辨率一个合适距离
        ;

        _proto.fix3dCameraFOV = function fix3dCameraFOV() {
          var camera = find("Main Camera");
          this.mainCamera = camera.getComponent(Camera);
          var windowWidth = this.data.w || document.body && document.body.clientWidth;
          var windowHeight = this.data.h || document.body && document.body.clientHeight; //玩家/观众宽高比

          var rate1 = this.playerDesignHeight / this.playerDesignWidth;
          var rate2 = windowHeight / windowWidth;
          Logger.info("bridge 更新相机fov ", rate2 - rate1); //pc宽高比

          if (_cjsExports.Bridge.app.isYppPC) {
            rate1 = this.pcPlayerDesignHeight / this.playerDesignWidth;
            rate2 = windowHeight / windowWidth - 0.2;
            this.mainCamera.rect = new math.Rect(0, 0.02, 1, 1);
            Logger.info("bridge 该用户是主播，更新pc端相机fov ", rate2 - rate1);
          }

          if (this.data.playerType <= 1) {
            Logger.info("");
            rate1 = this.audienDesignHeight / this.playerDesignWidth;
            rate2 = windowHeight / windowWidth - 0.22;
            this.mainCamera.rect = new math.Rect(0, -0.02, 1, 1);
            Logger.info("bridge 该用户是观众，更新观众端相机fov ", rate2 - rate1);
          }

          this.mainCamera.fov *= 1 + (rate2 - rate1);
        };

        _createClass(GameApp, [{
          key: "data",
          get: function get() {
            return this._data;
          }
        }]);

        return GameApp;
      }(Component), _defineProperty(_class3, "Instance", null), _temp), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "mainUI", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _class2)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ScoreNodeControl.ts", ['cc', './_rollupPluginModLoBabelHelpers.js'], function (exports) {
  'use strict';

  var cclegacy, _decorator, tween, v3, Component, _inheritsLoose;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      tween = module.tween;
      v3 = module.v3;
      Component = module.Component;
    }, function (module) {
      _inheritsLoose = module.inheritsLoose;
    }],
    execute: function () {
      var _dec, _class;

      cclegacy._RF.push({}, "83372DsDiJGzKR4bdK2t+Za", "ScoreNodeControl", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var ScoreNodeControl = exports('ScoreNodeControl', (_dec = ccclass('ScoreNodeControl'), _dec(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(ScoreNodeControl, _Component);

        function ScoreNodeControl() {
          return _Component.apply(this, arguments) || this;
        }

        var _proto = ScoreNodeControl.prototype;

        _proto.start = function start() {
          //上升
          var jumpUp = tween(this.node).to(1, {
            position: v3(this.node.position.x, this.node.position.y + 0.03, this.node.position.z)
          }); // 下落

          var jumpDown = tween(this.node).to(1, {
            position: v3(this.node.position.x, this.node.position.y - 0.03, this.node.position.z)
          });

          var _tween = tween().sequence(jumpUp, jumpDown).repeatForever();

          tween(this.node).then(_tween).start();
        };

        return ScoreNodeControl;
      }(Component)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/GridHandler.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './EventMgr.ts', './GameConstants.ts', './PoolMgr.ts', './ResourceUtil.ts', './lodash.ts', './AudioManager.ts', './FloorCtrl.ts', './StarFlyingCtrl.ts', './GameApp.ts', './PlayerCtrl.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, Node, Material, Vec3, resources, MeshRenderer, Prefab, SkeletalAnimation, v3, Component, LabelComponent, _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _defineProperty, EventMgr, GameEnum, ArrowState, ArrowDirection, DirIdxData, SKIN_MODEL_PATH, SKIN_MAT_PATH, StarPosData, GridType, SoundName, PoolManager, ResourceUtil, lodash, AudioManager, FloorCtrl, StarFlyingCtrl, GameApp, PlayerCtrl;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Material = module.Material;
      Vec3 = module.Vec3;
      resources = module.resources;
      MeshRenderer = module.MeshRenderer;
      Prefab = module.Prefab;
      SkeletalAnimation = module.SkeletalAnimation;
      v3 = module.v3;
      Component = module.Component;
      LabelComponent = module.LabelComponent;
    }, function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _defineProperty = module.defineProperty;
    }, function (module) {
      EventMgr = module.EventMgr;
    }, function (module) {
      GameEnum = module.GameEnum;
      ArrowState = module.ArrowState;
      ArrowDirection = module.ArrowDirection;
      DirIdxData = module.DirIdxData;
      SKIN_MODEL_PATH = module.SKIN_MODEL_PATH;
      SKIN_MAT_PATH = module.SKIN_MAT_PATH;
      StarPosData = module.StarPosData;
      GridType = module.GridType;
      SoundName = module.SoundName;
    }, function (module) {
      PoolManager = module.PoolManager;
    }, function (module) {
      ResourceUtil = module.ResourceUtil;
    }, function (module) {
      lodash = module.lodash;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      FloorCtrl = module.FloorCtrl;
    }, function (module) {
      StarFlyingCtrl = module.StarFlyingCtrl;
    }, function (module) {
      GameApp = module.GameApp;
    }, function (module) {
      PlayerCtrl = module.PlayerCtrl;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _temp;

      cclegacy._RF.push({}, "89f44eGpHlJ457hZdb3OW6M", "GridHandler", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property; // GridHandler
      // 场景玩家和格子数据更新 Handler

      var GridHandler = exports('GridHandler', (_dec = ccclass('GridHandler'), _dec2 = property({
        type: Node,
        displayName: '玩家列表'
      }), _dec3 = property({
        type: Node,
        displayName: '地板列表'
      }), _dec4 = property({
        type: Material
      }), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function (_Component) {
        _inheritsLoose(GridHandler, _Component);

        function GridHandler() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_assertThisInitialized(_this), "PlayerList", _descriptor, _assertThisInitialized(_this));

          _defineProperty(_assertThisInitialized(_this), "PlayerCtrlMap", new Map());

          _initializerDefineProperty(_assertThisInitialized(_this), "FloorList", _descriptor2, _assertThisInitialized(_this));

          _initializerDefineProperty(_assertThisInitialized(_this), "numMtlList", _descriptor3, _assertThisInitialized(_this));

          _defineProperty(_assertThisInitialized(_this), "myIdx", 0);

          _defineProperty(_assertThisInitialized(_this), "chosedIdx", 0);

          _defineProperty(_assertThisInitialized(_this), "myPlayerCtrl", null);

          return _this;
        }

        var _proto = GridHandler.prototype;

        _proto.onLoad = function onLoad() {};

        _proto.start = function start() {
          this.initPlayerPos();
          EventMgr.Instance.AddEventListener(GameEnum.EventPlayerPressedLeft, this, this.btnLeftCallback);
          EventMgr.Instance.AddEventListener(GameEnum.EventPlayerPressedRight, this, this.btnRightCallback);
          EventMgr.Instance.AddEventListener(GameEnum.EventPlayerPressedUp, this, this.btnUpCallback);
          EventMgr.Instance.AddEventListener(GameEnum.EventPlayerPressedDown, this, this.btnDownCallback);
          EventMgr.Instance.AddEventListener(GameEnum.EventPlayerPressedCenter, this, this.btnCenterCallback);
        };

        _proto.btnLeftCallback = function btnLeftCallback() {
          var isCanOperate = ArrowState[this.myIdx][ArrowDirection.LEFT];
          if (!isCanOperate) return;
          this.updateArrowState(ArrowDirection.LEFT);
        };

        _proto.btnRightCallback = function btnRightCallback() {
          var isCanOperate = ArrowState[this.myIdx][ArrowDirection.RIGHT];
          if (!isCanOperate) return;
          this.updateArrowState(ArrowDirection.RIGHT);
        };

        _proto.btnUpCallback = function btnUpCallback() {
          var isCanOperate = ArrowState[this.myIdx][ArrowDirection.UP];
          if (!isCanOperate) return;
          this.updateArrowState(ArrowDirection.UP);
        };

        _proto.btnDownCallback = function btnDownCallback() {
          var isCanOperate = ArrowState[this.myIdx][ArrowDirection.DOWN];
          if (!isCanOperate) return;
          this.updateArrowState(ArrowDirection.DOWN);
        };

        _proto.btnCenterCallback = function btnCenterCallback() {};

        _proto.updateArrowState = function updateArrowState(state) {
          this.myPlayerCtrl.jump(); // this.scheduleOnce(() => {

          this.chosedIdx = DirIdxData[this.myIdx][state];
          this.myPlayerCtrl.updateArrowState(state);

          GameApp.Instance._message.sendChooseRequest(this.chosedIdx); // }, 1.1);

        };

        _proto.initPlayerPos = function initPlayerPos() {
          //初始化玩家位置
          var startFloor1 = null;
          var startFloor2 = null;
          var startFloor3 = null;
          var startFloor4 = null;

          for (var i = 0; i < this.FloorList.length; i++) {
            var floorCtl = this.FloorList[i].getComponent(FloorCtrl);
            if ((floorCtl === null || floorCtl === void 0 ? void 0 : floorCtl.idx) == 2) startFloor1 = this.FloorList[i];
            if ((floorCtl === null || floorCtl === void 0 ? void 0 : floorCtl.idx) == 4) startFloor2 = this.FloorList[i];
            if ((floorCtl === null || floorCtl === void 0 ? void 0 : floorCtl.idx) == 8) startFloor3 = this.FloorList[i];
            if ((floorCtl === null || floorCtl === void 0 ? void 0 : floorCtl.idx) == 6) startFloor4 = this.FloorList[i];
          }

          for (var _i = 0; _i < this.PlayerList.length; _i++) {
            var playerCtl = this.PlayerList[_i].getComponent(PlayerCtrl);

            switch (playerCtl === null || playerCtl === void 0 ? void 0 : playerCtl.idx) {
              case 2:
                playerCtl.node.setWorldPosition(new Vec3(startFloor1.worldPosition.x, playerCtl.node.worldPosition.y, startFloor1.worldPosition.z));
                break;

              case 4:
                playerCtl.node.setWorldPosition(new Vec3(startFloor2.worldPosition.x, playerCtl.node.worldPosition.y, startFloor2.worldPosition.z));
                break;

              case 8:
                playerCtl.node.setWorldPosition(new Vec3(startFloor3.worldPosition.x, playerCtl.node.worldPosition.y, startFloor3.worldPosition.z));
                break;

              case 6:
                playerCtl.node.setWorldPosition(new Vec3(startFloor4.worldPosition.x, playerCtl.node.worldPosition.y, startFloor4.worldPosition.z));
                break;
            }
          }
        } //更新格子数据
        ;

        _proto.updateGridList = function updateGridList(mapInfo, isNeedBack) {
          var _this2 = this;

          if (isNeedBack === void 0) {
            isNeedBack = false;
          }

          var _loop = function _loop(i) {
            var info = mapInfo[i]; // console.log("updateGridList map info = ", info);

            if (info.type == GridType.ROLE) {
              _this2.updateRole(info, isNeedBack);
            } else if (info.type == GridType.STAR) {
              _this2.scheduleOnce(function () {
                _this2.updateStar(info);
              }, 0.7);
            } else if (info.type == GridType.NONE) {
              var player = null;

              for (var j = 0; j < _this2.PlayerList.length; j++) {
                var tPlayer = _this2.PlayerList[j].getComponent(PlayerCtrl);

                if (info.id == tPlayer.idx.toString()) {
                  player = tPlayer;
                  break;
                }
              }

              if (player) {
                player.initArrowState();
                var aniNode = player.node.getChildByName("aniNode");
                if (aniNode) aniNode.removeAllChildren();
              }

              var floor = null;

              for (var _j = 0; _j < _this2.FloorList.length; _j++) {
                var tFloor = _this2.FloorList[_j].getComponent(FloorCtrl);

                if (tFloor) {
                  if (info.id == tFloor.idx.toString()) {
                    floor = _this2.FloorList[_j];
                    break;
                  }
                }
              }

              if (floor) {
                var starNode = floor.getChildByName("starNode");

                if (starNode) {
                  starNode.removeAllChildren();
                }
              }
            }
          };

          for (var i = 0; i < mapInfo.length; i++) {
            _loop(i);
          }
        } //更新角色
        ;

        _proto.updateRole = function updateRole(info, isNeedBack) {
          // info.id,
          // info.type,
          // info.uid,
          // info.gold
          // info.isMe
          // 创建角色
          // console.log(`updateGridList updateRole start info.uid = ${info.uid}`);
          var player = null;

          for (var j = 0; j < this.PlayerList.length; j++) {
            var tPlayer = this.PlayerList[j].getComponent(PlayerCtrl);

            if (info.id == tPlayer.idx.toString()) {
              player = tPlayer;
              break;
            }
          } //设置uid，便于定位自己位置


          player.uid = lodash.cloneDeep(info.uid); //这里确定哪个角色是自己，然后确定箭头方向

          if (info.isMe) {
            this.myIdx = parseInt(info.id);
            this.myPlayerCtrl = player;
            player.initArrowState();
          }

          var aniNode = player.node.getChildByName("aniNode");

          if (isNeedBack) {
            player.init();
            player.backToStartFloor();
          } else {
            player.backToStartFloor();
            PoolManager.Instance.putNode(aniNode.children[0]); // aniNode.removeAllChildren();

            var modelPath = SKIN_MODEL_PATH + info.roleId;
            var decorateModelPath = SKIN_MODEL_PATH + info.roleId + "Decorate" + info.skinId;
            var skinPath = SKIN_MAT_PATH + info.roleId + "Mat" + info.skinId;
            console.log("模型名称：", modelPath);
            console.log("模型皮肤名称：", skinPath);
            console.log("模型配件名称：", decorateModelPath);
            var modelPrefab = info.roleId == "1" ? GameApp.Instance.player1Prefab : GameApp.Instance.player2Prefab; // resources.load(modelPath, Prefab, (err, prefab) => {

            resources.load(skinPath, Material, function (err, mat) {
              if (!mat) {
                console.log("加载模型材质资源失败mat: " + mat);
                return;
              } // let role = instantiate(prefab) as Node;
              //把模型绑定到 aniNode 节点上
              // role.parent = aniNode;


              var role = PoolManager.Instance.getNode(modelPrefab, aniNode);
              var meshs = role.getComponentsInChildren(MeshRenderer);

              for (var i = 0; i < meshs.length; i++) {
                meshs[i].setMaterial(mat, 0);
              }

              var decorateNode = role.getChildByName("headNode Socket");
              decorateNode.removeAllChildren();
              resources.load(decorateModelPath, Prefab, function (err, decoratePrefab) {
                if (decoratePrefab) {
                  var decorate = PoolManager.Instance.getNode(decoratePrefab, decorateNode); // let decorate = instantiate(decoratePrefab) as Node;
                  // decorate.parent = decorateNode;

                  console.log("安装模型配件成功,配件名称：", decoratePrefab.name, "父类节点模型：", role.name, "player uid:", player.uid);
                }
              }); //更新骨骼动画文件引用

              player.sa = role === null || role === void 0 ? void 0 : role.getComponent(SkeletalAnimation);
              player.runIdleAnimation();
            }); // });
          }
        } //更新星星
        ;

        _proto.updateStar = function updateStar(info) {
          var _this3 = this; // 创建星星


          var floor = null;

          for (var j = 0; j < this.FloorList.length; j++) {
            var tFloor = this.FloorList[j].getComponent(FloorCtrl);

            if (tFloor) {
              if (info.id == tFloor.idx) {
                floor = this.FloorList[j];
                break;
              }
            }
          }

          var starNode = floor.getChildByName("starNode");

          if (starNode) {
            starNode.removeAllChildren(); //todo 设置金币值，最多容纳25个
            // info.gold = (info.gold > 10) ? 9 : info.gold;

            var gold = info.gold;
            var idx = gold > 9 ? 9 : gold;

            for (var i = 0; i < idx; i++) {
              var star = PoolManager.Instance.getNode(GameApp.Instance.starPrefab, starNode);
              var x = StarPosData[idx][i].x;
              var y = StarPosData[idx][i].y;
              var z = StarPosData[idx][i].z; // console.log("info.gold = " + info.gold, " i = " + i, StarPosData[idx][i]);

              star.setPosition(v3(x, y, z));
            }

            if (gold > 9) {
              ResourceUtil.loadModelRes("prefab/star/scoreNode").then(function (prefab) {
                var scoreNode = PoolManager.Instance.getNode(prefab, starNode);
                var num1 = scoreNode === null || scoreNode === void 0 ? void 0 : scoreNode.getChildByName("num1");
                var num2 = scoreNode === null || scoreNode === void 0 ? void 0 : scoreNode.getChildByName("num2");
                var mesh1 = num1.getComponent(MeshRenderer);
                var mesh2 = num2 === null || num2 === void 0 ? void 0 : num2.getComponent(MeshRenderer);
                var idx1 = Math.floor(info.gold / 10);
                var idx2 = info.gold % 10;
                mesh1.setMaterial(_this3.numMtlList[idx1], 0);
                mesh2.setMaterial(_this3.numMtlList[idx2], 0);
              });
            }
          }
        } // 执行玩家跳跃,金币飞行动画，更新UI金币值
        ;

        _proto.moveModel = function moveModel(settleData, scoreNode) {
          var _this4 = this;

          var _loop2 = function _loop2(i) {
            var playerCtl = _this4.PlayerList[i].getComponent(PlayerCtrl);

            playerCtl === null || playerCtl === void 0 ? void 0 : playerCtl.initArrowState(); // console.log("GriderHandler moveModel playerCtl?.uid = " + playerCtl?.uid + "  settleData.uid = " + settleData.uid);

            if ((playerCtl === null || playerCtl === void 0 ? void 0 : playerCtl.uid) == settleData.uid) {
              // 找到目标地板
              var idx = settleData.gridNo - 1;
              var targetFloor = _this4.FloorList[idx]; //更新用户得分数据

              if (!settleData.isFail) {
                if (settleData.uid == GameApp.Instance.data.uId) {
                  var _GameApp$Instance$mai;

                  var tip = "恭喜你获得 " + settleData.gold + " 个星星！";
                  (_GameApp$Instance$mai = GameApp.Instance.mainUICtrl) === null || _GameApp$Instance$mai === void 0 ? void 0 : _GameApp$Instance$mai.updateLabel(tip);
                  console.log(tip);
                }
              }

              playerCtl === null || playerCtl === void 0 ? void 0 : playerCtl.jumpToDest(targetFloor, settleData.isHitted, function () {
                if (!settleData.isFail) {
                  playerCtl.showHuodeEffect();
                }

                _this4.scheduleOnce(function () {
                  //旋转回来
                  playerCtl === null || playerCtl === void 0 ? void 0 : playerCtl.rotateBack();

                  if (!settleData.isFail) {
                    playerCtl.runWinAnimation();
                    GameApp.Instance.playWinEffect(settleData.uid);
                  } else {
                    if (!settleData.isHitted) playerCtl.runFailAnimation();
                  }
                }, 0.5); // 找到目标点星星


                var stars = targetFloor.getChildByName("starNode");
                if (!stars) return;

                if (settleData.isFail || settleData.isHitted) {
                  // stars.removeFromParent();
                  return;
                } // 金币飞行


                var isNeedFixNum = stars.children.length > 9 ? true : false;

                for (var j = 0; j < stars.children.length; j++) {
                  var star = stars.children[j];

                  if (star.name != "star") {
                    star.removeFromParent();
                    continue;
                  }

                  var sc = star.addComponent(StarFlyingCtrl);
                  sc.starFlying(settleData.starPos, function () {
                    if (scoreNode) {
                      // let label = scoreNode.getComponent(LabelComponent);
                      // let str = parseInt(label?.string as string) + 1;
                      // label!.string = str.toString();
                      // console.log("settleData = " + JSON.stringify(settleData));
                      // let len = stars?.children.length! - 1;
                      // if (j == len && isNeedFixNum) {
                      //     label!.string = settleData.score.toString();
                      //     stars?.removeAllChildren();
                      // }
                      var label = scoreNode.getComponent(LabelComponent);
                      console.log("settleData = " + JSON.stringify(settleData));
                      label.string = settleData.score.toString();
                    }
                  });
                }

                AudioManager.Instance.playSound(SoundName.EFFECT_GET_SCORE); // SoundMgr.Instance.play_effect(SoundName.EFFECT_GET_SCORE);
              });
            }
          };

          for (var i = 0; i < this.PlayerList.length; i++) {
            _loop2(i);
          }
        };

        _proto.onDestroy = function onDestroy() {
          EventMgr.Instance.RemoveListenner(GameEnum.EventPlayerPressedLeft, this, this.btnLeftCallback);
          EventMgr.Instance.RemoveListenner(GameEnum.EventPlayerPressedRight, this, this.btnRightCallback);
          EventMgr.Instance.RemoveListenner(GameEnum.EventPlayerPressedUp, this, this.btnUpCallback);
          EventMgr.Instance.RemoveListenner(GameEnum.EventPlayerPressedDown, this, this.btnDownCallback);
          EventMgr.Instance.RemoveListenner(GameEnum.EventPlayerPressedCenter, this, this.btnCenterCallback);
        };

        return GridHandler;
      }(Component), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "PlayerList", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "FloorList", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "numMtlList", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UIMgr.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './ResMgr.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, ButtonComponent, find, instantiate, Component, _inheritsLoose, _defineProperty, _assertThisInitialized, ResMgr;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      ButtonComponent = module.ButtonComponent;
      find = module.find;
      instantiate = module.instantiate;
      Component = module.Component;
    }, function (module) {
      _inheritsLoose = module.inheritsLoose;
      _defineProperty = module.defineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      ResMgr = module.ResMgr;
    }],
    execute: function () {
      cclegacy._RF.push({}, "8f638aGHDNOgatmInxi19wd", "UIMgr", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var UICtrl = exports('UICtrl', /*#__PURE__*/function (_Component) {
        _inheritsLoose(UICtrl, _Component);

        function UICtrl() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this), "view", {});

          return _this;
        }

        var _proto = UICtrl.prototype;

        _proto.loadAllObject = function loadAllObject(root, path) {
          for (var i = 0; i < root.children.length; i++) {
            this.view[path + root.children[i].name] = root.children[i];
            this.loadAllObject(root.children[i], path + root.children[i].name + "/");
          }
        };

        _proto.onLoad = function onLoad() {
          this.view = {};
          this.loadAllObject(this.node, "");
        };

        _proto.addButtonListen = function addButtonListen(view_node, caller, func) {
          // var view_node = this.view[view_name];
          // if (!view_node) {
          //     console.log("节点未找到 节点名：" + view_name);
          //     return;
          // }
          var button = view_node.getComponent(ButtonComponent);

          if (!button) {
            return;
          }

          view_node.on(ButtonComponent.EventType.CLICK, func, caller);
        };

        return UICtrl;
      }(Component));
      var UIMgr = exports('UIMgr', /*#__PURE__*/function (_Component2) {
        _inheritsLoose(UIMgr, _Component2);

        function UIMgr() {
          var _this2;

          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          _this2 = _Component2.call.apply(_Component2, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this2), "Canvas", null);

          return _this2;
        }

        var _proto2 = UIMgr.prototype;

        _proto2.onLoad = function onLoad() {
          if (UIMgr.Instance === null) {
            UIMgr.Instance = this;
          } else {
            this.destroy();
            return;
          }

          this.Canvas = find("Canvas");
        };

        _proto2.showUI = function showUI(ui_name, parent) {
          if (!parent) {
            parent = this.Canvas;
          }

          var prefab = ResMgr.Instance.getAsset("ui_prefabs/" + ui_name);
          var item = null;

          if (prefab) {
            item = instantiate(prefab);
            parent.addChild(item);
            item.addComponent(ui_name + "_Ctrl");
          }

          return item;
        };

        return UIMgr;
      }(Component));

      _defineProperty(UIMgr, "Instance", null);

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/FloorCtrl.ts", ['cc', './_rollupPluginModLoBabelHelpers.js'], function (exports) {
  'use strict';

  var cclegacy, _decorator, Component, _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }],
    execute: function () {
      var _dec, _class, _class2, _descriptor, _temp;

      cclegacy._RF.push({}, "90f57LZw5xEora5+oWkY+Mo", "FloorCtrl", undefined);

      var ccclass = _decorator.ccclass,
          integer = _decorator.integer,
          property = _decorator.property;
      var FloorCtrl = exports('FloorCtrl', (_dec = ccclass('FloorCtrl'), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function (_Component) {
        _inheritsLoose(FloorCtrl, _Component);

        function FloorCtrl() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_assertThisInitialized(_this), "idx", _descriptor, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = FloorCtrl.prototype;

        _proto.onLoad = function onLoad() {};

        _proto.start = function start() {};

        return FloorCtrl;
      }(Component), _temp), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "idx", [integer], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _class2)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/BridgeMgr.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './index.cjs.js', './index.cjs.mjs_cjs=&original=.js'], function (exports) {
  'use strict';

  var cclegacy, _decorator, _defineProperty, _createClass, _asyncToGenerator, _cjsExports;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }, function (module) {
      _defineProperty = module.defineProperty;
      _createClass = module.createClass;
      _asyncToGenerator = module.asyncToGenerator;
    }, function (module) {
      _cjsExports = module.default;
    }, null],
    execute: function () {
      var _dec, _class, _class2, _temp;

      cclegacy._RF.push({}, "97b38WLDdxLQ6VVTk0XKrd2", "BridgeMgr", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var Logger = _cjsExports.Logger;
      var BridgeMgr = exports('BridgeMgr', (_dec = ccclass("BridgeMgr"), _dec(_class = (_temp = _class2 = /*#__PURE__*/function () {
        function BridgeMgr() {}

        var _proto = BridgeMgr.prototype;

        _proto.getToken = function getToken() {
          var _GameAwesome$Bridge$d;

          return (_GameAwesome$Bridge$d = _cjsExports.Bridge.detail) === null || _GameAwesome$Bridge$d === void 0 ? void 0 : _GameAwesome$Bridge$d.accessToken;
        }
        /**
         * 游戏加载桥事件回调
         */
        ;

        _proto.gameLoadSuccess = function gameLoadSuccess() {
          _cjsExports.PkBridge.gameLoadSuccess();
        }
        /**
         * 通过桥获取房间事件
         */
        ;

        _proto.getRoomInfo = /*#__PURE__*/function () {
          var _getRoomInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var roomInfo;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return _cjsExports.PkBridge.getRoomInfo();

                  case 2:
                    roomInfo = _context.sent;
                    Logger.info("BridgeMgr getRoomInfo ", roomInfo);
                    return _context.abrupt("return", roomInfo);

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function getRoomInfo() {
            return _getRoomInfo.apply(this, arguments);
          }

          return getRoomInfo;
        }() // 本局游戏结束
        ;

        _proto.gameEnd = function gameEnd(data) {
          Logger.info("bridge 开始调用pk_game_end_info", JSON.stringify(data));

          _cjsExports.PkBridge.gameEnd(data);
        } // 最小化游戏
        ;

        _proto.miniPage = function miniPage() {
          Logger.info("bridge 开始调用gameMinimum");

          _cjsExports.PkBridge.gameMinimum();
        };

        _proto.helpPage = function helpPage() {
          Logger.info("bridge 开始调用帮助界面");
          window.location.href = "xiaoxingqiu://npage/live/halfweb?containerHeight=480&url=https://activity.hibixin.com/kelvin/release/290/623"; // if (GameAwesome.Bridge.app.isYppPC) {
          //     GameAwesome.Bridge.call('page_open', {
          //         url: 'https://web.xxqapp.cn/pandora/2018',
          //     });
          // }
          // else {
          // }
        } // 头像开麦涟漪（全部还是当前直播间）
        ;

        _proto.listenTalkInfo = function listenTalkInfo(cb) {
          Logger.info("bridge 开始调用gameTalkNotify");

          _cjsExports.PkBridge.gameTalkNotify(function (data) {
            console.log('头像开麦涟漪业务方回调', data);
            cb && cb(data);
          }); // GameAwesome.PkBridge.gameTalkNotify((data: any) => {
          //     Logger.info("bridge 结束调用gameTalkNotify，返回data: ", data);
          //     data = typeof data === 'string' ? JSON.parse(data) : data;
          //     const _data = typeof data.data === 'string' ? JSON.parse(data.data) : data.data;
          //     const res = typeof _data.res === 'string' ? JSON.parse(_data.res) : _data.res;
          //     if (cb && res) {
          //         cb(res);
          //     }
          // });

        } // 开闭麦状态（全部还是当前直播间）
        ;

        _proto.listenMicStatus = function listenMicStatus(cb) {
          Logger.info("bridge 开始监听pk_game_mic_status");

          _cjsExports.PkBridge.gameMicNotify(function (data) {
            console.log('开闭麦状态业务方回调', data);
            cb && cb(data); // Logger.info("bridge 监听成功pk_game_mic_status，返回res: ", data);
            // // 监听音脉关闭操作
            // data = typeof data === 'string' ? JSON.parse(data) : data;
            // const _data = typeof data.data === 'string' ? JSON.parse(data.data) : data.data;
            // const res = typeof _data.res === 'string' ? JSON.parse(_data.res) : _data.res;
            // if (cb && res) {
            //     cb(res);
            // }
          });

          Logger.info("bridge 开始调用pk_game_mic_status");

          _cjsExports.PkBridge.gameMicStatus().then(function (data) {
            Logger.info("bridge 结束调用pk_game_mic_status res: ", data); // 监听音脉关闭操作

            if (cb && data) {
              cb(data);
            }
          });
        };

        _proto.listenPCKeyBoardEvent = function listenPCKeyBoardEvent(cb) {
          Logger.info("bridge 开始监听pk_game_keyboard_event");

          _cjsExports.PkBridge.onKeyboard(function (res) {
            Logger.info("bridge 监听到pk_game_keyboard_event事件，res= ", JSON.stringify(res));

            if (cb) {
              cb(res);
            }
          });
        } //头像点击事件
        ;

        _proto.clickHeader = function clickHeader(uid) {
          Logger.info("bridge 开始调用pk_game_avatar_click");

          _cjsExports.PkBridge.handleGameAvatar(uid);
        }
        /**
         * 震动设备
         */
        ;

        _proto.shakeDevice = function shakeDevice(shakeType, duration) {
          if (duration === void 0) {
            duration = 300;
          } // type: 'short' | 'long' | 'weak-in' | 'weak-out' | 'fast',
          // duration: 300,  // 震动持续时间，单位ms


          Logger.info("bridge 开始调用pk_game_shake shakeType = ", shakeType, " duration = ", duration);

          _cjsExports.PkBridge.handleShake(shakeType, duration);
        }
        /**
         * 提示
         * showToast
         */
        ;

        _proto.showToast = function showToast(msg, inType) {// Bridge.call('ui_showToast', {
        };

        _createClass(BridgeMgr, null, [{
          key: "Instance",
          get: function get() {
            if (this._instance) {
              return this._instance;
            }

            this._instance = new BridgeMgr();
            return this._instance;
          }
        }]);

        return BridgeMgr;
      }(), _defineProperty(_class2, "_instance", void 0), _temp)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/lodash.ts", ['cc', './_rollupPluginModLoBabelHelpers.js'], function (exports) {
  'use strict';

  var cclegacy, _decorator, _defineProperty;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }, function (module) {
      _defineProperty = module.defineProperty;
    }],
    execute: function () {
      var _dec, _class, _class2, _temp;

      cclegacy._RF.push({}, "984ef3qSIRJ65ZhDis82mKO", "lodash", undefined);

      var ccclass = _decorator.ccclass;
      var lodash = exports('lodash', (_dec = ccclass("lodash"), _dec(_class = (_temp = _class2 = /*#__PURE__*/function () {
        function lodash() {}
        /* class member could be defined like this */
        // dummy = '';

        /**
         * 遍历 collection（集合）元素，返回 predicate（断言函数）第一个返回真值的第一个元素
         * @param  {any} collection 一个用来迭代的集合
         * @param {Function} predicate 每次迭代调用的函数。
         * @returns 返回匹配元素，否则返回 undefined。
         */


        lodash.find = function find(collection, predicate) {
          var result;

          if (!Array.isArray(collection)) {
            collection = lodash._toArray(collection);
          }

          result = collection.filter(predicate);

          if (result.length) {
            return result[0];
          }

          return undefined;
        }
        /**
         * 调用 iteratee 遍历 collection(集合) 中的每个元素
         * @param  {any} collection 一个用来迭代的集合
         * @param {Function} iteratee 每次迭代调用的函数。
         */
        ;

        lodash.forEach = function forEach(collection, iteratee) {
          if (!Array.isArray(collection)) {
            var array = lodash._toArrayKey(collection);

            array.forEach(function (value, index, arr) {
              var key1 = value['key'];
              var value1 = value['value'];
              iteratee(value1, key1, collection);
            });
          } else {
            collection.forEach(iteratee);
          }
        }
        /**
         * 深度拷贝
         * @param {any} sObj 拷贝的对象
         * @returns 
         */
        ;

        lodash.cloneDeep = function cloneDeep(sObj) {
          if (sObj === null || typeof sObj !== "object") {
            return sObj;
          }

          var s = {};

          if (sObj.constructor === Array) {
            s = [];
          }

          for (var i in sObj) {
            if (sObj.hasOwnProperty(i)) {
              s[i] = lodash.cloneDeep(sObj[i]);
            }
          }

          return s;
        }
        /**
         * 创建一个数组， value（值） 是 iteratee（迭代函数）遍历 collection（集合）中的每个元素后返回的结果。
         * @param {Array|Object} collection  一个用来迭代的集合.
         * @param {Function} predicate  一个迭代函数，用来转换key（键
         * @returns {Array} 返回一个组成集合数组
         */
        ;

        lodash.map = function map(collection, iteratee) {
          if (!Array.isArray(collection)) {
            collection = lodash._toArray(collection);
          }

          var arr = [];
          collection.forEach(function (value, index, array) {
            arr.push(iteratee(value, index, array));
          });
          return arr;
        }
        /**
         * 
         * @param srcObj 
         * @returns 
         */
        ;

        lodash._toArrayKey = function _toArrayKey(srcObj) {
          var resultArr = []; // to array

          for (var key in srcObj) {
            if (!srcObj.hasOwnProperty(key)) {
              continue;
            }

            resultArr.push({
              key: key,
              value: srcObj[key]
            });
          }

          return resultArr;
        };

        lodash._toArray = function _toArray(srcObj) {
          var resultArr = []; // to array

          for (var key in srcObj) {
            if (!srcObj.hasOwnProperty(key)) {
              continue;
            }

            resultArr.push(srcObj[key]);
          }

          return resultArr;
        }
        /**
         * 遍历 collection（集合）元素，返回 predicate（断言函数）返回真值 的所有元素的数组。
         * @param {Array|Object} collection  一个用来迭代的集合.
         * @param {Function} predicate  一个迭代函数，用来转换key（键
         * @returns 返回一个新的过滤后的数组。
         */
        ;

        lodash.filter = function filter(collection, iteratees) {
          if (!Array.isArray(collection)) {
            collection = lodash._toArray(collection);
          }

          return collection.filter(iteratees);
        }
        /**
         * 执行深比较来确定两者的值是否相等。
         * @param {any}x 
         * @param {any}y 
         * @returns {boolean} 如果 两个值完全相同，那么返回 true，否则返回 false。
         */
        ;

        lodash.isEqual = function isEqual(x, y) {
          var in1 = x instanceof Object;
          var in2 = y instanceof Object;

          if (!in1 || !in2) {
            return x === y;
          }

          if (Object.keys(x).length !== Object.keys(y).length) {
            return false;
          }

          for (var p in x) {
            var a = x[p] instanceof Object;
            var b = y[p] instanceof Object;

            if (a && b) {
              return lodash.isEqual(x[p], y[p]);
            } else if (x[p] !== y[p]) {
              return false;
            }
          }

          return true;
        }
        /**
         * 接收一个要移除值的数组。
         * @param {Array} array 修改的数组
         * @param {Array} value 移除值的数组
         * @param  {Function} comparator comparator（比较器）调用每个元素。
         * @returns 
         */
        ;

        lodash.pullAllWith = function pullAllWith(array, value, comparator) {
          value.forEach(function (item) {
            var res = array.filter(function (n) {
              return comparator(n, item);
            });
            res.forEach(function (item) {
              var index = array.indexOf(item);

              if (array.indexOf(item) !== -1) {
                array.splice(index, 1);
              }
            });
          });
          return array;
        }
        /**
         * 返回当前时间戳
         * @returns 
         */
        ;

        lodash.now = function now() {
          return Date.now();
        }
        /**
         * 接收一个要移除值的数组。
         * @param {Array} array 修改的数组
         * @param {Array} value 移除值的数组
         * @returns 
         */
        ;

        lodash.pullAll = function pullAll(array, value) {
          value.forEach(function (item) {
            var index = array.indexOf(item);

            if (array.indexOf(item) !== -1) {
              array.splice(index, 1);
            }
          });
          return array;
        }
        /**
         * 从右到左遍历集合中每一个元素的。
         * @param {Array|Object} collection  一个用来迭代的集合.
         * @param {Function} predicate  一个迭代函数
         */
        ;

        lodash.forEachRight = function forEachRight(collection, iteratee) {
          if (!Array.isArray(collection)) {
            collection = lodash._toArray(collection);
          } //@ts-ignore


          for (var i = collection.length - 1; i >= 0; i--) {
            //@ts-ignore
            var ret = iteratee(collection[i]);
            if (!ret) break;
          }
        }
        /**
         * 检查字符串string是否以 target 开头。
         * @param {string} str 要检索的字符串。
         * @param {string}target  要检查的字符串。
         * @param {number}position 检索的位置。
         * @returns 
         */
        ;

        lodash.startsWith = function startsWith(str, target, position) {
          str = str.substr(position);
          return str.startsWith(target);
        }
        /**
         * 检查字符串string是否以 target 结束。
         * @param {string} str 要检索的字符串。
         * @param {string}target  要检查的字符串。
         * @param {number}position 检索的位置。
         * @returns 
         */
        ;

        lodash.endsWith = function endsWith(str, target, position) {
          str = str.substr(position);
          return str.endsWith(target);
        }
        /**
         * 移除数组中predicate（断言）返回为真值的所有元素
         * @param {Array} array  一个用来迭代的集合.
         * @param {Function} predicate  一个迭代函数
         * @returns 
         */
        ;

        lodash.remove = function remove(array, predicate) {
          var result = [];
          var indexes = [];
          array.forEach(function (item, index) {
            if (predicate(item)) {
              result.push(item);
              indexes.push(index);
            }
          });

          lodash._basePullAt(array, indexes);

          return result;
        };

        lodash._basePullAt = function _basePullAt(array, indexes) {
          var length = array ? indexes.length : 0;
          var lastIndex = length - 1;
          var previous;

          while (length--) {
            var index = indexes[length];

            if (length === lastIndex || index !== previous) {
              previous = index;
              Array.prototype.splice.call(array, index, 1);
            }
          }

          return array;
        }
        /**
         * 返回第一个通过 predicate 判断为真值的元素的索引值
         * @param {Array} array  一个用来迭代的集合.
         * @param {Function} predicate  一个迭代函数
         * @param {number} fromIndex 开始查找索引值
         * @returns 
         */
        ;

        lodash.findIndex = function findIndex(array, predicate, fromIndex) {
          array = array.slice(fromIndex);
          var i;

          if (typeof predicate === "function") {
            for (i = 0; i < array.length; i++) {
              if (predicate(array[i])) {
                return i;
              }
            }
          } else if (Array.isArray(predicate)) {
            for (i = 0; i < array.length; i++) {
              var key = predicate[0];
              var vaule = true; //@ts-ignore

              if (predicate.length > 1) {
                vaule = predicate[1];
              }

              if (array[i][key] === vaule) {
                return i;
              }
            }
          } else {
            for (i = 0; i < array.length; i++) {
              if (array[i] === predicate) {
                return i;
              }
            }
          }

          return -1;
        }
        /**
         * 创建一个新数组，将array与任何数组 或 值连接在一起。
         * @returns 
         */
        ;

        lodash.concat = function concat() {
          var length = arguments.length;

          if (!length) {
            return [];
          }

          var array = arguments[0];
          var index = 1;

          while (index < length) {
            array = array.concat(arguments[index]);
            index++;
          }

          return array;
        }
        /**
         * 检查 value 是否是原始Number数值型 或者 对象。
         * @param {any }value 
         * @returns 
         */
        ;

        lodash.isNumber = function isNumber(value) {
          return typeof value === 'number';
        }
        /**
         * 返回首次 value 在数组array中被找到的 索引值
         * @param {Array}array 
         * @param {any}value 
         * @param {number} fromIndex 
         * @returns 
         */
        ;

        lodash.indexOf = function indexOf(array, value, fromIndex) {
          array = array.slice(fromIndex);
          return array.indexOf(value);
        }
        /**
         * 将 array 中的所有元素转换为由 separator 分隔的字符串。
         * @param {any} array 要转换的数组
         * @param {string} separator 分隔元素。
         * @returns 
         */
        ;

        lodash.join = function join(array, separator) {
          if (array === null) return '';
          var result = '';
          array.forEach(function (item) {
            result += item + separator;
          });
          return result.substr(0, result.length - 1);
        }
        /**
         * 根据separator 拆分字符串string。
         * @param {string} str 要转换的数组
         * @param {RegExp|string} separator 分隔元素。
         * @param {number} limit 限制结果的数量。
         * @returns 
         */
        ;

        lodash.split = function split(str, separator, limit) {
          return str.split(separator, limit);
        }
        /**
         * 计算 array 中的最大值。 如果 array 是 空的或者假值将会返回 undefined。
         * @param {Array}array 
         * @returns 
         */
        ;

        lodash.max = function max(array) {
          if (array && array.length) {
            var result;

            for (var i = 0; i < array.length; i++) {
              if (i === 0) {
                result = array[0];
              } else if (result < array[i]) {
                result = array[i];
              }
            }

            return result;
          }

          return undefined;
        }
        /**
         * 创建一个切片数组，去除array前面的n个元素。（n默认值为1。）
         * @param {Array}array : 要查询的数组。
         * @param {number}n 要去除的元素个数。
         * @returns 
         */
        ;

        lodash.drop = function drop(array, n) {
          var length = array === null ? 0 : array.length;

          if (!length) {
            return [];
          }

          return array.slice(n);
        }
        /**
         * 将array递归为一维数组。
         * @param {Array} arr 
         * @returns 
         */
        ;

        lodash.flattenDeep = function flattenDeep(arr) {
          return arr.reduce(function (prev, cur) {
            return prev.concat(Array.isArray(cur) ? lodash.flattenDeep(cur) : cur);
          }, []);
        }
        /**
         * 创建一个去重后的array数组副本。使用了SameValueZero 做等值比较。只有第一次出现的元素才会被保留。
         * @param {Array} array 
         * @returns 
         */
        ;

        lodash.uniq = function uniq(array) {
          var result = [];
          array.forEach(function (item) {
            if (result.indexOf(item) === -1) {
              result.push(item);
            }
          });
          return result;
        }
        /**
         * 检查 value 是否是 NaN。
         * @param {any}value 
         * @returns 
         */
        ;

        lodash.isNaN = function isNaN(value) {
          // An `NaN` primitive is the only value that is not equal to itself.
          // Perform the `toStringTag` check first to avoid errors with some
          // ActiveX objects in IE.
          return lodash.isNumber(value) && value !== +value;
        }
        /**
         * 将数组（array）拆分成多个 size 长度的区块，并将这些区块组成一个新数组
         * @param {Array}array 
         * @param {number}size 
         * @returns 
         */
        ;

        lodash.chunk = function chunk(array, size) {
          var length = array === null ? 0 : array.length;

          if (!length || size < 1) {
            return [];
          }

          var result = [];

          while (array.length > size) {
            result.push(array.slice(0, size));
            array = array.slice(size);
          }

          result.push(array);
          return result;
        }
        /**
         * 转换 value 为一个有限数字
         * @param {any} value 
         * @returns 
         */
        ;

        lodash.toFinite = function toFinite(value) {
          var INFINITY = 1 / 0;
          var MAX_INTEGER = 1.7976931348623157e+308;

          if (!value) {
            return value === 0 ? value : 0;
          }

          value = Number(value);

          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }

          return value === value ? value : 0;
        }
        /**
         * 判断是否为对象
         * @param {any}value  
         * @returns {boolean}
         */
        ;

        lodash.isObject = function isObject(value) {
          var type = typeof value;
          return value !== null && (type === 'object' || type === 'function');
        };
        /**
         * 
         * @param value 
         * @returns 
         */


        lodash.isLength = function isLength(value) {
          return typeof value === 'number' && value > -1 && value % 1 === 0 && value <= lodash.MAX_SAFE_INTEGER;
        };

        lodash._isArrayLike = function _isArrayLike(value) {
          return value !== null && lodash.isLength(value.length)
          /*&& !isFunction(value)*/
          ;
        }
        /**
         * 返回数组总符合条件的最大值
         * @param {Array} array  一个用来迭代的集合.
         * @param {Function} predicate  一个迭代函数
         * @returns {Object} 返回最大值
         */
        ;

        lodash.maxBy = function maxBy(array, predicate) {
          if (array && array.length) {
            var result;
            var objResult;

            for (var i = 0; i < array.length; i++) {
              if (i === 0) {
                result = predicate(array[0]);
                objResult = array[0];
              } else if (result < array[i]) {
                result = array[i];
                objResult = array[i];
              }
            }

            return objResult;
          }

          return undefined;
        }
        /**
         * 返回数组总符合条件的最小值
         * @param {Array} array  一个用来迭代的集合.
         * @param {Function} predicate  一个迭代函数
         * @returns {Object} 返回最小值
         */
        ;

        lodash.minBy = function minBy(array, predicate) {
          if (array && array.length) {
            var result;
            var objResult;

            for (var i = 0; i < array.length; i++) {
              if (i === 0) {
                result = predicate(array[0]);
                objResult = array[0];
              } else if (result > array[i]) {
                result = predicate(array[i]);
                objResult = array[i];
              }
            }

            return objResult;
          }

          return undefined;
        }
        /**
         * 返回复合迭代函数的总和
         * @param {Array|Object} collection  一个用来迭代的集合.
         * @param {Function} predicate  一个迭代函数
         * @returns {Object} 返回总和
         */
        ;

        lodash.sumBy = function sumBy(collection, predicate) {
          var sum = 0;

          for (var _key in collection) {
            //@ts-ignore
            sum += predicate(collection[_key]);
          }

          return sum;
        }
        /**
         * 返回复合迭代函数的次数
         * @param {Array|Object} collection  一个用来迭代的集合.
         * @param {Function} predicate  一个迭代函数，用来转换key（键
         * @returns {Object} 返回一个组成集合对象
         */
        ;

        lodash.countBy = function countBy(collection, predicate) {
          var objRet = {};

          for (var _key2 in collection) {
            var value = predicate(_key2);

            if (objRet.hasOwnProperty(value)) {
              objRet[value] += 1;
            } else {
              objRet[value] = 1;
            }
          }

          return objRet;
        };

        return lodash;
      }(), _defineProperty(_class2, "MAX_SAFE_INTEGER", 9007199254740991), _temp)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/WebviewMgr.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './index.cjs.js', './index.cjs.mjs_cjs=&original=.js', './GameConstants.ts'], function (exports) {
  'use strict';

  var cclegacy, _defineProperty, _cjsExports, GAME_ID;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      _defineProperty = module.defineProperty;
    }, function (module) {
      _cjsExports = module.default;
    }, null, function (module) {
      GAME_ID = module.GAME_ID;
    }],
    execute: function () {
      cclegacy._RF.push({}, "a4965j62bNGBpQOCggKEJMH", "WebviewMgr", undefined);

      var Logger = _cjsExports.Logger;
      var WebviewMgr = exports('default', /*#__PURE__*/function () {
        function WebviewMgr() {
          _defineProperty(this, "_webview", void 0);

          this._webview = new _cjsExports.PkWebview(GAME_ID, false);

          this._webview.create();

          Logger.info("bridge this.webview created ", JSON.stringify(this._webview));
        }
        /**
         * 本局开始弹窗
         */


        var _proto = WebviewMgr.prototype;

        _proto.showGameStart = function showGameStart(data) {
          this._webview.emit('game', data);

          Logger.info("bridge this.webview showGameStart ", data);
        }
        /**
         * 关卡开始弹窗
         */
        ;

        _proto.showRoundStart = function showRoundStart(data) {
          this._webview.emit('round', {
            show: true,
            // 是否显示
            gameNo: data.gameNo,
            // 对局No
            roundNo: data.roundNo // 回合No

          });

          Logger.info("bridge this.webview showRoundStart ", data);
        };

        return WebviewMgr;
      }());

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ColliderConfig.ts", ['cc'], function (exports) {
  'use strict';

  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      exports('ColliderType', void 0);

      cclegacy._RF.push({}, "a54bfnUxxRBuqgoAErJby5V", "ColliderConfig", undefined);
      /**
       * @Author: liubeizhang
       * @Date: 2021-08-23 10:46:00 
       * 物理碰撞配置文件
       */


      var ColliderType;

      (function (ColliderType) {
        ColliderType[ColliderType["Box"] = 0] = "Box";
        ColliderType[ColliderType["Cylinder"] = 1] = "Cylinder";
      })(ColliderType || (ColliderType = exports('ColliderType', {})));

      var ColliderConfig = exports('ColliderConfig', function ColliderConfig() {});

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UserHeader_Ctrl.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './index.cjs.js', './index.cjs.mjs_cjs=&original=.js', './UIMgr.ts', './GameConstants.ts', './BridgeMgr.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, Label, sp, assetManager, SpriteFrame, Texture2D, Sprite, _inheritsLoose, _defineProperty, _assertThisInitialized, _cjsExports, UICtrl, PlayerState, BridgeMgr;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Label = module.Label;
      sp = module.sp;
      assetManager = module.assetManager;
      SpriteFrame = module.SpriteFrame;
      Texture2D = module.Texture2D;
      Sprite = module.Sprite;
    }, function (module) {
      _inheritsLoose = module.inheritsLoose;
      _defineProperty = module.defineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      _cjsExports = module.default;
    }, null, function (module) {
      UICtrl = module.UICtrl;
    }, function (module) {
      PlayerState = module.PlayerState;
    }, function (module) {
      BridgeMgr = module.BridgeMgr;
    }],
    execute: function () {
      var _dec, _class, _temp;

      cclegacy._RF.push({}, "a8abdImfNdKGoZELElSOg1o", "UserHeader_Ctrl", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var Logger = _cjsExports.Logger;
      var UserHeader_Ctrl = exports('UserHeader_Ctrl', (_dec = ccclass('UserHeader_Ctrl'), _dec(_class = (_temp = /*#__PURE__*/function (_UICtrl) {
        _inheritsLoose(UserHeader_Ctrl, _UICtrl);

        function UserHeader_Ctrl() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _UICtrl.call.apply(_UICtrl, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this), "uid", "");

          _defineProperty(_assertThisInitialized(_this), "talkAniNode", null);

          return _this;
        }

        var _proto = UserHeader_Ctrl.prototype;

        _proto.onLoad = function onLoad() {
          _UICtrl.prototype.onLoad.call(this);

          this.talkAniNode = this.view["header/maskNode/talkAni"];
          var score = this.view["score"];
          var label = score.getComponent(Label);
          label.spacingX = -3.5;
          this.view["mute_bg"].active = false;
          this.view["score"].getComponent(Label).string = "0";
          this.updateAvatar("https://g.yppstatic.com/common/avatar/yrlive_normal.png");
          this.addButtonListen(this.node, this, this.onPressed);
        };

        _proto.start = function start() {} //用户开闭麦控制
        ;

        _proto.updateHeadMute = function updateHeadMute(isMute) {
          this.view["mute_bg"].active = isMute;
        } //更新麦位音波
        ;

        _proto.updateTalkSound = function updateTalkSound() {
          var _this2 = this;

          if (!this.talkAniNode.activeInHierarchy) {
            this.talkAniNode.active = true;
            var aniNode = this.talkAniNode.getComponent(sp.Skeleton);
            var n = aniNode.setAnimation(0, 'yinbo', true);
            aniNode.setTrackCompleteListener(n, function () {
              _this2.talkAniNode.active = false;
            });
          }
        } //禁用麦位音波
        ;

        _proto.disableTalkSound = function disableTalkSound() {
          this.talkAniNode.active = false;
        } // 发送头像点击事件
        ;

        _proto.onPressed = function onPressed() {
          Logger.info("头像点击事件发送");
          BridgeMgr.Instance.clickHeader(this.uid);
        } // 获取星星UI节点的位置
        ;

        _proto.getUIStarPos = function getUIStarPos(out) {
          var starNode = this.view["star"];
          var outScoreNode = this.view["score"]; // Logger.info("UserHeader_Ctrl getUIStarPos score node = " + outScoreNode.name);

          starNode.getWorldPosition(out);
          return outScoreNode;
        };

        _proto.updateState = function updateState(state) {
          this.view["header/maskNode/ofllineIcon"].active = state == PlayerState.OFFLINE ? true : false;
          this.view["header/maskNode/headerIconNode/headerIcon"].active = state == PlayerState.OFFLINE ? false : true;
        };

        _proto.updateHeaderData = function updateHeaderData(data) {
          if (!data) return;
          this.uid = data.uid;
          this.view["header/maskNode/ofllineIcon"].active = data.status == 0 ? true : false;
          this.view["header/maskNode/headerIconNode/headerIcon"].active = data.status == 0 ? false : true;
          this.view["score"].getComponent(Label).string = data.score ? data.score.toString() : "0"; //更新人物头像

          this.updateAvatar(data.avatar);
        } //更新用户头像
        ;

        _proto.updateAvatar = function updateAvatar(url) {
          var _this3 = this;

          if (!url) {
            this.view["header/maskNode/ofllineIcon"].active = true;
            this.view["header/maskNode/headerIconNode/headerIcon"].active = false;
            return;
          }

          assetManager.loadRemote(url, function (err, imageAsset) {
            if (!err && imageAsset) {
              var spriteFrame = new SpriteFrame();
              var texture = new Texture2D();
              texture.image = imageAsset;
              spriteFrame.texture = texture;
              _this3.view["header/maskNode/headerIconNode/headerIcon"].getComponent(Sprite).spriteFrame = spriteFrame;
              _this3.view["header/maskNode/ofllineIcon"].active = false;
              _this3.view["header/maskNode/headerIconNode/headerIcon"].active = true;
            } else {
              _this3.view["header/maskNode/ofllineIcon"].active = true;
              _this3.view["header/maskNode/headerIconNode/headerIcon"].active = false;
            }
          });
        } //更新人物形象
        ;

        _proto.updateRoleUI = function updateRoleUI(sp) {
          var spr = this.view["headLogo"].getComponent(Sprite);
          spr.spriteFrame = sp ? sp : null;
        };

        _proto.resetRoleUI = function resetRoleUI() {
          this.view["headLogo"].getComponent(Sprite).spriteFrame = null;
        };

        return UserHeader_Ctrl;
      }(UICtrl), _temp)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ColliderBase.ts", ['cc', './_rollupPluginModLoBabelHelpers.js'], function (exports) {
  'use strict';

  var cclegacy, _defineProperty;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      _defineProperty = module.defineProperty;
    }],
    execute: function () {
      cclegacy._RF.push({}, "aef8cSh+s1OHa5Sor0UXM2h", "ColliderBase", undefined);
      /**
       * @Author: liubeizhang
       * @Date: 2021-08-23 10:46:00 
       * 碰撞体抽象基类
       */


      var ColliderBase = exports('ColliderBase', /*#__PURE__*/function () {
        function ColliderBase() {
          _defineProperty(this, "colliders", []);
        }

        var _proto = ColliderBase.prototype;

        _proto.DetectContact = function DetectContact(collider, normal, bordersAdjust) {
          if (collider) {
            return this.DetectSphereContact(collider, normal, bordersAdjust);
          } else if (collider) {
            return this.DetectBoxContact(collider, normal, bordersAdjust);
          } else {
            return false;
          }
        };

        return ColliderBase;
      }());
      var CollisionInfo = exports('CollisionInfo', function CollisionInfo(collider, normal, bordersAdjust) {
        _defineProperty(this, "collider", null);

        _defineProperty(this, "normal", null);

        _defineProperty(this, "bordersAdjust", null);

        this.collider = collider;
        this.normal = normal;
        this.bordersAdjust = bordersAdjust;
      });

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MesssageMgr.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './index.cjs.js', './index.cjs.mjs_cjs=&original=.js', './GameConstants.ts', './lodash.ts', './BridgeMgr.ts', './long.js', './long.mjs_cjs=&original=.js', './GameApp.ts'], function (exports) {
  'use strict';

  var cclegacy, _createClass, _defineProperty, _cjsExports, GameWindowCountDownTime, RoundWindowCountDownTime, RoundStatus, DirIdxData, GameCountDownTime, GAME_ID, lodash, BridgeMgr, _cjsExports$1, GameApp;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      _createClass = module.createClass;
      _defineProperty = module.defineProperty;
    }, function (module) {
      _cjsExports = module.default;
    }, null, function (module) {
      GameWindowCountDownTime = module.GameWindowCountDownTime;
      RoundWindowCountDownTime = module.RoundWindowCountDownTime;
      RoundStatus = module.RoundStatus;
      DirIdxData = module.DirIdxData;
      GameCountDownTime = module.GameCountDownTime;
      GAME_ID = module.GAME_ID;
    }, function (module) {
      lodash = module.lodash;
    }, function (module) {
      BridgeMgr = module.BridgeMgr;
    }, function (module) {
      _cjsExports$1 = module.default;
    }, null, function (module) {
      GameApp = module.GameApp;
    }],
    execute: function () {
      cclegacy._RF.push({}, "b7927rTP2NCTquGJpgSxeLk", "MesssageMgr", undefined);

      var Logger = _cjsExports.Logger;
      var MesssageMgr = exports('default', /*#__PURE__*/function () {
        // private _onOpen: Function
        // private _onClose: Function
        // 本局开始倒计时定时器
        // 本轮开始倒计时定时器
        // 重连开始倒计时定时器
        // 加赛按钮动画减速定时器
        // 加赛结算定时器
        function MesssageMgr() {
          _defineProperty(this, "_msgMap", _cjsExports.Ws.getMsgMap());

          _defineProperty(this, "_isOffline", false);

          _defineProperty(this, "isConnect", false);

          _defineProperty(this, "gameStartCountDownTimer", 0);

          _defineProperty(this, "roundStartCountDownTimer", 0);

          _defineProperty(this, "reEnterCountDownTimer", 0);

          _defineProperty(this, "overTimeSlowDownTimer", 0);

          _defineProperty(this, "overTimeSettleTimer", 0);

          _cjsExports.Ws.config.gameId = parseInt(GAME_ID);
          _cjsExports.Ws.config.gameScene = 'xxq-pk'; // this._onOpen = listener.onOpen || (() => { })
          // this._onClose = listener.onClose || (() => { })
        }

        var _proto = MesssageMgr.prototype;

        _proto.connect = function connect(roomInfo) {
          _cjsExports.Ws.config.uid = roomInfo.uid;
          _cjsExports.Ws.config.roomId = roomInfo.roomId;

          if (roomInfo.isViewer) {
            _cjsExports.Ws.config.viewerId = roomInfo.viewerId;
          }

          this.wsListener();
          Logger.info('------------GameAwesome.Ws.config', _cjsExports.Ws.config);

          _cjsExports.Ws.connectWebsocket();
        };

        _proto.registerEvent = function registerEvent() {
          this.initBaseListener();
        };

        _proto.GameSnapshotResp = function GameSnapshotResp(e) {
          var _GameApp$Instance$mai; // 游戏未开始 显示加入面板 否则等待战斗通知


          var battleId = e.battleId;
          var battleIdStr = this.data.getLongStr(battleId);

          if (battleIdStr === '0') {
            Logger.info('游戏未开始');
          } else {
            this.data.battleId = battleIdStr;
          } // 更新开局快照数据


          this.data.leftDuel = [];
          this.data.rightDuel = [];
          this.data.updateGameSnapshotRespData(e.userInfos);
          (_GameApp$Instance$mai = GameApp.Instance.mainUICtrl) === null || _GameApp$Instance$mai === void 0 ? void 0 : _GameApp$Instance$mai.updateGameSnapshotRespUI({
            leftDuel: this.data.leftDuel,
            rightDuel: this.data.rightDuel,
            playerType: this.data.playerType,
            isPlayoff: this.data.isPlayoff,
            myData: this.data.myCurrentTurnData
          });
        } // 本局开始
        ;

        _proto.onGameStart = function onGameStart(udata) {
          var _GameApp$Instance$mai2; //整理数据，找出当前局和下一局


          this.data.updateGameStartData(udata); //弹webview

          var webViewData = this.data.getGameStartWebviewData();
          GameApp.Instance.webview.showGameStart(webViewData); //更新局开始事件UI回调

          (_GameApp$Instance$mai2 = GameApp.Instance.mainUICtrl) === null || _GameApp$Instance$mai2 === void 0 ? void 0 : _GameApp$Instance$mai2.updateGameStartUI({
            mapInfo: this.data.mapInfo
          }); //更新局开始场景地图数据

          GameApp.Instance.gridCtrl.updateGridList(this.data.mapInfo); //本局弹窗5400秒之后开始做倒计时处理

          if (this.gameStartCountDownTimer) clearTimeout(this.gameStartCountDownTimer);
          this.gameStartCountDownTimer = setTimeout(this.gameStartCountDownHandler.bind(this), GameWindowCountDownTime);
        } //本局弹窗5400秒之后开始做倒计时处理
        ;

        _proto.gameStartCountDownHandler = function gameStartCountDownHandler() {
          var _GameApp$Instance$mai3;

          if (this.gameStartCountDownTimer) clearTimeout(this.gameStartCountDownTimer);
          (_GameApp$Instance$mai3 = GameApp.Instance.mainUICtrl) === null || _GameApp$Instance$mai3 === void 0 ? void 0 : _GameApp$Instance$mai3.updateBottomCountDown({
            isPlayoff: this.data.isPlayoff,
            myData: this.data.myCurrentTurnData,
            roundStatus: this.data.roundStatus,
            roundCountdown: this.data.roundCountdown
          });
        } // 本轮开始
        ;

        _proto.onRoundStart = function onRoundStart(udata) {
          var _GameApp$Instance$mai4; // 基于数据刷新round数据


          this.data.updateRoundStartData(udata); // webview弹窗，第几局开始

          GameApp.Instance.webview.showRoundStart(udata);
          (_GameApp$Instance$mai4 = GameApp.Instance.mainUICtrl) === null || _GameApp$Instance$mai4 === void 0 ? void 0 : _GameApp$Instance$mai4.updateGameStartUI({
            mapInfo: this.data.mapInfo
          }); // 更新格子数据（第一局不需要更新，会在本局开始时更新好）

          GameApp.Instance.gridCtrl.updateGridList(this.data.mapInfo, true); //本轮弹窗1600秒之后开始做倒计时处理

          if (this.roundStartCountDownTimer) clearTimeout(this.roundStartCountDownTimer);
          this.roundStartCountDownTimer = setTimeout(this.roundStartCountDownHandler.bind(this), RoundWindowCountDownTime);
        } //本轮弹窗1600秒之后开始做倒计时处理
        ;

        _proto.roundStartCountDownHandler = function roundStartCountDownHandler() {
          var _GameApp$Instance$mai5;

          if (this.roundStartCountDownTimer) clearTimeout(this.roundStartCountDownTimer);
          (_GameApp$Instance$mai5 = GameApp.Instance.mainUICtrl) === null || _GameApp$Instance$mai5 === void 0 ? void 0 : _GameApp$Instance$mai5.updateBottomCountDown({
            isPlayoff: this.data.isPlayoff,
            myData: this.data.myCurrentTurnData,
            roundStatus: this.data.roundStatus,
            roundCountdown: this.data.roundCountdown
          });
        };

        _proto.sendChooseRequest = function sendChooseRequest(chooseIdx) {
          Logger.info("Star- this.data.roundNo: ", this.data.roundNo, " 发送位置数据：", {
            uid: _cjsExports$1.fromString(this.data.uId),
            roundNo: _cjsExports$1.fromNumber(this.data.roundNo),
            gridNo: chooseIdx
          }); //如果已经处于结算阶段，则所有的发送按钮操作都应该被屏蔽掉

          if (this.data.roundStatus == RoundStatus.IN_SETTLE) return;

          _cjsExports.Ws.sendMessage(this._msgMap.Star.GridChooseReq, {
            uid: _cjsExports$1.fromString(this.data.uId),
            roundNo: this.data.roundNo,
            gridNo: chooseIdx
          });
        } // 本轮结算
        ;

        _proto.onRoundSettle = function onRoundSettle(udata) {
          var _this = this;

          this.data.updateRoundSettleData(udata); // 如果是加赛情况，7秒钟数据就过来了，需要先降按钮速度，3秒之后执行跳的逻辑

          this.data.roundSettleData.forEach(function (element) {
            if (_this.data.isPlayoff == true) {
              setTimeout(function () {
                if (element.uid == _this.data.uId && _this.data.playerType >= 2) {
                  var idxList = DirIdxData[_this.data.myCurrentTurnData.id];
                  var offset = 0;

                  for (var i = 0; i < idxList.length; i++) {
                    if (element.gridNo == idxList[i]) {
                      offset = i;
                    }
                  }

                  GameApp.Instance.mainUICtrl.slowDown(offset, lodash.cloneDeep(element));
                }
              }, 2000, lodash.cloneDeep(element));
              setTimeout(function () {
                GameApp.Instance.collectStar(element);
              }, 3000, lodash.cloneDeep(element));
              GameApp.Instance.mainUICtrl.updateFinalRotate();
            } else {
              GameApp.Instance.collectStar(element);
            }
          });
        } //重连
        ;

        _proto.onReEnter = function onReEnter(udata) {
          var _GameApp$Instance$mai6;

          this.data.updateReEnterData(udata);
          (_GameApp$Instance$mai6 = GameApp.Instance.mainUICtrl) === null || _GameApp$Instance$mai6 === void 0 ? void 0 : _GameApp$Instance$mai6.updateReEnterRespUI({
            leftDuel: this.data.leftDuel,
            rightDuel: this.data.rightDuel,
            mapInfo: this.data.mapInfo
          });
          GameApp.Instance.gridCtrl.updateGridList(this.data.mapInfo); //如果重连过来的倒计时>1000，则说明还在动画播放期内，需要设置动画等待时间

          if (this.data.roundCountdown > GameCountDownTime / 1000) {
            var webviewWindowOffset = this.data.roundCountdown * 1000 - GameCountDownTime; //本轮弹窗1600秒之后开始做倒计时处理

            if (this.reEnterCountDownTimer) clearTimeout(this.reEnterCountDownTimer);
            this.reEnterCountDownTimer = setTimeout(this.reEnterCountDownHandler.bind(this), webviewWindowOffset);
          } else {
            this.reEnterCountDownHandler();
          }
        };

        _proto.reEnterCountDownHandler = function reEnterCountDownHandler() {
          var _GameApp$Instance$mai7;

          if (this.reEnterCountDownTimer) clearTimeout(this.reEnterCountDownTimer);
          var countdownData = GameCountDownTime / 1000;
          (_GameApp$Instance$mai7 = GameApp.Instance.mainUICtrl) === null || _GameApp$Instance$mai7 === void 0 ? void 0 : _GameApp$Instance$mai7.updateBottomCountDown({
            isPlayoff: this.data.isPlayoff,
            myData: this.data.myCurrentTurnData,
            roundStatus: this.data.roundStatus,
            roundCountdown: countdownData
          });
        } // 玩家状态更新
        ;

        _proto.onUserStatusChange = function onUserStatusChange(udata) {
          var _GameApp$Instance$mai8;

          this.data.updatePlayerStateData(udata);

          var uid = _cjsExports$1.fromValue(udata.uid).toString();

          (_GameApp$Instance$mai8 = GameApp.Instance.mainUICtrl) === null || _GameApp$Instance$mai8 === void 0 ? void 0 : _GameApp$Instance$mai8.updateUserOnlineState(uid, udata.changeType);
        } // 游戏结束
        ;

        _proto.onGameSettle = function onGameSettle(udata) {
          this.data.updateGameSettleData(udata);
          var winnnerAnchorUid = this.data.getLongStr(udata.winner.anchorUid);
          var winnnerMVPUid = this.data.getLongStr(udata.winner.mvp);
          var loserAnchorUid = this.data.getLongStr(udata.loser.anchorUid);
          var loserMVPUid = this.data.getLongStr(udata.loser.mvp);
          var winnnerUserInfos = [];
          var loserUserInfos = [];

          for (var i = 0; i < udata.winner.userInfo.length; i++) {
            var uid = this.data.getLongStr(udata.winner.userInfo[i].uid);
            var score = udata.winner.userInfo[i].score;
            winnnerUserInfos.push({
              uid: uid,
              score: score
            });
          }

          for (var _i = 0; _i < udata.loser.userInfo.length; _i++) {
            var _uid = this.data.getLongStr(udata.loser.userInfo[_i].uid);

            var _score = udata.loser.userInfo[_i].score;
            loserUserInfos.push({
              uid: _uid,
              score: _score
            });
          }

          var outData = {
            winner: {
              anchorUid: winnnerAnchorUid,
              mvp: winnnerMVPUid,
              score: udata.winner.score,
              userInfo: winnnerUserInfos
            },
            loser: {
              anchorUid: loserAnchorUid,
              mvp: loserMVPUid,
              score: udata.loser.score,
              userInfo: loserUserInfos
            }
          };
          BridgeMgr.Instance.gameEnd(outData);
        } // ----------网络事件handler end-----------
        ;

        _proto.initBaseListener = function initBaseListener() {
          var _this2 = this; // 游戏通用快照
          // this._msgMap.Message.GameSnapshotResp


          _cjsExports.Ws.on(-10201, function (e, extra) {
            Logger.info('Star-  -10201 游戏快照', JSON.stringify(e));

            if (e) {
              _this2.GameSnapshotResp(e);
            }
          }); // 通知游戏开始
          // this._msgMap.Star.GameStartNotify


          _cjsExports.Ws.on(-300, function (e, extra) {
            if (e) {
              _this2.isConnect = true;
              Logger.info('Star-  -300 游戏开始', JSON.stringify(e));

              _this2.onGameStart(e[0]);
            }
          }); // 本轮开始


          _cjsExports.Ws.on(this._msgMap.Star.RoundStartNotify, function (e, extra) {
            if (e) {
              Logger.info('Star-本轮开始', JSON.stringify(e));

              _this2.onRoundStart(e[0]);
            }
          }); // 本轮结算


          _cjsExports.Ws.on(this._msgMap.Star.RoundSettleNotify, function (e, extra) {
            if (e) {
              Logger.info('Star-本轮结算', JSON.stringify(e));

              _this2.onRoundSettle(e[0]);
            }
          }); // -500 重连，战斗快照


          _cjsExports.Ws.on(this._msgMap.Star.UserReEnterRes, function (e, extra) {
            Logger.info('Star- -500 战斗快照,用户重连', JSON.stringify(e));

            if (e) {
              _this2.onReEnter(e);
            }
          }); // -600 用户状态变更


          _cjsExports.Ws.on(this._msgMap.Star.UserStatusChangeNotify, function (e, extra) {
            if (e) {
              Logger.info('Star- -600 用户状态变更', JSON.stringify(e), "  uid = ", _this2.data.getLongStr(e[0].uid));

              _this2.onUserStatusChange(e[0]);
            }
          }); // 游戏结束通知
          // this._msgMap.Star.GameResultNotify


          _cjsExports.Ws.on(-999, function (e, extra) {
            if (e) {
              Logger.info('Star-游戏结束通知', JSON.stringify(e));

              _this2.onGameSettle(e[0]);
            }
          });
        };

        _proto.wsListener = function wsListener() {
          var _this3 = this; // 监听事件


          _cjsExports.Ws.onOpen(function () {
            Logger.info('ws onOpen');

            if (_this3._isOffline) {
              Logger.info('重联');
              _this3._isOffline = false; // this._onOpen()
            }
          });

          _cjsExports.Ws.onError(function () {
            if (!_this3._isOffline) {
              _this3.handleClose();
            }
          });

          _cjsExports.Ws.onClose(function () {
            Logger.info('ws onClose');

            if (!_this3._isOffline) {
              _this3.handleClose();
            }
          });
        };

        _proto.handleClose = function handleClose() {
          Logger.info('断线');
          this._isOffline = true; // this._onClose()

          _cjsExports.GameBridge.toast({
            message: '网络连接不稳定'
          });
        };

        _createClass(MesssageMgr, [{
          key: "data",
          get: function get() {
            return GameApp.Instance.data;
          }
        }]);

        return MesssageMgr;
      }());

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EffectManager.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './PoolMgr.ts', './ResourceUtil.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, find, ParticleSystemComponent, Component, _defineProperty, _inheritsLoose, _assertThisInitialized, _createClass, PoolManager, ResourceUtil;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      find = module.find;
      ParticleSystemComponent = module.ParticleSystemComponent;
      Component = module.Component;
    }, function (module) {
      _defineProperty = module.defineProperty;
      _inheritsLoose = module.inheritsLoose;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      PoolManager = module.PoolManager;
    }, function (module) {
      ResourceUtil = module.ResourceUtil;
    }],
    execute: function () {
      var _dec, _class, _class2, _temp;

      cclegacy._RF.push({}, "badf9x9kKdLwJyZYLLLXshz", "EffectManager", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var EffectManager = exports('EffectManager', (_dec = ccclass('EffectManager'), _dec(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(EffectManager, _Component);

        function EffectManager() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this), "_ndParent", null);

          return _this;
        }

        var _proto = EffectManager.prototype;
        /**
         * 播放粒子特效
         * @param {string} path 特效路径
         * @param {vec3} pos 特效世界坐标 
         * @param {number} eulerAnglesY 特效角度
         */

        _proto.playEffect = function playEffect(path, pos) {
          var _this2 = this;

          ResourceUtil.loadEffectRes(path).then(function (prefab) {
            var ndEffect = PoolManager.Instance.getNode(prefab, _this2.ndParent); // let ndEffect: Node = instantiate(prefab as Prefab) as Node;
            // ndEffect.parent = this.ndParent;

            ndEffect.setWorldPosition(pos);
            var par = find("EffectManager");
            ndEffect.parent = par;
            var maxDuration = 0;
            var arrParticle = ndEffect.getComponentsInChildren(ParticleSystemComponent);
            arrParticle.forEach(function (item) {
              item.simulationSpeed = 1;
              item === null || item === void 0 ? void 0 : item.clear();
              item === null || item === void 0 ? void 0 : item.stop();
              item === null || item === void 0 ? void 0 : item.play();
              var duration = item.duration;
              maxDuration = duration > maxDuration ? duration : maxDuration;
            });
            var seconds = maxDuration;
            setTimeout(function () {
              if (ndEffect.parent) {
                arrParticle.forEach(function (item) {
                  item === null || item === void 0 ? void 0 : item.clear();
                  item === null || item === void 0 ? void 0 : item.stop();
                }); // ndEffect.destroy()

                ndEffect.removeFromParent();
                PoolManager.Instance.putNode(ndEffect);
              }
            }, seconds * 1000);
          });
        };

        _createClass(EffectManager, [{
          key: "ndParent",
          get: function get() {
            if (!this._ndParent) {
              this._ndParent = find("effectManager");
            }

            return this._ndParent;
          }
        }], [{
          key: "Instance",
          get: function get() {
            if (this._instance) {
              return this._instance;
            }

            this._instance = new EffectManager();
            return this._instance;
          }
        }]);

        return EffectManager;
      }(Component), _defineProperty(_class2, "_instance", void 0), _temp)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ResourceUtil.ts", ['cc'], function (exports) {
  'use strict';

  var cclegacy, _decorator, resources, error, Prefab, Material, SpriteFrame, Texture2D, instantiate, find, isValid;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      resources = module.resources;
      error = module.error;
      Prefab = module.Prefab;
      Material = module.Material;
      SpriteFrame = module.SpriteFrame;
      Texture2D = module.Texture2D;
      instantiate = module.instantiate;
      find = module.find;
      isValid = module.isValid;
    }],
    execute: function () {
      var _dec, _class;

      cclegacy._RF.push({}, "bb3df5VPelBYJeK2B4pYU1G", "ResourceUtil", undefined);

      var ccclass = _decorator.ccclass;
      var ResourceUtil = exports('ResourceUtil', (_dec = ccclass("ResourceUtil"), _dec(_class = /*#__PURE__*/function () {
        function ResourceUtil() {}
        /**
        * 加载资源
        * @param url   资源路径
        * @param type  资源类型
        * @param cb    回调
        * @method loadRes
        */


        ResourceUtil.loadRes = function loadRes(url, type, cb) {
          if (cb === void 0) {
            cb = function cb() {};
          }

          resources.load(url, function (err, res) {
            if (err) {
              error(err.message || err);
              cb(err, res);
              return;
            }

            cb && cb(null, res);
          });
        }
        /**
         * 获取特效prefab
         * @param modulePath 路径
         * @returns 
         */
        ;

        ResourceUtil.loadEffectRes = function loadEffectRes(modulePath) {
          var _this = this;

          return new Promise(function (resolve, reject) {
            _this.loadRes("prefab/effect/" + modulePath, Prefab, function (err, prefab) {
              if (err) {
                console.error('effect load failed', modulePath);
                reject && reject();
                return;
              }

              resolve && resolve(prefab);
            });
          });
        }
        /**
         * 获取模型数据
         * @param modulePath 模型路径
         * @returns 
         */
        ;

        ResourceUtil.loadModelRes = function loadModelRes(modulePath) {
          var _this2 = this;

          return new Promise(function (resolve, reject) {
            _this2.loadRes("" + modulePath, Prefab, function (err, prefab) {
              if (err) {
                console.error("model load failed", modulePath);
                reject && reject();
                return;
              }

              resolve && resolve(prefab);
            });
          });
        }
        /**
         * 获取材质
         * @param matPath 路径
         * @returns 
         */
        ;

        ResourceUtil.loadMatRes = function loadMatRes(matPath) {
          var _this3 = this;

          return new Promise(function (resolve, reject) {
            _this3.loadRes("" + matPath, Material, function (err, mat) {
              if (err) {
                console.error('mat load failed', matPath);
                reject && reject();
                return;
              }

              resolve && resolve(mat);
            });
          });
        }
        /**
         * 获取多模型数据
         * @param path 资源路径
         * @param arrName 资源名称
         * @param progressCb 过程回调函数
         * @param completeCb 完成回调函数
         */
        ;

        ResourceUtil.loadModelResArr = function loadModelResArr(path, arrName, progressCb, completeCb) {
          var arrUrls = arrName.map(function (item) {
            return path + "/" + item;
          });
          resources.load(arrUrls, Prefab, progressCb, completeCb);
        }
        /**
         * 获取贴图资源
         * @param path 贴图路径
         * @returns 
         */
        ;

        ResourceUtil.loadSpriteFrameRes = function loadSpriteFrameRes(path) {
          var _this4 = this;

          return new Promise(function (resolve, reject) {
            _this4.loadRes(path, SpriteFrame, function (err, img) {
              if (err) {
                console.error('spriteFrame load failed!', path, err);
                reject && reject();
                return;
              }

              var texture = new Texture2D();
              texture.image = img;
              var sf = new SpriteFrame();
              sf.texture = texture;
              resolve && resolve(sf);
            });
          });
        }
        /**
         * 获取关卡数据
         * @param level 关卡
         * @param cb 回调函数
         */
        ;

        ResourceUtil.getMap = function getMap(level, cb) {
          var levelStr = 'map'; //前面补0

          if (level >= 100) {
            levelStr += level;
          } else if (level >= 10) {
            levelStr += '0' + level;
          } else {
            levelStr += '00' + level;
          }

          this.loadRes("map/config/" + levelStr, null, function (err, txtAsset) {
            if (err) {
              cb(err, txtAsset);
              return;
            }

            var content = '';

            if (txtAsset._file) {
              //@ts-ignore
              if (window['LZString']) {
                //@ts-ignore
                content = window['LZString'].decompressFromEncodedURIComponent(txtAsset._file);
              }

              var objJson = JSON.parse(content);
              cb(null, objJson);
            } else if (txtAsset.text) {
              //@ts-ignore
              if (window['LZString']) {
                //@ts-ignore
                content = window['LZString'].decompressFromEncodedURIComponent(txtAsset.text);
              }

              var objJson = JSON.parse(content);
              cb(null, objJson);
            } else if (txtAsset.json) {
              cb(null, txtAsset.json);
            } else {
              cb('failed');
            }
          });
        }
        /**
         * 获取关卡数据
         * @param type 关卡类型
         * @param arrName 资源名称
         * @param progressCb 过程回调函数
         * @param completeCb 完成回调函数
         */
        ;

        ResourceUtil.getMapObj = function getMapObj(type, arrName, progressCb, completeCb) {
          var arrUrls = [];

          for (var idx = 0; idx < arrName.length; idx++) {
            arrUrls.push("map/" + type + "/" + arrName[idx]);
          }

          resources.load(arrUrls, Prefab, progressCb, completeCb);
        }
        /**
         * 获取UI prefab
         * @param prefabPath prefab路径 
         * @param cb 回调函数
         */
        ;

        ResourceUtil.getUIPrefabRes = function getUIPrefabRes(prefabPath, cb) {
          this.loadRes("prefab/ui_prefabs/" + prefabPath, Prefab, cb);
        }
        /**
         * 创建ui界面
         * @param path ui路径
         * @param cb 回调函数
         * @param parent 父节点
         */
        ;

        ResourceUtil.createUI = function createUI(path, cb, parent) {
          this.getUIPrefabRes(path, function (err, prefab) {
            if (err) return;
            var node = instantiate(prefab);
            node.setPosition(0, 0, 0);

            if (!parent) {
              parent = find("Canvas");
            }

            parent.addChild(node);
            cb && cb(null, node);
          });
        }
        /**
         * 获取json数据
         * @param fileName 文件名
         * @param cb 回调函数 
         */
        ;

        ResourceUtil.getJsonData = function getJsonData(fileName, cb) {
          this.loadRes("datas/" + fileName, null, function (err, content) {
            if (err) {
              error(err.message || err);
              return;
            }

            if (content.json) {
              cb(err, content.json);
            } else {
              cb('failed!!!');
            }
          });
        }
        /**
         * 获取文本数据
         * @param fileName 文件名
         * @param cb  回调函数
         */
        ;

        ResourceUtil.getTextData = function getTextData(fileName, cb) {
          this.loadRes("datas/" + fileName, null, function (err, content) {
            if (err) {
              error(err.message || err);
              return;
            }

            var text = content.text;
            cb(err, text);
          });
        }
        /**
         * 设置精灵贴图
         * @param path 资源路径
         * @param sprite 精灵
         * @param cb 回调函数
         */
        ;

        ResourceUtil.setSpriteFrame = function setSpriteFrame(path, sprite, cb) {
          this.loadRes(path + '/spriteFrame', SpriteFrame, function (err, spriteFrame) {
            if (err) {
              console.error('set sprite frame failed! err:', path, err);
              cb(err);
              return;
            }

            if (sprite && isValid(sprite)) {
              sprite.spriteFrame = spriteFrame;
              cb(null);
            }
          });
        };

        return ResourceUtil;
      }()) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/matrix.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './Decimal.ts', './F.ts', './vector.ts'], function (exports) {
  'use strict';

  var cclegacy, _defineProperty, Decimal, Fe, Vector;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      _defineProperty = module.defineProperty;
    }, function (module) {
      Decimal = module.default;
    }, function (module) {
      Fe = module.Fe;
    }, function (module) {
      Vector = module.Vector;
    }],
    execute: function () {
      cclegacy._RF.push({}, "c02c8khNnNFuqhxPWWoI3nS", "matrix", undefined);
      /**
       * 2 * 2矩阵
       */


      var Matrix = exports('Matrix', /*#__PURE__*/function () {
        function Matrix(r1, r2) {
          _defineProperty(this, "r1", void 0);

          _defineProperty(this, "r2", void 0);

          this.r1 = new Vector(1, 0);
          this.r2 = new Vector(0, 1);

          if (r1 !== undefined && r2 !== undefined) {
            this.set(r1, r2);
          }
        }
        /**
         * 设置矩阵值
         * @param r1 
         * @param r2 
         */


        var _proto = Matrix.prototype;

        _proto.set = function set(r1, r2) {
          this.r1.x = r1.x;
          this.r1.y = r1.y;
          this.r2.x = r2.x;
          this.r2.y = r2.y;
        }
        /**
         * 矩阵相加
         * @param m
         * @param mOut 
         */
        ;

        _proto.add = function add(m, mOut) {
          var dest;

          if (mOut !== undefined) {
            dest = mOut;
          } else {
            dest = new Matrix();
          }

          dest.r1 = this.r1.add(m.r1, dest.r1);
          dest.r2 = this.r2.add(m.r2, dest.r2);
          return dest;
        }
        /**
         * 矩阵相减
         * @param m
         * @param mOut 
         */
        ;

        _proto.subtract = function subtract(m, mOut) {
          var dest;

          if (mOut !== undefined) {
            dest = mOut;
          } else {
            dest = new Matrix();
          }

          dest.r1 = this.r1.sub(m.r1, dest.r1);
          dest.r2 = this.r2.sub(m.r2, dest.r2);
          return dest;
        }
        /**
         * 矩阵相乘
         * @param m
         * @param mOut 
         */
        ;

        _proto.multiply = function multiply(m, mOut) {
          var dest;

          if (mOut !== undefined) {
            dest = mOut;
          } else {
            dest = new Matrix();
          }

          dest.r1.x = new Decimal(this.r1.x).mul(m.r1.x).add(new Decimal(this.r1.y).mul(m.r2.x)).toNumber();
          dest.r1.y = new Decimal(this.r1.x).mul(m.r1.y).add(new Decimal(this.r1.y).mul(m.r2.y)).toNumber();
          dest.r2.x = new Decimal(this.r2.x).mul(m.r1.x).add(new Decimal(this.r2.y).mul(m.r2.x)).toNumber();
          dest.r2.y = new Decimal(this.r2.x).mul(m.r1.y).add(new Decimal(this.r2.y).mul(m.r2.y)).toNumber();
          return dest;
        }
        /**
         * 矩阵与 2 维向量相乘
         * @param v 
         * @param vOut 
         */
        ;

        _proto.multiplyVec = function multiplyVec(v, vOut) {
          var dest;

          if (vOut !== undefined) {
            dest = vOut;
          } else {
            dest = new Vector();
          }

          dest.x = new Decimal(this.r1.x).mul(v.x).add(new Decimal(this.r1.y).mul(v.y)).toNumber();
          dest.y = new Decimal(this.r2.x).mul(v.x).add(new Decimal(this.r2.y).mul(v.y)).toNumber();
          return dest;
        }
        /**
         * 矩阵乘上一个数
         * @param n
         * @param mOut
         */
        ;

        _proto.multiplyNum = function multiplyNum(n, mOut) {
          var dest;

          if (mOut !== undefined) {
            dest = mOut;
          } else {
            dest = new Matrix();
          }

          dest.r1 = this.r1.scl(n, dest.r1);
          dest.r2 = this.r2.scl(n, dest.r2);
          return dest;
        }
        /**
         * 矩阵转置
         */
        ;

        _proto.transpose = function transpose() {
          var r1y = this.r1.y,
              r2x = this.r2.x;
          this.r1.y = r2x;
          this.r2.x = r1y;
          return this;
        }
        /**
         * 转换为单位矩阵
         */
        ;

        _proto.identity = function identity() {
          this.r1.x = this.r2.y = new Decimal(1).toNumber();
          this.r1.y = this.r2.x = 0;
          return this;
        }
        /**
         *  求矩阵行列式
         */
        ;

        _proto.determinant = function determinant() {
          return new Decimal(this.r1.x).mul(this.r2.y).sub(new Decimal(this.r1.y).mul(this.r2.x)).toNumber();
        }
        /**
         * 矩阵求逆
         * @param mOut 
         */
        ;

        _proto.invert = function invert(mOut) {
          var dest;

          if (mOut !== undefined) {
            dest = mOut;
          } else {
            dest = new Matrix();
          }

          var det = this.determinant();
          if (det === 0) return null;
          var r1x = this.r1.x,
              r1y = this.r1.y,
              r2x = this.r2.x,
              r2y = this.r2.y;
          dest.r1.x = r2y;
          dest.r1.y = new Decimal(r1y).mul(-1).toNumber();
          dest.r2.x = new Decimal(r2x).mul(-1).toNumber();
          dest.r2.y = r1x;
          dest = dest.multiplyNum(new Decimal(1).div(det).toNumber());
          return dest;
        }
        /**
         * 拷贝矩阵
         */
        ;

        _proto.clone = function clone() {
          var m = new Matrix();
          m.r1 = this.r1.col();
          m.r2 = this.r2.col();
          return m;
        }
        /**
         * 设置旋转矩阵
         * @param rad
         */
        ;

        _proto.rotate = function rotate(rad) {
          var sin = Fe.sin(rad).toNumber(),
              cos = Fe.cos(rad).toNumber();
          this.r1.x = cos;
          this.r1.y = new Decimal(sin).mul(-1).toNumber();
          this.r2.x = sin;
          this.r2.y = cos;
          return this;
        };

        return Matrix;
      }());

      var _tempMatrix1 = exports('_tempMatrix1', new Matrix());

      var _tempMatrix2 = exports('_tempMatrix2', new Matrix());

      var _tempMatrix3 = exports('_tempMatrix3', new Matrix());

      var _tempMatrix4 = exports('_tempMatrix4', new Matrix());

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AudienceBottomUI_Ctrl.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './index.cjs.js', './index.cjs.mjs_cjs=&original=.js', './UIMgr.ts', './GameConstants.ts', './BridgeMgr.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, LabelComponent, _inheritsLoose, _defineProperty, _assertThisInitialized, _cjsExports, UICtrl, Tips, BridgeMgr;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      LabelComponent = module.LabelComponent;
    }, function (module) {
      _inheritsLoose = module.inheritsLoose;
      _defineProperty = module.defineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      _cjsExports = module.default;
    }, null, function (module) {
      UICtrl = module.UICtrl;
    }, function (module) {
      Tips = module.Tips;
    }, function (module) {
      BridgeMgr = module.BridgeMgr;
    }],
    execute: function () {
      var _dec, _class, _temp;

      cclegacy._RF.push({}, "c0a0eIxtstH6JM6txh4gEmx", "AudienceBottomUI_Ctrl", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var Logger = _cjsExports.Logger;
      var AudienceBottomUI_Ctrl = exports('AudienceBottomUI_Ctrl', (_dec = ccclass('AudienceBottomUI_Ctrl'), _dec(_class = (_temp = /*#__PURE__*/function (_UICtrl) {
        _inheritsLoose(AudienceBottomUI_Ctrl, _UICtrl);

        function AudienceBottomUI_Ctrl() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _UICtrl.call.apply(_UICtrl, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this), "tipBG", null);

          _defineProperty(_assertThisInitialized(_this), "tipLabel", null);

          _defineProperty(_assertThisInitialized(_this), "btnHelp", null);

          _defineProperty(_assertThisInitialized(_this), "btnMini", null);

          _defineProperty(_assertThisInitialized(_this), "currentNo", 10);

          return _this;
        }

        var _proto = AudienceBottomUI_Ctrl.prototype;

        _proto.onLoad = function onLoad() {
          _UICtrl.prototype.onLoad.call(this);

          this.tipBG = this.view["tipsBG"];
          this.tipLabel = this.view["tipsBG/tipLabel"];
          this.btnHelp = this.view["audienceHelp/audienceHelpBtn"];
          this.btnMini = this.view["audienceMini/audienceMiniBtn"];
          this.addButtonListen(this.btnHelp, this, this.onPressAudienceHelp);
          this.addButtonListen(this.btnMini, this, this.onPressAudienceMini);
        } //更新快照数据
        ;

        _proto.updateSnapshotUI = function updateSnapshotUI() {
          this.tipBG.active = true;
          var tipLabel = this.tipLabel.getComponent(LabelComponent);
          if (tipLabel) tipLabel.string = Tips.tipRegStart;
        };

        _proto.updateLabel = function updateLabel(str) {
          this.unschedule(this.updateTimeTips);
          var tipLabel = this.tipLabel.getComponent(LabelComponent);
          if (tipLabel) tipLabel.string = str;
          this.tipBG.active = false;
        };

        _proto.updateTimeTips = function updateTimeTips() {
          var tipLabel = this.tipLabel.getComponent(LabelComponent);
          if (tipLabel) tipLabel.string = Tips.tipPlayerChoose + " " + this.currentNo + " s";
          this.currentNo--;
        };

        _proto.updateOperateBtnState = function updateOperateBtnState(leftShow, upShow, rightShow, downShow, centerShow) {} //更新本局或本轮开始数据
        ;

        _proto.updateGameStartUI = function updateGameStartUI(data) {
          this.tipBG.active = true;
          var tipLabel = this.tipLabel.getComponent(LabelComponent);
          if (tipLabel) tipLabel.string = Tips.tipPlayerChoose;
          this.currentNo = data.roundCountdown;
          this.updateTimeTips();
          this.schedule(this.updateTimeTips, 1, this.currentNo, 0);
        };

        _proto.start = function start() {};

        _proto.update = function update() {};

        _proto.onPressAudienceHelp = function onPressAudienceHelp() {
          Logger.info("onPressAudienceHelp");
          BridgeMgr.Instance.helpPage();
        };

        _proto.onPressAudienceMini = function onPressAudienceMini() {
          Logger.info("onPressAudienceMini");
          BridgeMgr.Instance.miniPage();
        };

        return AudienceBottomUI_Ctrl;
      }(UICtrl), _temp)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/fetch.umd.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      loader.define(module.meta.url, function (exports$1, _require, module, __filename, __dirname) {
        var require = loader.createRequireWithReqMap({}, _require);

        (function () {
          (function (global, factory) {
            typeof exports$1 === 'object' && typeof module !== 'undefined' ? factory(exports$1) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.WHATWGFetch = {});
          })(this, function (exports) {
            var global = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self || typeof global !== 'undefined' && global;
            var support = {
              searchParams: 'URLSearchParams' in global,
              iterable: 'Symbol' in global && 'iterator' in Symbol,
              blob: 'FileReader' in global && 'Blob' in global && function () {
                try {
                  new Blob();
                  return true;
                } catch (e) {
                  return false;
                }
              }(),
              formData: 'FormData' in global,
              arrayBuffer: 'ArrayBuffer' in global
            };

            function isDataView(obj) {
              return obj && DataView.prototype.isPrototypeOf(obj);
            }

            if (support.arrayBuffer) {
              var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

              var isArrayBufferView = ArrayBuffer.isView || function (obj) {
                return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
              };
            }

            function normalizeName(name) {
              if (typeof name !== 'string') {
                name = String(name);
              }

              if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
                throw new TypeError('Invalid character in header field name: "' + name + '"');
              }

              return name.toLowerCase();
            }

            function normalizeValue(value) {
              if (typeof value !== 'string') {
                value = String(value);
              }

              return value;
            } // Build a destructive iterator for the value list


            function iteratorFor(items) {
              var iterator = {
                next: function next() {
                  var value = items.shift();
                  return {
                    done: value === undefined,
                    value: value
                  };
                }
              };

              if (support.iterable) {
                iterator[Symbol.iterator] = function () {
                  return iterator;
                };
              }

              return iterator;
            }

            function Headers(headers) {
              this.map = {};

              if (headers instanceof Headers) {
                headers.forEach(function (value, name) {
                  this.append(name, value);
                }, this);
              } else if (Array.isArray(headers)) {
                headers.forEach(function (header) {
                  this.append(header[0], header[1]);
                }, this);
              } else if (headers) {
                Object.getOwnPropertyNames(headers).forEach(function (name) {
                  this.append(name, headers[name]);
                }, this);
              }
            }

            Headers.prototype.append = function (name, value) {
              name = normalizeName(name);
              value = normalizeValue(value);
              var oldValue = this.map[name];
              this.map[name] = oldValue ? oldValue + ', ' + value : value;
            };

            Headers.prototype['delete'] = function (name) {
              delete this.map[normalizeName(name)];
            };

            Headers.prototype.get = function (name) {
              name = normalizeName(name);
              return this.has(name) ? this.map[name] : null;
            };

            Headers.prototype.has = function (name) {
              return this.map.hasOwnProperty(normalizeName(name));
            };

            Headers.prototype.set = function (name, value) {
              this.map[normalizeName(name)] = normalizeValue(value);
            };

            Headers.prototype.forEach = function (callback, thisArg) {
              for (var name in this.map) {
                if (this.map.hasOwnProperty(name)) {
                  callback.call(thisArg, this.map[name], name, this);
                }
              }
            };

            Headers.prototype.keys = function () {
              var items = [];
              this.forEach(function (value, name) {
                items.push(name);
              });
              return iteratorFor(items);
            };

            Headers.prototype.values = function () {
              var items = [];
              this.forEach(function (value) {
                items.push(value);
              });
              return iteratorFor(items);
            };

            Headers.prototype.entries = function () {
              var items = [];
              this.forEach(function (value, name) {
                items.push([name, value]);
              });
              return iteratorFor(items);
            };

            if (support.iterable) {
              Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
            }

            function consumed(body) {
              if (body.bodyUsed) {
                return Promise.reject(new TypeError('Already read'));
              }

              body.bodyUsed = true;
            }

            function fileReaderReady(reader) {
              return new Promise(function (resolve, reject) {
                reader.onload = function () {
                  resolve(reader.result);
                };

                reader.onerror = function () {
                  reject(reader.error);
                };
              });
            }

            function readBlobAsArrayBuffer(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsArrayBuffer(blob);
              return promise;
            }

            function readBlobAsText(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsText(blob);
              return promise;
            }

            function readArrayBufferAsText(buf) {
              var view = new Uint8Array(buf);
              var chars = new Array(view.length);

              for (var i = 0; i < view.length; i++) {
                chars[i] = String.fromCharCode(view[i]);
              }

              return chars.join('');
            }

            function bufferClone(buf) {
              if (buf.slice) {
                return buf.slice(0);
              } else {
                var view = new Uint8Array(buf.byteLength);
                view.set(new Uint8Array(buf));
                return view.buffer;
              }
            }

            function Body() {
              this.bodyUsed = false;

              this._initBody = function (body) {
                /*
                  fetch-mock wraps the Response object in an ES6 Proxy to
                  provide useful test harness features such as flush. However, on
                  ES5 browsers without fetch or Proxy support pollyfills must be used;
                  the proxy-pollyfill is unable to proxy an attribute unless it exists
                  on the object before the Proxy is created. This change ensures
                  Response.bodyUsed exists on the instance, while maintaining the
                  semantic of setting Request.bodyUsed in the constructor before
                  _initBody is called.
                */
                this.bodyUsed = this.bodyUsed;
                this._bodyInit = body;

                if (!body) {
                  this._bodyText = '';
                } else if (typeof body === 'string') {
                  this._bodyText = body;
                } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                  this._bodyBlob = body;
                } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                  this._bodyFormData = body;
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this._bodyText = body.toString();
                } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                  this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.

                  this._bodyInit = new Blob([this._bodyArrayBuffer]);
                } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                  this._bodyArrayBuffer = bufferClone(body);
                } else {
                  this._bodyText = body = Object.prototype.toString.call(body);
                }

                if (!this.headers.get('content-type')) {
                  if (typeof body === 'string') {
                    this.headers.set('content-type', 'text/plain;charset=UTF-8');
                  } else if (this._bodyBlob && this._bodyBlob.type) {
                    this.headers.set('content-type', this._bodyBlob.type);
                  } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                    this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                  }
                }
              };

              if (support.blob) {
                this.blob = function () {
                  var rejected = consumed(this);

                  if (rejected) {
                    return rejected;
                  }

                  if (this._bodyBlob) {
                    return Promise.resolve(this._bodyBlob);
                  } else if (this._bodyArrayBuffer) {
                    return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                  } else if (this._bodyFormData) {
                    throw new Error('could not read FormData body as blob');
                  } else {
                    return Promise.resolve(new Blob([this._bodyText]));
                  }
                };

                this.arrayBuffer = function () {
                  if (this._bodyArrayBuffer) {
                    var isConsumed = consumed(this);

                    if (isConsumed) {
                      return isConsumed;
                    }

                    if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                      return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
                    } else {
                      return Promise.resolve(this._bodyArrayBuffer);
                    }
                  } else {
                    return this.blob().then(readBlobAsArrayBuffer);
                  }
                };
              }

              this.text = function () {
                var rejected = consumed(this);

                if (rejected) {
                  return rejected;
                }

                if (this._bodyBlob) {
                  return readBlobAsText(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                } else if (this._bodyFormData) {
                  throw new Error('could not read FormData body as text');
                } else {
                  return Promise.resolve(this._bodyText);
                }
              };

              if (support.formData) {
                this.formData = function () {
                  return this.text().then(decode);
                };
              }

              this.json = function () {
                return this.text().then(JSON.parse);
              };

              return this;
            } // HTTP methods whose capitalization should be normalized


            var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

            function normalizeMethod(method) {
              var upcased = method.toUpperCase();
              return methods.indexOf(upcased) > -1 ? upcased : method;
            }

            function Request(input, options) {
              if (!(this instanceof Request)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
              }

              options = options || {};
              var body = options.body;

              if (input instanceof Request) {
                if (input.bodyUsed) {
                  throw new TypeError('Already read');
                }

                this.url = input.url;
                this.credentials = input.credentials;

                if (!options.headers) {
                  this.headers = new Headers(input.headers);
                }

                this.method = input.method;
                this.mode = input.mode;
                this.signal = input.signal;

                if (!body && input._bodyInit != null) {
                  body = input._bodyInit;
                  input.bodyUsed = true;
                }
              } else {
                this.url = String(input);
              }

              this.credentials = options.credentials || this.credentials || 'same-origin';

              if (options.headers || !this.headers) {
                this.headers = new Headers(options.headers);
              }

              this.method = normalizeMethod(options.method || this.method || 'GET');
              this.mode = options.mode || this.mode || null;
              this.signal = options.signal || this.signal;
              this.referrer = null;

              if ((this.method === 'GET' || this.method === 'HEAD') && body) {
                throw new TypeError('Body not allowed for GET or HEAD requests');
              }

              this._initBody(body);

              if (this.method === 'GET' || this.method === 'HEAD') {
                if (options.cache === 'no-store' || options.cache === 'no-cache') {
                  // Search for a '_' parameter in the query string
                  var reParamSearch = /([?&])_=[^&]*/;

                  if (reParamSearch.test(this.url)) {
                    // If it already exists then set the value with the current time
                    this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
                  } else {
                    // Otherwise add a new '_' parameter to the end with the current time
                    var reQueryString = /\?/;
                    this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
                  }
                }
              }
            }

            Request.prototype.clone = function () {
              return new Request(this, {
                body: this._bodyInit
              });
            };

            function decode(body) {
              var form = new FormData();
              body.trim().split('&').forEach(function (bytes) {
                if (bytes) {
                  var split = bytes.split('=');
                  var name = split.shift().replace(/\+/g, ' ');
                  var value = split.join('=').replace(/\+/g, ' ');
                  form.append(decodeURIComponent(name), decodeURIComponent(value));
                }
              });
              return form;
            }

            function parseHeaders(rawHeaders) {
              var headers = new Headers(); // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
              // https://tools.ietf.org/html/rfc7230#section-3.2

              var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' '); // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
              // https://github.com/github/fetch/issues/748
              // https://github.com/zloirock/core-js/issues/751

              preProcessedHeaders.split('\r').map(function (header) {
                return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
              }).forEach(function (line) {
                var parts = line.split(':');
                var key = parts.shift().trim();

                if (key) {
                  var value = parts.join(':').trim();
                  headers.append(key, value);
                }
              });
              return headers;
            }

            Body.call(Request.prototype);

            function Response(bodyInit, options) {
              if (!(this instanceof Response)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
              }

              if (!options) {
                options = {};
              }

              this.type = 'default';
              this.status = options.status === undefined ? 200 : options.status;
              this.ok = this.status >= 200 && this.status < 300;
              this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
              this.headers = new Headers(options.headers);
              this.url = options.url || '';

              this._initBody(bodyInit);
            }

            Body.call(Response.prototype);

            Response.prototype.clone = function () {
              return new Response(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new Headers(this.headers),
                url: this.url
              });
            };

            Response.error = function () {
              var response = new Response(null, {
                status: 0,
                statusText: ''
              });
              response.type = 'error';
              return response;
            };

            var redirectStatuses = [301, 302, 303, 307, 308];

            Response.redirect = function (url, status) {
              if (redirectStatuses.indexOf(status) === -1) {
                throw new RangeError('Invalid status code');
              }

              return new Response(null, {
                status: status,
                headers: {
                  location: url
                }
              });
            };

            exports.DOMException = global.DOMException;

            try {
              new exports.DOMException();
            } catch (err) {
              exports.DOMException = function (message, name) {
                this.message = message;
                this.name = name;
                var error = Error(message);
                this.stack = error.stack;
              };

              exports.DOMException.prototype = Object.create(Error.prototype);
              exports.DOMException.prototype.constructor = exports.DOMException;
            }

            function fetch(input, init) {
              return new Promise(function (resolve, reject) {
                var request = new Request(input, init);

                if (request.signal && request.signal.aborted) {
                  return reject(new exports.DOMException('Aborted', 'AbortError'));
                }

                var xhr = new XMLHttpRequest();

                function abortXhr() {
                  xhr.abort();
                }

                xhr.onload = function () {
                  var options = {
                    status: xhr.status,
                    statusText: xhr.statusText,
                    headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                  };
                  options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                  var body = 'response' in xhr ? xhr.response : xhr.responseText;
                  setTimeout(function () {
                    resolve(new Response(body, options));
                  }, 0);
                };

                xhr.onerror = function () {
                  setTimeout(function () {
                    reject(new TypeError('Network request failed'));
                  }, 0);
                };

                xhr.ontimeout = function () {
                  setTimeout(function () {
                    reject(new TypeError('Network request failed'));
                  }, 0);
                };

                xhr.onabort = function () {
                  setTimeout(function () {
                    reject(new exports.DOMException('Aborted', 'AbortError'));
                  }, 0);
                };

                function fixUrl(url) {
                  try {
                    return url === '' && global.location.href ? global.location.href : url;
                  } catch (e) {
                    return url;
                  }
                }

                xhr.open(request.method, fixUrl(request.url), true);

                if (request.credentials === 'include') {
                  xhr.withCredentials = true;
                } else if (request.credentials === 'omit') {
                  xhr.withCredentials = false;
                }

                if ('responseType' in xhr) {
                  if (support.blob) {
                    xhr.responseType = 'blob';
                  } else if (support.arrayBuffer && request.headers.get('Content-Type') && request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1) {
                    xhr.responseType = 'arraybuffer';
                  }
                }

                if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
                  Object.getOwnPropertyNames(init.headers).forEach(function (name) {
                    xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
                  });
                } else {
                  request.headers.forEach(function (value, name) {
                    xhr.setRequestHeader(name, value);
                  });
                }

                if (request.signal) {
                  request.signal.addEventListener('abort', abortXhr);

                  xhr.onreadystatechange = function () {
                    // DONE (success or failure)
                    if (xhr.readyState === 4) {
                      request.signal.removeEventListener('abort', abortXhr);
                    }
                  };
                }

                xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
              });
            }

            fetch.polyfill = true;

            if (!global.fetch) {
              global.fetch = fetch;
              global.Headers = Headers;
              global.Request = Request;
              global.Response = Response;
            }

            exports.Headers = Headers;
            exports.Request = Request;
            exports.Response = Response;
            exports.fetch = fetch;
            Object.defineProperty(exports, '__esModule', {
              value: true
            });
          });
        })();

        _cjsExports = exports('default', module.exports);
      });

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);
    }
  };
});

System.register("chunks:///_virtual/protobuf-library.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      loader.define(module.meta.url, function (exports$1, _require, module, __filename, __dirname) {
        var require = loader.createRequireWithReqMap({}, _require);

        (function () {
          /*!
           * protobuf.js v6.8.4 (c) 2016, daniel wirtz
           * compiled thu, 04 jan 2018 21:51:39 utc
           * licensed under the bsd-3-clause license
           * see: https://github.com/dcodeio/protobuf.js for details
           */
          (function (global, undefined$1) {
            (function prelude(modules, cache, entries) {
              // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS
              // sources through a conflict-free require shim and is again wrapped within an iife that
              // provides a unified `global` and a minification-friendly `undefined` var plus a global
              // "use strict" directive so that minification can remove the directives of each module.
              function $require(name) {
                var $module = cache[name];
                if (!$module) modules[name][0].call($module = cache[name] = {
                  exports: {}
                }, $require, $module, $module.exports);
                return $module.exports;
              } // Expose globally


              var protobuf = global.protobuf = $require(entries[0]); // Be nice to AMD

              if (typeof define === "function" && define.amd) define(["long"], function (Long) {
                if (Long && Long.isLong) {
                  protobuf.util.Long = Long;
                  protobuf.configure();
                }

                return protobuf;
              }); // Be nice to CommonJS

              if (typeof module === "object" && module && module.exports) module.exports = protobuf;
            })(
            /* end of prelude */
            {
              1: [function (require, module, exports) {
                module.exports = asPromise;
                /**
                 * Callback as used by {@link util.asPromise}.
                 * @typedef asPromiseCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {...*} params Additional arguments
                 * @returns {undefined}
                 */

                /**
                 * Returns a promise from a node-style callback function.
                 * @memberof util
                 * @param {asPromiseCallback} fn Function to call
                 * @param {*} ctx Function context
                 * @param {...*} params Function arguments
                 * @returns {Promise<*>} Promisified function
                 */

                function asPromise(fn, ctx
                /*, varargs */
                ) {
                  var params = new Array(arguments.length - 1),
                      offset = 0,
                      index = 2,
                      pending = true;

                  while (index < arguments.length) {
                    params[offset++] = arguments[index++];
                  }

                  return new Promise(function executor(resolve, reject) {
                    params[offset] = function callback(err
                    /*, varargs */
                    ) {
                      if (pending) {
                        pending = false;
                        if (err) reject(err);else {
                          var params = new Array(arguments.length - 1),
                              offset = 0;

                          while (offset < params.length) {
                            params[offset++] = arguments[offset];
                          }

                          resolve.apply(null, params);
                        }
                      }
                    };

                    try {
                      fn.apply(ctx || null, params);
                    } catch (err) {
                      if (pending) {
                        pending = false;
                        reject(err);
                      }
                    }
                  });
                }
              }, {}],
              2: [function (require, module, exports) {
                /**
                 * A minimal base64 implementation for number arrays.
                 * @memberof util
                 * @namespace
                 */
                var base64 = exports;
                /**
                 * Calculates the byte length of a base64 encoded string.
                 * @param {string} string Base64 encoded string
                 * @returns {number} Byte length
                 */

                base64.length = function length(string) {
                  var p = string.length;
                  if (!p) return 0;
                  var n = 0;

                  while (--p % 4 > 1 && string.charAt(p) === "=") {
                    ++n;
                  }

                  return Math.ceil(string.length * 3) / 4 - n;
                }; // Base64 encoding table


                var b64 = new Array(64); // Base64 decoding table

                var s64 = new Array(123); // 65..90, 97..122, 48..57, 43, 47

                for (var i = 0; i < 64;) {
                  s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
                }
                /**
                 * Encodes a buffer to a base64 encoded string.
                 * @param {Uint8Array} buffer Source buffer
                 * @param {number} start Source start
                 * @param {number} end Source end
                 * @returns {string} Base64 encoded string
                 */


                base64.encode = function encode(buffer, start, end) {
                  var parts = null,
                      chunk = [];
                  var i = 0,
                      // output index
                  j = 0,
                      // goto index
                  t; // temporary

                  while (start < end) {
                    var b = buffer[start++];

                    switch (j) {
                      case 0:
                        chunk[i++] = b64[b >> 2];
                        t = (b & 3) << 4;
                        j = 1;
                        break;

                      case 1:
                        chunk[i++] = b64[t | b >> 4];
                        t = (b & 15) << 2;
                        j = 2;
                        break;

                      case 2:
                        chunk[i++] = b64[t | b >> 6];
                        chunk[i++] = b64[b & 63];
                        j = 0;
                        break;
                    }

                    if (i > 8191) {
                      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
                      i = 0;
                    }
                  }

                  if (j) {
                    chunk[i++] = b64[t];
                    chunk[i++] = 61;
                    if (j === 1) chunk[i++] = 61;
                  }

                  if (parts) {
                    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
                    return parts.join("");
                  }

                  return String.fromCharCode.apply(String, chunk.slice(0, i));
                };

                var invalidEncoding = "invalid encoding";
                /**
                 * Decodes a base64 encoded string to a buffer.
                 * @param {string} string Source string
                 * @param {Uint8Array} buffer Destination buffer
                 * @param {number} offset Destination offset
                 * @returns {number} Number of bytes written
                 * @throws {Error} If encoding is invalid
                 */

                base64.decode = function decode(string, buffer, offset) {
                  var start = offset;
                  var j = 0,
                      // goto index
                  t; // temporary

                  for (var i = 0; i < string.length;) {
                    var c = string.charCodeAt(i++);
                    if (c === 61 && j > 1) break;
                    if ((c = s64[c]) === undefined$1) throw Error(invalidEncoding);

                    switch (j) {
                      case 0:
                        t = c;
                        j = 1;
                        break;

                      case 1:
                        buffer[offset++] = t << 2 | (c & 48) >> 4;
                        t = c;
                        j = 2;
                        break;

                      case 2:
                        buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                        t = c;
                        j = 3;
                        break;

                      case 3:
                        buffer[offset++] = (t & 3) << 6 | c;
                        j = 0;
                        break;
                    }
                  }

                  if (j === 1) throw Error(invalidEncoding);
                  return offset - start;
                };
                /**
                 * Tests if the specified string appears to be base64 encoded.
                 * @param {string} string String to test
                 * @returns {boolean} `true` if probably base64 encoded, otherwise false
                 */


                base64.test = function test(string) {
                  return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
                };
              }, {}],
              3: [function (require, module, exports) {
                module.exports = codegen;
                /**
                 * Begins generating a function.
                 * @memberof util
                 * @param {string[]} functionParams Function parameter names
                 * @param {string} [functionName] Function name if not anonymous
                 * @returns {Codegen} Appender that appends code to the function's body
                 */

                function codegen(functionParams, functionName) {
                  /* istanbul ignore if */
                  if (typeof functionParams === "string") {
                    functionName = functionParams;
                    functionParams = undefined$1;
                  }

                  var body = [];
                  /**
                   * Appends code to the function's body or finishes generation.
                   * @typedef Codegen
                   * @type {function}
                   * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
                   * @param {...*} [formatParams] Format parameters
                   * @returns {Codegen|Function} Itself or the generated function if finished
                   * @throws {Error} If format parameter counts do not match
                   */

                  function Codegen(formatStringOrScope) {
                    // note that explicit array handling below makes this ~50% faster
                    // finish the function
                    if (typeof formatStringOrScope !== "string") {
                      var source = toString();
                      if (codegen.verbose) console.log("codegen: " + source); // eslint-disable-line no-console

                      source = "return " + source;

                      if (formatStringOrScope) {
                        var scopeKeys = Object.keys(formatStringOrScope),
                            scopeParams = new Array(scopeKeys.length + 1),
                            scopeValues = new Array(scopeKeys.length),
                            scopeOffset = 0;

                        while (scopeOffset < scopeKeys.length) {
                          scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                          scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                        }

                        scopeParams[scopeOffset] = source;
                        return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
                      }

                      return Function(source)(); // eslint-disable-line no-new-func
                    } // otherwise append to body


                    var formatParams = new Array(arguments.length - 1),
                        formatOffset = 0;

                    while (formatOffset < formatParams.length) {
                      formatParams[formatOffset] = arguments[++formatOffset];
                    }

                    formatOffset = 0;
                    formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
                      var value = formatParams[formatOffset++];

                      switch ($1) {
                        case "d":
                        case "f":
                          return String(Number(value));

                        case "i":
                          return String(Math.floor(value));

                        case "j":
                          return JSON.stringify(value);

                        case "s":
                          return String(value);
                      }

                      return "%";
                    });
                    if (formatOffset !== formatParams.length) throw Error("parameter count mismatch");
                    body.push(formatStringOrScope);
                    return Codegen;
                  }

                  function toString(functionNameOverride) {
                    return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
                  }

                  Codegen.toString = toString;
                  return Codegen;
                }
                /**
                 * Begins generating a function.
                 * @memberof util
                 * @function codegen
                 * @param {string} [functionName] Function name if not anonymous
                 * @returns {Codegen} Appender that appends code to the function's body
                 * @variation 2
                 */

                /**
                 * When set to `true`, codegen will log generated code to console. Useful for debugging.
                 * @name util.codegen.verbose
                 * @type {boolean}
                 */


                codegen.verbose = false;
              }, {}],
              4: [function (require, module, exports) {
                module.exports = EventEmitter;
                /**
                 * Constructs a new event emitter instance.
                 * @classdesc A minimal event emitter.
                 * @memberof util
                 * @constructor
                 */

                function EventEmitter() {
                  /**
                   * Registered listeners.
                   * @type {Object.<string,*>}
                   * @private
                   */
                  this._listeners = {};
                }
                /**
                 * Registers an event listener.
                 * @param {string} evt Event name
                 * @param {function} fn Listener
                 * @param {*} [ctx] Listener context
                 * @returns {util.EventEmitter} `this`
                 */


                EventEmitter.prototype.on = function on(evt, fn, ctx) {
                  (this._listeners[evt] || (this._listeners[evt] = [])).push({
                    fn: fn,
                    ctx: ctx || this
                  });
                  return this;
                };
                /**
                 * Removes an event listener or any matching listeners if arguments are omitted.
                 * @param {string} [evt] Event name. Removes all listeners if omitted.
                 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
                 * @returns {util.EventEmitter} `this`
                 */


                EventEmitter.prototype.off = function off(evt, fn) {
                  if (evt === undefined$1) this._listeners = {};else {
                    if (fn === undefined$1) this._listeners[evt] = [];else {
                      var listeners = this._listeners[evt];

                      for (var i = 0; i < listeners.length;) {
                        if (listeners[i].fn === fn) listeners.splice(i, 1);else ++i;
                      }
                    }
                  }
                  return this;
                };
                /**
                 * Emits an event by calling its listeners with the specified arguments.
                 * @param {string} evt Event name
                 * @param {...*} args Arguments
                 * @returns {util.EventEmitter} `this`
                 */


                EventEmitter.prototype.emit = function emit(evt) {
                  var listeners = this._listeners[evt];

                  if (listeners) {
                    var args = [],
                        i = 1;

                    for (; i < arguments.length;) {
                      args.push(arguments[i++]);
                    }

                    for (i = 0; i < listeners.length;) {
                      listeners[i].fn.apply(listeners[i++].ctx, args);
                    }
                  }

                  return this;
                };
              }, {}],
              5: [function (require, module, exports) {
                module.exports = fetch;

                var asPromise = require(1),
                    inquire = require(7);

                var fs = inquire("fs");
                /**
                 * Node-style callback as used by {@link util.fetch}.
                 * @typedef FetchCallback
                 * @type {function}
                 * @param {?Error} error Error, if any, otherwise `null`
                 * @param {string} [contents] File contents, if there hasn't been an error
                 * @returns {undefined}
                 */

                /**
                 * Options as used by {@link util.fetch}.
                 * @typedef FetchOptions
                 * @type {Object}
                 * @property {boolean} [binary=false] Whether expecting a binary response
                 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
                 */

                /**
                 * Fetches the contents of a file.
                 * @memberof util
                 * @param {string} filename File path or url
                 * @param {FetchOptions} options Fetch options
                 * @param {FetchCallback} callback Callback function
                 * @returns {undefined}
                 */

                function fetch(filename, options, callback) {
                  if (typeof options === "function") {
                    callback = options;
                    options = {};
                  } else if (!options) options = {};

                  if (!callback) return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this
                  // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.

                  if (!options.xhr && fs && fs.readFile) return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
                    return err && typeof XMLHttpRequest !== "undefined" ? fetch.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
                  }); // use the XHR version otherwise.

                  return fetch.xhr(filename, options, callback);
                }
                /**
                 * Fetches the contents of a file.
                 * @name util.fetch
                 * @function
                 * @param {string} path File path or url
                 * @param {FetchCallback} callback Callback function
                 * @returns {undefined}
                 * @variation 2
                 */

                /**
                 * Fetches the contents of a file.
                 * @name util.fetch
                 * @function
                 * @param {string} path File path or url
                 * @param {FetchOptions} [options] Fetch options
                 * @returns {Promise<string|Uint8Array>} Promise
                 * @variation 3
                 */

                /**/


                fetch.xhr = function fetch_xhr(filename, options, callback) {
                  var xhr = new XMLHttpRequest();

                  xhr.onreadystatechange
                  /* works everywhere */
                  = function fetchOnReadyStateChange() {
                    if (xhr.readyState !== 4) return undefined$1; // local cors security errors return status 0 / empty string, too. afaik this cannot be
                    // reliably distinguished from an actually empty file for security reasons. feel free
                    // to send a pull request if you are aware of a solution.

                    if (xhr.status !== 0 && xhr.status !== 200) return callback(Error("status " + xhr.status)); // if binary data is expected, make sure that some sort of array is returned, even if
                    // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.

                    if (options.binary) {
                      var buffer = xhr.response;

                      if (!buffer) {
                        buffer = [];

                        for (var i = 0; i < xhr.responseText.length; ++i) {
                          buffer.push(xhr.responseText.charCodeAt(i) & 255);
                        }
                      }

                      return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
                    }

                    return callback(null, xhr.responseText);
                  };

                  if (options.binary) {
                    // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
                    if ("overrideMimeType" in xhr) xhr.overrideMimeType("text/plain; charset=x-user-defined");
                    xhr.responseType = "arraybuffer";
                  }

                  xhr.open("GET", filename);
                  xhr.send();
                };
              }, {
                "1": 1,
                "7": 7
              }],
              6: [function (require, module, exports) {
                module.exports = factory(factory);
                /**
                 * Reads / writes floats / doubles from / to buffers.
                 * @name util.float
                 * @namespace
                 */

                /**
                 * Writes a 32 bit float to a buffer using little endian byte order.
                 * @name util.float.writeFloatLE
                 * @function
                 * @param {number} val Value to write
                 * @param {Uint8Array} buf Target buffer
                 * @param {number} pos Target buffer offset
                 * @returns {undefined}
                 */

                /**
                 * Writes a 32 bit float to a buffer using big endian byte order.
                 * @name util.float.writeFloatBE
                 * @function
                 * @param {number} val Value to write
                 * @param {Uint8Array} buf Target buffer
                 * @param {number} pos Target buffer offset
                 * @returns {undefined}
                 */

                /**
                 * Reads a 32 bit float from a buffer using little endian byte order.
                 * @name util.float.readFloatLE
                 * @function
                 * @param {Uint8Array} buf Source buffer
                 * @param {number} pos Source buffer offset
                 * @returns {number} Value read
                 */

                /**
                 * Reads a 32 bit float from a buffer using big endian byte order.
                 * @name util.float.readFloatBE
                 * @function
                 * @param {Uint8Array} buf Source buffer
                 * @param {number} pos Source buffer offset
                 * @returns {number} Value read
                 */

                /**
                 * Writes a 64 bit double to a buffer using little endian byte order.
                 * @name util.float.writeDoubleLE
                 * @function
                 * @param {number} val Value to write
                 * @param {Uint8Array} buf Target buffer
                 * @param {number} pos Target buffer offset
                 * @returns {undefined}
                 */

                /**
                 * Writes a 64 bit double to a buffer using big endian byte order.
                 * @name util.float.writeDoubleBE
                 * @function
                 * @param {number} val Value to write
                 * @param {Uint8Array} buf Target buffer
                 * @param {number} pos Target buffer offset
                 * @returns {undefined}
                 */

                /**
                 * Reads a 64 bit double from a buffer using little endian byte order.
                 * @name util.float.readDoubleLE
                 * @function
                 * @param {Uint8Array} buf Source buffer
                 * @param {number} pos Source buffer offset
                 * @returns {number} Value read
                 */

                /**
                 * Reads a 64 bit double from a buffer using big endian byte order.
                 * @name util.float.readDoubleBE
                 * @function
                 * @param {Uint8Array} buf Source buffer
                 * @param {number} pos Source buffer offset
                 * @returns {number} Value read
                 */
                // Factory function for the purpose of node-based testing in modified global environments

                function factory(exports) {
                  // float: typed array
                  if (typeof Float32Array !== "undefined") (function () {
                    var f32 = new Float32Array([-0]),
                        f8b = new Uint8Array(f32.buffer),
                        le = f8b[3] === 128;

                    function writeFloat_f32_cpy(val, buf, pos) {
                      f32[0] = val;
                      buf[pos] = f8b[0];
                      buf[pos + 1] = f8b[1];
                      buf[pos + 2] = f8b[2];
                      buf[pos + 3] = f8b[3];
                    }

                    function writeFloat_f32_rev(val, buf, pos) {
                      f32[0] = val;
                      buf[pos] = f8b[3];
                      buf[pos + 1] = f8b[2];
                      buf[pos + 2] = f8b[1];
                      buf[pos + 3] = f8b[0];
                    }
                    /* istanbul ignore next */


                    exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
                    /* istanbul ignore next */

                    exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

                    function readFloat_f32_cpy(buf, pos) {
                      f8b[0] = buf[pos];
                      f8b[1] = buf[pos + 1];
                      f8b[2] = buf[pos + 2];
                      f8b[3] = buf[pos + 3];
                      return f32[0];
                    }

                    function readFloat_f32_rev(buf, pos) {
                      f8b[3] = buf[pos];
                      f8b[2] = buf[pos + 1];
                      f8b[1] = buf[pos + 2];
                      f8b[0] = buf[pos + 3];
                      return f32[0];
                    }
                    /* istanbul ignore next */


                    exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
                    /* istanbul ignore next */

                    exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy; // float: ieee754
                  })();else (function () {
                    function writeFloat_ieee754(writeUint, val, buf, pos) {
                      var sign = val < 0 ? 1 : 0;
                      if (sign) val = -val;
                      if (val === 0) writeUint(1 / val > 0 ?
                      /* positive */
                      0 :
                      /* negative 0 */
                      2147483648, buf, pos);else if (isNaN(val)) writeUint(2143289344, buf, pos);else if (val > 3.4028234663852886e+38) // +-Infinity
                        writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);else if (val < 1.1754943508222875e-38) // denormal
                        writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);else {
                        var exponent = Math.floor(Math.log(val) / Math.LN2),
                            mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                        writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
                      }
                    }

                    exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
                    exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

                    function readFloat_ieee754(readUint, buf, pos) {
                      var uint = readUint(buf, pos),
                          sign = (uint >> 31) * 2 + 1,
                          exponent = uint >>> 23 & 255,
                          mantissa = uint & 8388607;
                      return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
                      ? sign * 1.401298464324817e-45 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
                    }

                    exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
                    exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
                  })(); // double: typed array

                  if (typeof Float64Array !== "undefined") (function () {
                    var f64 = new Float64Array([-0]),
                        f8b = new Uint8Array(f64.buffer),
                        le = f8b[7] === 128;

                    function writeDouble_f64_cpy(val, buf, pos) {
                      f64[0] = val;
                      buf[pos] = f8b[0];
                      buf[pos + 1] = f8b[1];
                      buf[pos + 2] = f8b[2];
                      buf[pos + 3] = f8b[3];
                      buf[pos + 4] = f8b[4];
                      buf[pos + 5] = f8b[5];
                      buf[pos + 6] = f8b[6];
                      buf[pos + 7] = f8b[7];
                    }

                    function writeDouble_f64_rev(val, buf, pos) {
                      f64[0] = val;
                      buf[pos] = f8b[7];
                      buf[pos + 1] = f8b[6];
                      buf[pos + 2] = f8b[5];
                      buf[pos + 3] = f8b[4];
                      buf[pos + 4] = f8b[3];
                      buf[pos + 5] = f8b[2];
                      buf[pos + 6] = f8b[1];
                      buf[pos + 7] = f8b[0];
                    }
                    /* istanbul ignore next */


                    exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
                    /* istanbul ignore next */

                    exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

                    function readDouble_f64_cpy(buf, pos) {
                      f8b[0] = buf[pos];
                      f8b[1] = buf[pos + 1];
                      f8b[2] = buf[pos + 2];
                      f8b[3] = buf[pos + 3];
                      f8b[4] = buf[pos + 4];
                      f8b[5] = buf[pos + 5];
                      f8b[6] = buf[pos + 6];
                      f8b[7] = buf[pos + 7];
                      return f64[0];
                    }

                    function readDouble_f64_rev(buf, pos) {
                      f8b[7] = buf[pos];
                      f8b[6] = buf[pos + 1];
                      f8b[5] = buf[pos + 2];
                      f8b[4] = buf[pos + 3];
                      f8b[3] = buf[pos + 4];
                      f8b[2] = buf[pos + 5];
                      f8b[1] = buf[pos + 6];
                      f8b[0] = buf[pos + 7];
                      return f64[0];
                    }
                    /* istanbul ignore next */


                    exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
                    /* istanbul ignore next */

                    exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy; // double: ieee754
                  })();else (function () {
                    function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
                      var sign = val < 0 ? 1 : 0;
                      if (sign) val = -val;

                      if (val === 0) {
                        writeUint(0, buf, pos + off0);
                        writeUint(1 / val > 0 ?
                        /* positive */
                        0 :
                        /* negative 0 */
                        2147483648, buf, pos + off1);
                      } else if (isNaN(val)) {
                        writeUint(0, buf, pos + off0);
                        writeUint(2146959360, buf, pos + off1);
                      } else if (val > 1.7976931348623157e+308) {
                        // +-Infinity
                        writeUint(0, buf, pos + off0);
                        writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
                      } else {
                        var mantissa;

                        if (val < 2.2250738585072014e-308) {
                          // denormal
                          mantissa = val / 5e-324;
                          writeUint(mantissa >>> 0, buf, pos + off0);
                          writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                        } else {
                          var exponent = Math.floor(Math.log(val) / Math.LN2);
                          if (exponent === 1024) exponent = 1023;
                          mantissa = val * Math.pow(2, -exponent);
                          writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                          writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                        }
                      }
                    }

                    exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
                    exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

                    function readDouble_ieee754(readUint, off0, off1, buf, pos) {
                      var lo = readUint(buf, pos + off0),
                          hi = readUint(buf, pos + off1);
                      var sign = (hi >> 31) * 2 + 1,
                          exponent = hi >>> 20 & 2047,
                          mantissa = 4294967296 * (hi & 1048575) + lo;
                      return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
                      ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
                    }

                    exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
                    exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
                  })();
                  return exports;
                } // uint helpers


                function writeUintLE(val, buf, pos) {
                  buf[pos] = val & 255;
                  buf[pos + 1] = val >>> 8 & 255;
                  buf[pos + 2] = val >>> 16 & 255;
                  buf[pos + 3] = val >>> 24;
                }

                function writeUintBE(val, buf, pos) {
                  buf[pos] = val >>> 24;
                  buf[pos + 1] = val >>> 16 & 255;
                  buf[pos + 2] = val >>> 8 & 255;
                  buf[pos + 3] = val & 255;
                }

                function readUintLE(buf, pos) {
                  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
                }

                function readUintBE(buf, pos) {
                  return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
                }
              }, {}],
              7: [function (require, module, exports) {
                module.exports = inquire;
                /**
                 * Requires a module only if available.
                 * @memberof util
                 * @param {string} moduleName Module to require
                 * @returns {?Object} Required module if available and not empty, otherwise `null`
                 */

                function inquire(moduleName) {
                  try {
                    var mod = eval("quire".replace(/^/, "re"))(moduleName); // eslint-disable-line no-eval

                    if (mod && (mod.length || Object.keys(mod).length)) return mod;
                  } catch (e) {} // eslint-disable-line no-empty


                  return null;
                }
              }, {}],
              8: [function (require, module, exports) {
                /**
                 * A minimal path module to resolve Unix, Windows and URL paths alike.
                 * @memberof util
                 * @namespace
                 */
                var path = exports;

                var isAbsolute =
                /**
                 * Tests if the specified path is absolute.
                 * @param {string} path Path to test
                 * @returns {boolean} `true` if path is absolute
                 */
                path.isAbsolute = function isAbsolute(path) {
                  return /^(?:\/|\w+:)/.test(path);
                };

                var normalize =
                /**
                 * Normalizes the specified path.
                 * @param {string} path Path to normalize
                 * @returns {string} Normalized path
                 */
                path.normalize = function normalize(path) {
                  path = path.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
                  var parts = path.split("/"),
                      absolute = isAbsolute(path),
                      prefix = "";
                  if (absolute) prefix = parts.shift() + "/";

                  for (var i = 0; i < parts.length;) {
                    if (parts[i] === "..") {
                      if (i > 0 && parts[i - 1] !== "..") parts.splice(--i, 2);else if (absolute) parts.splice(i, 1);else ++i;
                    } else if (parts[i] === ".") parts.splice(i, 1);else ++i;
                  }

                  return prefix + parts.join("/");
                };
                /**
                 * Resolves the specified include path against the specified origin path.
                 * @param {string} originPath Path to the origin file
                 * @param {string} includePath Include path relative to origin path
                 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
                 * @returns {string} Path to the include file
                 */


                path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
                  if (!alreadyNormalized) includePath = normalize(includePath);
                  if (isAbsolute(includePath)) return includePath;
                  if (!alreadyNormalized) originPath = normalize(originPath);
                  return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
                };
              }, {}],
              9: [function (require, module, exports) {
                module.exports = pool;
                /**
                 * An allocator as used by {@link util.pool}.
                 * @typedef PoolAllocator
                 * @type {function}
                 * @param {number} size Buffer size
                 * @returns {Uint8Array} Buffer
                 */

                /**
                 * A slicer as used by {@link util.pool}.
                 * @typedef PoolSlicer
                 * @type {function}
                 * @param {number} start Start offset
                 * @param {number} end End offset
                 * @returns {Uint8Array} Buffer slice
                 * @this {Uint8Array}
                 */

                /**
                 * A general purpose buffer pool.
                 * @memberof util
                 * @function
                 * @param {PoolAllocator} alloc Allocator
                 * @param {PoolSlicer} slice Slicer
                 * @param {number} [size=8192] Slab size
                 * @returns {PoolAllocator} Pooled allocator
                 */

                function pool(alloc, slice, size) {
                  var SIZE = size || 8192;
                  var MAX = SIZE >>> 1;
                  var slab = null;
                  var offset = SIZE;
                  return function pool_alloc(size) {
                    if (size < 1 || size > MAX) return alloc(size);

                    if (offset + size > SIZE) {
                      slab = alloc(SIZE);
                      offset = 0;
                    }

                    var buf = slice.call(slab, offset, offset += size);
                    if (offset & 7) // align to 32 bit
                      offset = (offset | 7) + 1;
                    return buf;
                  };
                }
              }, {}],
              10: [function (require, module, exports) {
                /**
                 * A minimal UTF8 implementation for number arrays.
                 * @memberof util
                 * @namespace
                 */
                var utf8 = exports;
                /**
                 * Calculates the UTF8 byte length of a string.
                 * @param {string} string String
                 * @returns {number} Byte length
                 */

                utf8.length = function utf8_length(string) {
                  var len = 0,
                      c = 0;

                  for (var i = 0; i < string.length; ++i) {
                    c = string.charCodeAt(i);
                    if (c < 128) len += 1;else if (c < 2048) len += 2;else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
                      ++i;
                      len += 4;
                    } else len += 3;
                  }

                  return len;
                };
                /**
                 * Reads UTF8 bytes as a string.
                 * @param {Uint8Array} buffer Source buffer
                 * @param {number} start Source start
                 * @param {number} end Source end
                 * @returns {string} String read
                 */


                utf8.read = function utf8_read(buffer, start, end) {
                  var len = end - start;
                  if (len < 1) return "";
                  var parts = null,
                      chunk = [],
                      i = 0,
                      // char offset
                  t; // temporary

                  while (start < end) {
                    t = buffer[start++];
                    if (t < 128) chunk[i++] = t;else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;else if (t > 239 && t < 365) {
                      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
                      chunk[i++] = 0xD800 + (t >> 10);
                      chunk[i++] = 0xDC00 + (t & 1023);
                    } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;

                    if (i > 8191) {
                      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
                      i = 0;
                    }
                  }

                  if (parts) {
                    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
                    return parts.join("");
                  }

                  return String.fromCharCode.apply(String, chunk.slice(0, i));
                };
                /**
                 * Writes a string as UTF8 bytes.
                 * @param {string} string Source string
                 * @param {Uint8Array} buffer Destination buffer
                 * @param {number} offset Destination offset
                 * @returns {number} Bytes written
                 */


                utf8.write = function utf8_write(string, buffer, offset) {
                  var start = offset,
                      c1,
                      // character 1
                  c2; // character 2

                  for (var i = 0; i < string.length; ++i) {
                    c1 = string.charCodeAt(i);

                    if (c1 < 128) {
                      buffer[offset++] = c1;
                    } else if (c1 < 2048) {
                      buffer[offset++] = c1 >> 6 | 192;
                      buffer[offset++] = c1 & 63 | 128;
                    } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
                      c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
                      ++i;
                      buffer[offset++] = c1 >> 18 | 240;
                      buffer[offset++] = c1 >> 12 & 63 | 128;
                      buffer[offset++] = c1 >> 6 & 63 | 128;
                      buffer[offset++] = c1 & 63 | 128;
                    } else {
                      buffer[offset++] = c1 >> 12 | 224;
                      buffer[offset++] = c1 >> 6 & 63 | 128;
                      buffer[offset++] = c1 & 63 | 128;
                    }
                  }

                  return offset - start;
                };
              }, {}],
              11: [function (require, module, exports) {
                module.exports = common;
                var commonRe = /\/|\./;
                /**
                 * Provides common type definitions.
                 * Can also be used to provide additional google types or your own custom types.
                 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
                 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
                 * @returns {undefined}
                 * @property {INamespace} google/protobuf/any.proto Any
                 * @property {INamespace} google/protobuf/duration.proto Duration
                 * @property {INamespace} google/protobuf/empty.proto Empty
                 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
                 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
                 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
                 * @example
                 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
                 * protobuf.common("descriptor", descriptorJson);
                 *
                 * // manually provides a custom definition (uses my.foo namespace)
                 * protobuf.common("my/foo/bar.proto", myFooBarJson);
                 */

                function common(name, json) {
                  if (!commonRe.test(name)) {
                    name = "google/protobuf/" + name + ".proto";
                    json = {
                      nested: {
                        google: {
                          nested: {
                            protobuf: {
                              nested: json
                            }
                          }
                        }
                      }
                    };
                  }

                  common[name] = json;
                } // Not provided because of limited use (feel free to discuss or to provide yourself):
                //
                // google/protobuf/descriptor.proto
                // google/protobuf/field_mask.proto
                // google/protobuf/source_context.proto
                // google/protobuf/type.proto
                //
                // Stripped and pre-parsed versions of these non-bundled files are instead available as part of
                // the repository or package within the google/protobuf directory.


                common("any", {
                  /**
                   * Properties of a google.protobuf.Any message.
                   * @interface IAny
                   * @type {Object}
                   * @property {string} [typeUrl]
                   * @property {Uint8Array} [bytes]
                   * @memberof common
                   */
                  Any: {
                    fields: {
                      type_url: {
                        type: "string",
                        id: 1
                      },
                      value: {
                        type: "bytes",
                        id: 2
                      }
                    }
                  }
                });
                var timeType;
                common("duration", {
                  /**
                   * Properties of a google.protobuf.Duration message.
                   * @interface IDuration
                   * @type {Object}
                   * @property {number|Long} [seconds]
                   * @property {number} [nanos]
                   * @memberof common
                   */
                  Duration: timeType = {
                    fields: {
                      seconds: {
                        type: "int64",
                        id: 1
                      },
                      nanos: {
                        type: "int32",
                        id: 2
                      }
                    }
                  }
                });
                common("timestamp", {
                  /**
                   * Properties of a google.protobuf.Timestamp message.
                   * @interface ITimestamp
                   * @type {Object}
                   * @property {number|Long} [seconds]
                   * @property {number} [nanos]
                   * @memberof common
                   */
                  Timestamp: timeType
                });
                common("empty", {
                  /**
                   * Properties of a google.protobuf.Empty message.
                   * @interface IEmpty
                   * @memberof common
                   */
                  Empty: {
                    fields: {}
                  }
                });
                common("struct", {
                  /**
                   * Properties of a google.protobuf.Struct message.
                   * @interface IStruct
                   * @type {Object}
                   * @property {Object.<string,IValue>} [fields]
                   * @memberof common
                   */
                  Struct: {
                    fields: {
                      fields: {
                        keyType: "string",
                        type: "Value",
                        id: 1
                      }
                    }
                  },

                  /**
                   * Properties of a google.protobuf.Value message.
                   * @interface IValue
                   * @type {Object}
                   * @property {string} [kind]
                   * @property {0} [nullValue]
                   * @property {number} [numberValue]
                   * @property {string} [stringValue]
                   * @property {boolean} [boolValue]
                   * @property {IStruct} [structValue]
                   * @property {IListValue} [listValue]
                   * @memberof common
                   */
                  Value: {
                    oneofs: {
                      kind: {
                        oneof: ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]
                      }
                    },
                    fields: {
                      nullValue: {
                        type: "NullValue",
                        id: 1
                      },
                      numberValue: {
                        type: "double",
                        id: 2
                      },
                      stringValue: {
                        type: "string",
                        id: 3
                      },
                      boolValue: {
                        type: "bool",
                        id: 4
                      },
                      structValue: {
                        type: "Struct",
                        id: 5
                      },
                      listValue: {
                        type: "ListValue",
                        id: 6
                      }
                    }
                  },
                  NullValue: {
                    values: {
                      NULL_VALUE: 0
                    }
                  },

                  /**
                   * Properties of a google.protobuf.ListValue message.
                   * @interface IListValue
                   * @type {Object}
                   * @property {Array.<IValue>} [values]
                   * @memberof common
                   */
                  ListValue: {
                    fields: {
                      values: {
                        rule: "repeated",
                        type: "Value",
                        id: 1
                      }
                    }
                  }
                });
                common("wrappers", {
                  /**
                   * Properties of a google.protobuf.DoubleValue message.
                   * @interface IDoubleValue
                   * @type {Object}
                   * @property {number} [value]
                   * @memberof common
                   */
                  DoubleValue: {
                    fields: {
                      value: {
                        type: "double",
                        id: 1
                      }
                    }
                  },

                  /**
                   * Properties of a google.protobuf.FloatValue message.
                   * @interface IFloatValue
                   * @type {Object}
                   * @property {number} [value]
                   * @memberof common
                   */
                  FloatValue: {
                    fields: {
                      value: {
                        type: "float",
                        id: 1
                      }
                    }
                  },

                  /**
                   * Properties of a google.protobuf.Int64Value message.
                   * @interface IInt64Value
                   * @type {Object}
                   * @property {number|Long} [value]
                   * @memberof common
                   */
                  Int64Value: {
                    fields: {
                      value: {
                        type: "int64",
                        id: 1
                      }
                    }
                  },

                  /**
                   * Properties of a google.protobuf.UInt64Value message.
                   * @interface IUInt64Value
                   * @type {Object}
                   * @property {number|Long} [value]
                   * @memberof common
                   */
                  UInt64Value: {
                    fields: {
                      value: {
                        type: "uint64",
                        id: 1
                      }
                    }
                  },

                  /**
                   * Properties of a google.protobuf.Int32Value message.
                   * @interface IInt32Value
                   * @type {Object}
                   * @property {number} [value]
                   * @memberof common
                   */
                  Int32Value: {
                    fields: {
                      value: {
                        type: "int32",
                        id: 1
                      }
                    }
                  },

                  /**
                   * Properties of a google.protobuf.UInt32Value message.
                   * @interface IUInt32Value
                   * @type {Object}
                   * @property {number} [value]
                   * @memberof common
                   */
                  UInt32Value: {
                    fields: {
                      value: {
                        type: "uint32",
                        id: 1
                      }
                    }
                  },

                  /**
                   * Properties of a google.protobuf.BoolValue message.
                   * @interface IBoolValue
                   * @type {Object}
                   * @property {boolean} [value]
                   * @memberof common
                   */
                  BoolValue: {
                    fields: {
                      value: {
                        type: "bool",
                        id: 1
                      }
                    }
                  },

                  /**
                   * Properties of a google.protobuf.StringValue message.
                   * @interface IStringValue
                   * @type {Object}
                   * @property {string} [value]
                   * @memberof common
                   */
                  StringValue: {
                    fields: {
                      value: {
                        type: "string",
                        id: 1
                      }
                    }
                  },

                  /**
                   * Properties of a google.protobuf.BytesValue message.
                   * @interface IBytesValue
                   * @type {Object}
                   * @property {Uint8Array} [value]
                   * @memberof common
                   */
                  BytesValue: {
                    fields: {
                      value: {
                        type: "bytes",
                        id: 1
                      }
                    }
                  }
                });
                /**
                 * Gets the root definition of the specified common proto file.
                 *
                 * Bundled definitions are:
                 * - google/protobuf/any.proto
                 * - google/protobuf/duration.proto
                 * - google/protobuf/empty.proto
                 * - google/protobuf/struct.proto
                 * - google/protobuf/timestamp.proto
                 * - google/protobuf/wrappers.proto
                 *
                 * @param {string} file Proto file name
                 * @returns {INamespace|null} Root definition or `null` if not defined
                 */

                common.get = function get(file) {
                  return common[file] || null;
                };
              }, {}],
              12: [function (require, module, exports) {
                /**
                 * Runtime message from/to plain object converters.
                 * @namespace
                 */
                var converter = exports;

                var Enum = require(15),
                    util = require(37);
                /**
                 * Generates a partial value fromObject conveter.
                 * @param {Codegen} gen Codegen instance
                 * @param {Field} field Reflected field
                 * @param {number} fieldIndex Field index
                 * @param {string} prop Property reference
                 * @returns {Codegen} Codegen instance
                 * @ignore
                 */


                function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
                  /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
                  if (field.resolvedType) {
                    if (field.resolvedType instanceof Enum) {
                      gen("switch(d%s){", prop);

                      for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                        if (field.repeated && values[keys[i]] === field.typeDefault) gen("default:");
                        gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
                      }

                      gen("}");
                    } else gen("if(typeof d%s!==\"object\")", prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
                  } else {
                    var isUnsigned = false;

                    switch (field.type) {
                      case "double":
                      case "float":
                        gen("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"

                        break;

                      case "uint32":
                      case "fixed32":
                        gen("m%s=d%s>>>0", prop, prop);
                        break;

                      case "int32":
                      case "sint32":
                      case "sfixed32":
                        gen("m%s=d%s|0", prop, prop);
                        break;

                      case "uint64":
                        isUnsigned = true;
                      // eslint-disable-line no-fallthrough

                      case "int64":
                      case "sint64":
                      case "fixed64":
                      case "sfixed64":
                        gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)("else if(typeof d%s===\"string\")", prop)("m%s=parseInt(d%s,10)", prop, prop)("else if(typeof d%s===\"number\")", prop)("m%s=d%s", prop, prop)("else if(typeof d%s===\"object\")", prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                        break;

                      case "bytes":
                        gen("if(typeof d%s===\"string\")", prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length)", prop)("m%s=d%s", prop, prop);
                        break;

                      case "string":
                        gen("m%s=String(d%s)", prop, prop);
                        break;

                      case "bool":
                        gen("m%s=Boolean(d%s)", prop, prop);
                        break;

                      /* default: gen
                          ("m%s=d%s", prop, prop);
                          break; */
                    }
                  }

                  return gen;
                  /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
                }
                /**
                 * Generates a plain object to runtime message converter specific to the specified message type.
                 * @param {Type} mtype Message type
                 * @returns {Codegen} Codegen instance
                 */


                converter.fromObject = function fromObject(mtype) {
                  /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
                  var fields = mtype.fieldsArray;
                  var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
                  if (!fields.length) return gen("return new this.ctor");
                  gen("var m=new this.ctor");

                  for (var i = 0; i < fields.length; ++i) {
                    var field = fields[i].resolve(),
                        prop = util.safeProp(field.name); // Map fields

                    if (field.map) {
                      gen("if(d%s){", prop)("if(typeof d%s!==\"object\")", prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
                      genValuePartial_fromObject(gen, field,
                      /* not sorted */
                      i, prop + "[ks[i]]")("}")("}"); // Repeated fields
                    } else if (field.repeated) {
                      gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
                      genValuePartial_fromObject(gen, field,
                      /* not sorted */
                      i, prop + "[i]")("}")("}"); // Non-repeated fields
                    } else {
                      if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
                      ("if(d%s!=null){", prop); // !== undefined && !== null

                      genValuePartial_fromObject(gen, field,
                      /* not sorted */
                      i, prop);
                      if (!(field.resolvedType instanceof Enum)) gen("}");
                    }
                  }

                  return gen("return m");
                  /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
                };
                /**
                 * Generates a partial value toObject converter.
                 * @param {Codegen} gen Codegen instance
                 * @param {Field} field Reflected field
                 * @param {number} fieldIndex Field index
                 * @param {string} prop Property reference
                 * @returns {Codegen} Codegen instance
                 * @ignore
                 */


                function genValuePartial_toObject(gen, field, fieldIndex, prop) {
                  /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
                  if (field.resolvedType) {
                    if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);else gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
                  } else {
                    var isUnsigned = false;

                    switch (field.type) {
                      case "double":
                      case "float":
                        gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                        break;

                      case "uint64":
                        isUnsigned = true;
                      // eslint-disable-line no-fallthrough

                      case "int64":
                      case "sint64":
                      case "fixed64":
                      case "sfixed64":
                        gen("if(typeof m%s===\"number\")", prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else") // Long-like
                        ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
                        break;

                      case "bytes":
                        gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                        break;

                      default:
                        gen("d%s=m%s", prop, prop);
                        break;
                    }
                  }

                  return gen;
                  /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
                }
                /**
                 * Generates a runtime message to plain object converter specific to the specified message type.
                 * @param {Type} mtype Message type
                 * @returns {Codegen} Codegen instance
                 */


                converter.toObject = function toObject(mtype) {
                  /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
                  var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
                  if (!fields.length) return util.codegen()("return {}");
                  var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
                  var repeatedFields = [],
                      mapFields = [],
                      normalFields = [],
                      i = 0;

                  for (; i < fields.length; ++i) {
                    if (!fields[i].partOf) (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
                  }

                  if (repeatedFields.length) {
                    gen("if(o.arrays||o.defaults){");

                    for (i = 0; i < repeatedFields.length; ++i) {
                      gen("d%s=[]", util.safeProp(repeatedFields[i].name));
                    }

                    gen("}");
                  }

                  if (mapFields.length) {
                    gen("if(o.objects||o.defaults){");

                    for (i = 0; i < mapFields.length; ++i) {
                      gen("d%s={}", util.safeProp(mapFields[i].name));
                    }

                    gen("}");
                  }

                  if (normalFields.length) {
                    gen("if(o.defaults){");

                    for (i = 0; i < normalFields.length; ++i) {
                      var field = normalFields[i],
                          prop = util.safeProp(field.name);
                      if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);else if (field["long"]) gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());else if (field.bytes) gen("d%s=o.bytes===String?%j:%s", prop, String.fromCharCode.apply(String, field.typeDefault), "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]");else gen("d%s=%j", prop, field.typeDefault); // also messages (=null)
                    }

                    gen("}");
                  }

                  var hasKs2 = false;

                  for (i = 0; i < fields.length; ++i) {
                    var field = fields[i],
                        index = mtype._fieldsArray.indexOf(field),
                        prop = util.safeProp(field.name);

                    if (field.map) {
                      if (!hasKs2) {
                        hasKs2 = true;
                        gen("var ks2");
                      }

                      gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
                      genValuePartial_toObject(gen, field,
                      /* sorted */
                      index, prop + "[ks2[j]]")("}");
                    } else if (field.repeated) {
                      gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
                      genValuePartial_toObject(gen, field,
                      /* sorted */
                      index, prop + "[j]")("}");
                    } else {
                      gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null

                      genValuePartial_toObject(gen, field,
                      /* sorted */
                      index, prop);
                      if (field.partOf) gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
                    }

                    gen("}");
                  }

                  return gen("return d");
                  /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
                };
              }, {
                "15": 15,
                "37": 37
              }],
              13: [function (require, module, exports) {
                module.exports = decoder;

                var Enum = require(15),
                    types = require(36),
                    util = require(37);

                function missing(field) {
                  return "missing required '" + field.name + "'";
                }
                /**
                 * Generates a decoder specific to the specified message type.
                 * @param {Type} mtype Message type
                 * @returns {Codegen} Codegen instance
                 */


                function decoder(mtype) {
                  /* eslint-disable no-unexpected-multiline */
                  var gen = util.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function (field) {
                    return field.map;
                  }).length ? ",k" : ""))("while(r.pos<c){")("var t=r.uint32()");
                  if (mtype.group) gen("if((t&7)===4)")("break");
                  gen("switch(t>>>3){");
                  var i = 0;

                  for (; i <
                  /* initializes */
                  mtype.fieldsArray.length; ++i) {
                    var field = mtype._fieldsArray[i].resolve(),
                        type = field.resolvedType instanceof Enum ? "int32" : field.type,
                        ref = "m" + util.safeProp(field.name);

                    gen("case %i:", field.id); // Map fields

                    if (field.map) {
                      gen("r.skip().pos++") // assumes id 1 + key wireType
                      ("if(%s===util.emptyObject)", ref)("%s={}", ref)("k=r.%s()", field.keyType)("r.pos++"); // assumes id 2 + value wireType

                      if (types["long"][field.keyType] !== undefined$1) {
                        if (types.basic[type] === undefined$1) gen("%s[typeof k===\"object\"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                        else gen("%s[typeof k===\"object\"?util.longToHash(k):k]=r.%s()", ref, type);
                      } else {
                        if (types.basic[type] === undefined$1) gen("%s[k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                        else gen("%s[k]=r.%s()", ref, type);
                      } // Repeated fields

                    } else if (field.repeated) {
                      gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref); // Packable (always check for forward and backward compatiblity)

                      if (types.packed[type] !== undefined$1) gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else"); // Non-packed

                      if (types.basic[type] === undefined$1) gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);else gen("%s.push(r.%s())", ref, type); // Non-repeated
                    } else if (types.basic[type] === undefined$1) gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i);else gen("%s=r.%s()", ref, type);

                    gen("break"); // Unknown fields
                  }

                  gen("default:")("r.skipType(t&7)")("break")("}")("}"); // Field presence

                  for (i = 0; i < mtype._fieldsArray.length; ++i) {
                    var rfield = mtype._fieldsArray[i];
                    if (rfield.required) gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
                  }

                  return gen("return m");
                  /* eslint-enable no-unexpected-multiline */
                }
              }, {
                "15": 15,
                "36": 36,
                "37": 37
              }],
              14: [function (require, module, exports) {
                module.exports = encoder;

                var Enum = require(15),
                    types = require(36),
                    util = require(37);
                /**
                 * Generates a partial message type encoder.
                 * @param {Codegen} gen Codegen instance
                 * @param {Field} field Reflected field
                 * @param {number} fieldIndex Field index
                 * @param {string} ref Variable reference
                 * @returns {Codegen} Codegen instance
                 * @ignore
                 */


                function genTypePartial(gen, field, fieldIndex, ref) {
                  return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
                }
                /**
                 * Generates an encoder specific to the specified message type.
                 * @param {Type} mtype Message type
                 * @returns {Codegen} Codegen instance
                 */


                function encoder(mtype) {
                  /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
                  var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
                  var i, ref; // "when a message is serialized its known fields should be written sequentially by field number"

                  var fields =
                  /* initializes */
                  mtype.fieldsArray.slice().sort(util.compareFieldsById);

                  for (var i = 0; i < fields.length; ++i) {
                    var field = fields[i].resolve(),
                        index = mtype._fieldsArray.indexOf(field),
                        type = field.resolvedType instanceof Enum ? "int32" : field.type,
                        wireType = types.basic[type];

                    ref = "m" + util.safeProp(field.name); // Map fields

                    if (field.map) {
                      gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name) // !== undefined && !== null
                      ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
                      if (wireType === undefined$1) gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
                      else gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
                      gen("}")("}"); // Repeated fields
                    } else if (field.repeated) {
                      gen("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null
                      // Packed repeated

                      if (field.packed && types.packed[type] !== undefined$1) {
                        gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()"); // Non-packed
                      } else {
                        gen("for(var i=0;i<%s.length;++i)", ref);
                        if (wireType === undefined$1) genTypePartial(gen, field, index, ref + "[i]");else gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
                      }

                      gen("}"); // Non-repeated
                    } else {
                      if (field.optional) gen("if(%s!=null&&m.hasOwnProperty(%j))", ref, field.name); // !== undefined && !== null

                      if (wireType === undefined$1) genTypePartial(gen, field, index, ref);else gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
                    }
                  }

                  return gen("return w");
                  /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
                }
              }, {
                "15": 15,
                "36": 36,
                "37": 37
              }],
              15: [function (require, module, exports) {
                module.exports = Enum; // extends ReflectionObject

                var ReflectionObject = require(24);

                ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

                var Namespace = require(23),
                    util = require(37);
                /**
                 * Constructs a new enum instance.
                 * @classdesc Reflected enum.
                 * @extends ReflectionObject
                 * @constructor
                 * @param {string} name Unique name within its namespace
                 * @param {Object.<string,number>} [values] Enum values as an object, by name
                 * @param {Object.<string,*>} [options] Declared options
                 */


                function Enum(name, values, options) {
                  ReflectionObject.call(this, name, options);
                  if (values && typeof values !== "object") throw TypeError("values must be an object");
                  /**
                   * Enum values by id.
                   * @type {Object.<number,string>}
                   */

                  this.valuesById = {};
                  /**
                   * Enum values by name.
                   * @type {Object.<string,number>}
                   */

                  this.values = Object.create(this.valuesById); // toJSON, marker

                  /**
                   * Value comment texts, if any.
                   * @type {Object.<string,string>}
                   */

                  this.comments = {};
                  /**
                   * Reserved ranges, if any.
                   * @type {Array.<number[]|string>}
                   */

                  this.reserved = undefined$1; // toJSON
                  // Note that values inherit valuesById on their prototype which makes them a TypeScript-
                  // compatible enum. This is used by pbts to write actual enum definitions that work for
                  // static and reflection code alike instead of emitting generic object definitions.

                  if (values) for (var keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                    if (typeof values[keys[i]] === "number") // use forward entries only
                      this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
                  }
                }
                /**
                 * Enum descriptor.
                 * @interface IEnum
                 * @property {Object.<string,number>} values Enum values
                 * @property {Object.<string,*>} [options] Enum options
                 */

                /**
                 * Constructs an enum from an enum descriptor.
                 * @param {string} name Enum name
                 * @param {IEnum} json Enum descriptor
                 * @returns {Enum} Created enum
                 * @throws {TypeError} If arguments are invalid
                 */


                Enum.fromJSON = function fromJSON(name, json) {
                  var enm = new Enum(name, json.values, json.options);
                  enm.reserved = json.reserved;
                  return enm;
                };
                /**
                 * Converts this enum to an enum descriptor.
                 * @returns {IEnum} Enum descriptor
                 */


                Enum.prototype.toJSON = function toJSON() {
                  return util.toObject(["options", this.options, "values", this.values, "reserved", this.reserved && this.reserved.length ? this.reserved : undefined$1]);
                };
                /**
                 * Adds a value to this enum.
                 * @param {string} name Value name
                 * @param {number} id Value id
                 * @param {string} [comment] Comment, if any
                 * @returns {Enum} `this`
                 * @throws {TypeError} If arguments are invalid
                 * @throws {Error} If there is already a value with this name or id
                 */


                Enum.prototype.add = function add(name, id, comment) {
                  // utilized by the parser but not by .fromJSON
                  if (!util.isString(name)) throw TypeError("name must be a string");
                  if (!util.isInteger(id)) throw TypeError("id must be an integer");
                  if (this.values[name] !== undefined$1) throw Error("duplicate name '" + name + "' in " + this);
                  if (this.isReservedId(id)) throw Error("id " + id + " is reserved in " + this);
                  if (this.isReservedName(name)) throw Error("name '" + name + "' is reserved in " + this);

                  if (this.valuesById[id] !== undefined$1) {
                    if (!(this.options && this.options.allow_alias)) throw Error("duplicate id " + id + " in " + this);
                    this.values[name] = id;
                  } else this.valuesById[this.values[name] = id] = name;

                  this.comments[name] = comment || null;
                  return this;
                };
                /**
                 * Removes a value from this enum
                 * @param {string} name Value name
                 * @returns {Enum} `this`
                 * @throws {TypeError} If arguments are invalid
                 * @throws {Error} If `name` is not a name of this enum
                 */


                Enum.prototype.remove = function remove(name) {
                  if (!util.isString(name)) throw TypeError("name must be a string");
                  var val = this.values[name];
                  if (val == null) throw Error("name '" + name + "' does not exist in " + this);
                  delete this.valuesById[val];
                  delete this.values[name];
                  delete this.comments[name];
                  return this;
                };
                /**
                 * Tests if the specified id is reserved.
                 * @param {number} id Id to test
                 * @returns {boolean} `true` if reserved, otherwise `false`
                 */


                Enum.prototype.isReservedId = function isReservedId(id) {
                  return Namespace.isReservedId(this.reserved, id);
                };
                /**
                 * Tests if the specified name is reserved.
                 * @param {string} name Name to test
                 * @returns {boolean} `true` if reserved, otherwise `false`
                 */


                Enum.prototype.isReservedName = function isReservedName(name) {
                  return Namespace.isReservedName(this.reserved, name);
                };
              }, {
                "23": 23,
                "24": 24,
                "37": 37
              }],
              16: [function (require, module, exports) {
                module.exports = Field; // extends ReflectionObject

                var ReflectionObject = require(24);

                ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

                var Enum = require(15),
                    types = require(36),
                    util = require(37);

                var Type; // cyclic

                var ruleRe = /^required|optional|repeated$/;
                /**
                 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
                 * @name Field
                 * @classdesc Reflected message field.
                 * @extends FieldBase
                 * @constructor
                 * @param {string} name Unique name within its namespace
                 * @param {number} id Unique id within its namespace
                 * @param {string} type Value type
                 * @param {string|Object.<string,*>} [rule="optional"] Field rule
                 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
                 * @param {Object.<string,*>} [options] Declared options
                 */

                /**
                 * Constructs a field from a field descriptor.
                 * @param {string} name Field name
                 * @param {IField} json Field descriptor
                 * @returns {Field} Created field
                 * @throws {TypeError} If arguments are invalid
                 */

                Field.fromJSON = function fromJSON(name, json) {
                  return new Field(name, json.id, json.type, json.rule, json.extend, json.options);
                };
                /**
                 * Not an actual constructor. Use {@link Field} instead.
                 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
                 * @exports FieldBase
                 * @extends ReflectionObject
                 * @constructor
                 * @param {string} name Unique name within its namespace
                 * @param {number} id Unique id within its namespace
                 * @param {string} type Value type
                 * @param {string|Object.<string,*>} [rule="optional"] Field rule
                 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
                 * @param {Object.<string,*>} [options] Declared options
                 */


                function Field(name, id, type, rule, extend, options) {
                  if (util.isObject(rule)) {
                    options = rule;
                    rule = extend = undefined$1;
                  } else if (util.isObject(extend)) {
                    options = extend;
                    extend = undefined$1;
                  }

                  ReflectionObject.call(this, name, options);
                  if (!util.isInteger(id) || id < 0) throw TypeError("id must be a non-negative integer");
                  if (!util.isString(type)) throw TypeError("type must be a string");
                  if (rule !== undefined$1 && !ruleRe.test(rule = rule.toString().toLowerCase())) throw TypeError("rule must be a string rule");
                  if (extend !== undefined$1 && !util.isString(extend)) throw TypeError("extend must be a string");
                  /**
                   * Field rule, if any.
                   * @type {string|undefined}
                   */

                  this.rule = rule && rule !== "optional" ? rule : undefined$1; // toJSON

                  /**
                   * Field type.
                   * @type {string}
                   */

                  this.type = type; // toJSON

                  /**
                   * Unique field id.
                   * @type {number}
                   */

                  this.id = id; // toJSON, marker

                  /**
                   * Extended type if different from parent.
                   * @type {string|undefined}
                   */

                  this.extend = extend || undefined$1; // toJSON

                  /**
                   * Whether this field is required.
                   * @type {boolean}
                   */

                  this.required = rule === "required";
                  /**
                   * Whether this field is optional.
                   * @type {boolean}
                   */

                  this.optional = !this.required;
                  /**
                   * Whether this field is repeated.
                   * @type {boolean}
                   */

                  this.repeated = rule === "repeated";
                  /**
                   * Whether this field is a map or not.
                   * @type {boolean}
                   */

                  this.map = false;
                  /**
                   * Message this field belongs to.
                   * @type {Type|null}
                   */

                  this.message = null;
                  /**
                   * OneOf this field belongs to, if any,
                   * @type {OneOf|null}
                   */

                  this.partOf = null;
                  /**
                   * The field type's default value.
                   * @type {*}
                   */

                  this.typeDefault = null;
                  /**
                   * The field's default value on prototypes.
                   * @type {*}
                   */

                  this.defaultValue = null;
                  /**
                   * Whether this field's value should be treated as a long.
                   * @type {boolean}
                   */

                  this["long"] = util.Long ? types["long"][type] !== undefined$1 :
                  /* istanbul ignore next */
                  false;
                  /**
                   * Whether this field's value is a buffer.
                   * @type {boolean}
                   */

                  this.bytes = type === "bytes";
                  /**
                   * Resolved type if not a basic type.
                   * @type {Type|Enum|null}
                   */

                  this.resolvedType = null;
                  /**
                   * Sister-field within the extended type if a declaring extension field.
                   * @type {Field|null}
                   */

                  this.extensionField = null;
                  /**
                   * Sister-field within the declaring namespace if an extended field.
                   * @type {Field|null}
                   */

                  this.declaringField = null;
                  /**
                   * Internally remembers whether this field is packed.
                   * @type {boolean|null}
                   * @private
                   */

                  this._packed = null;
                }
                /**
                 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
                 * @name Field#packed
                 * @type {boolean}
                 * @readonly
                 */


                Object.defineProperty(Field.prototype, "packed", {
                  get: function get() {
                    // defaults to packed=true if not explicity set to false
                    if (this._packed === null) this._packed = this.getOption("packed") !== false;
                    return this._packed;
                  }
                });
                /**
                 * @override
                 */

                Field.prototype.setOption = function setOption(name, value, ifNotSet) {
                  if (name === "packed") // clear cached before setting
                    this._packed = null;
                  return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
                };
                /**
                 * Field descriptor.
                 * @interface IField
                 * @property {string} [rule="optional"] Field rule
                 * @property {string} type Field type
                 * @property {number} id Field id
                 * @property {Object.<string,*>} [options] Field options
                 */

                /**
                 * Extension field descriptor.
                 * @interface IExtensionField
                 * @extends IField
                 * @property {string} extend Extended type
                 */

                /**
                 * Converts this field to a field descriptor.
                 * @returns {IField} Field descriptor
                 */


                Field.prototype.toJSON = function toJSON() {
                  return util.toObject(["rule", this.rule !== "optional" && this.rule || undefined$1, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options]);
                };
                /**
                 * Resolves this field's type references.
                 * @returns {Field} `this`
                 * @throws {Error} If any reference cannot be resolved
                 */


                Field.prototype.resolve = function resolve() {
                  if (this.resolved) return this;

                  if ((this.typeDefault = types.defaults[this.type]) === undefined$1) {
                    // if not a basic type, resolve it
                    this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
                    if (this.resolvedType instanceof Type) this.typeDefault = null;else // instanceof Enum
                      this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
                  } // use explicitly set default value if present


                  if (this.options && this.options["default"] != null) {
                    this.typeDefault = this.options["default"];
                    if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string") this.typeDefault = this.resolvedType.values[this.typeDefault];
                  } // remove unnecessary options


                  if (this.options) {
                    if (this.options.packed === true || this.options.packed !== undefined$1 && this.resolvedType && !(this.resolvedType instanceof Enum)) delete this.options.packed;
                    if (!Object.keys(this.options).length) this.options = undefined$1;
                  } // convert to internal data type if necesssary


                  if (this["long"]) {
                    this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
                    /* istanbul ignore else */

                    if (Object.freeze) Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)
                  } else if (this.bytes && typeof this.typeDefault === "string") {
                    var buf;
                    if (util.base64.test(this.typeDefault)) util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);else util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
                    this.typeDefault = buf;
                  } // take special care of maps and repeated fields


                  if (this.map) this.defaultValue = util.emptyObject;else if (this.repeated) this.defaultValue = util.emptyArray;else this.defaultValue = this.typeDefault; // ensure proper value on prototype

                  if (this.parent instanceof Type) this.parent.ctor.prototype[this.name] = this.defaultValue;
                  return ReflectionObject.prototype.resolve.call(this);
                };
                /**
                 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
                 * @typedef FieldDecorator
                 * @type {function}
                 * @param {Object} prototype Target prototype
                 * @param {string} fieldName Field name
                 * @returns {undefined}
                 */

                /**
                 * Field decorator (TypeScript).
                 * @name Field.d
                 * @function
                 * @param {number} fieldId Field id
                 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
                 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
                 * @param {T} [defaultValue] Default value
                 * @returns {FieldDecorator} Decorator function
                 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
                 */


                Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
                  // submessage: decorate the submessage and use its name as the type
                  if (typeof fieldType === "function") fieldType = util.decorateType(fieldType).name; // enum reference: create a reflected copy of the enum and keep reuseing it
                  else if (fieldType && typeof fieldType === "object") fieldType = util.decorateEnum(fieldType).name;
                  return function fieldDecorator(prototype, fieldName) {
                    util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, {
                      "default": defaultValue
                    }));
                  };
                };
                /**
                 * Field decorator (TypeScript).
                 * @name Field.d
                 * @function
                 * @param {number} fieldId Field id
                 * @param {Constructor<T>|string} fieldType Field type
                 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
                 * @returns {FieldDecorator} Decorator function
                 * @template T extends Message<T>
                 * @variation 2
                 */
                // like Field.d but without a default value


                Field._configure = function configure(Type_) {
                  Type = Type_;
                };
              }, {
                "15": 15,
                "24": 24,
                "36": 36,
                "37": 37
              }],
              17: [function (require, module, exports) {
                var protobuf = module.exports = require(18);

                protobuf.build = "light";
                /**
                 * A node-style callback as used by {@link load} and {@link Root#load}.
                 * @typedef LoadCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any, otherwise `null`
                 * @param {Root} [root] Root, if there hasn't been an error
                 * @returns {undefined}
                 */

                /**
                 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
                 * @param {string|string[]} filename One or multiple files to load
                 * @param {Root} root Root namespace, defaults to create a new one if omitted.
                 * @param {LoadCallback} callback Callback function
                 * @returns {undefined}
                 * @see {@link Root#load}
                 */

                function load(filename, root, callback) {
                  if (typeof root === "function") {
                    callback = root;
                    root = new protobuf.Root();
                  } else if (!root) root = new protobuf.Root();

                  return root.load(filename, callback);
                }
                /**
                 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
                 * @name load
                 * @function
                 * @param {string|string[]} filename One or multiple files to load
                 * @param {LoadCallback} callback Callback function
                 * @returns {undefined}
                 * @see {@link Root#load}
                 * @variation 2
                 */
                // function load(filename:string, callback:LoadCallback):undefined

                /**
                 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
                 * @name load
                 * @function
                 * @param {string|string[]} filename One or multiple files to load
                 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
                 * @returns {Promise<Root>} Promise
                 * @see {@link Root#load}
                 * @variation 3
                 */
                // function load(filename:string, [root:Root]):Promise<Root>


                protobuf.load = load;
                /**
                 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
                 * @param {string|string[]} filename One or multiple files to load
                 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
                 * @returns {Root} Root namespace
                 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
                 * @see {@link Root#loadSync}
                 */

                function loadSync(filename, root) {
                  if (!root) root = new protobuf.Root();
                  return root.loadSync(filename);
                }

                protobuf.loadSync = loadSync; // Serialization

                protobuf.encoder = require(14);
                protobuf.decoder = require(13);
                protobuf.verifier = require(40);
                protobuf.converter = require(12); // Reflection

                protobuf.ReflectionObject = require(24);
                protobuf.Namespace = require(23);
                protobuf.Root = require(29);
                protobuf.Enum = require(15);
                protobuf.Type = require(35);
                protobuf.Field = require(16);
                protobuf.OneOf = require(25);
                protobuf.MapField = require(20);
                protobuf.Service = require(33);
                protobuf.Method = require(22); // Runtime

                protobuf.Message = require(21);
                protobuf.wrappers = require(41); // Utility

                protobuf.types = require(36);
                protobuf.util = require(37); // Configure reflection

                protobuf.ReflectionObject._configure(protobuf.Root);

                protobuf.Namespace._configure(protobuf.Type, protobuf.Service);

                protobuf.Root._configure(protobuf.Type);

                protobuf.Field._configure(protobuf.Type);
              }, {
                "12": 12,
                "13": 13,
                "14": 14,
                "15": 15,
                "16": 16,
                "18": 18,
                "20": 20,
                "21": 21,
                "22": 22,
                "23": 23,
                "24": 24,
                "25": 25,
                "29": 29,
                "33": 33,
                "35": 35,
                "36": 36,
                "37": 37,
                "40": 40,
                "41": 41
              }],
              18: [function (require, module, exports) {
                var protobuf = exports;
                /**
                 * Build type, one of `"full"`, `"light"` or `"minimal"`.
                 * @name build
                 * @type {string}
                 * @const
                 */

                protobuf.build = "minimal"; // Serialization

                protobuf.Writer = require(42);
                protobuf.BufferWriter = require(43);
                protobuf.Reader = require(27);
                protobuf.BufferReader = require(28); // Utility

                protobuf.util = require(39);
                protobuf.rpc = require(31);
                protobuf.roots = require(30);
                protobuf.configure = configure;
                /* istanbul ignore next */

                /**
                 * Reconfigures the library according to the environment.
                 * @returns {undefined}
                 */

                function configure() {
                  protobuf.Reader._configure(protobuf.BufferReader);

                  protobuf.util._configure();
                } // Configure serialization


                protobuf.Writer._configure(protobuf.BufferWriter);

                configure();
              }, {
                "27": 27,
                "28": 28,
                "30": 30,
                "31": 31,
                "39": 39,
                "42": 42,
                "43": 43
              }],
              19: [function (require, module, exports) {
                var protobuf = module.exports = require(17);

                protobuf.build = "full"; // Parser

                protobuf.tokenize = require(34);
                protobuf.parse = require(26);
                protobuf.common = require(11); // Configure parser

                protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
              }, {
                "11": 11,
                "17": 17,
                "26": 26,
                "34": 34
              }],
              20: [function (require, module, exports) {
                module.exports = MapField; // extends Field

                var Field = require(16);

                ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

                var types = require(36),
                    util = require(37);
                /**
                 * Constructs a new map field instance.
                 * @classdesc Reflected map field.
                 * @extends FieldBase
                 * @constructor
                 * @param {string} name Unique name within its namespace
                 * @param {number} id Unique id within its namespace
                 * @param {string} keyType Key type
                 * @param {string} type Value type
                 * @param {Object.<string,*>} [options] Declared options
                 */


                function MapField(name, id, keyType, type, options) {
                  Field.call(this, name, id, type, options);
                  /* istanbul ignore if */

                  if (!util.isString(keyType)) throw TypeError("keyType must be a string");
                  /**
                   * Key type.
                   * @type {string}
                   */

                  this.keyType = keyType; // toJSON, marker

                  /**
                   * Resolved key type if not a basic type.
                   * @type {ReflectionObject|null}
                   */

                  this.resolvedKeyType = null; // Overrides Field#map

                  this.map = true;
                }
                /**
                 * Map field descriptor.
                 * @interface IMapField
                 * @extends {IField}
                 * @property {string} keyType Key type
                 */

                /**
                 * Extension map field descriptor.
                 * @interface IExtensionMapField
                 * @extends IMapField
                 * @property {string} extend Extended type
                 */

                /**
                 * Constructs a map field from a map field descriptor.
                 * @param {string} name Field name
                 * @param {IMapField} json Map field descriptor
                 * @returns {MapField} Created map field
                 * @throws {TypeError} If arguments are invalid
                 */


                MapField.fromJSON = function fromJSON(name, json) {
                  return new MapField(name, json.id, json.keyType, json.type, json.options);
                };
                /**
                 * Converts this map field to a map field descriptor.
                 * @returns {IMapField} Map field descriptor
                 */


                MapField.prototype.toJSON = function toJSON() {
                  return util.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options]);
                };
                /**
                 * @override
                 */


                MapField.prototype.resolve = function resolve() {
                  if (this.resolved) return this; // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"

                  if (types.mapKey[this.keyType] === undefined$1) throw Error("invalid key type: " + this.keyType);
                  return Field.prototype.resolve.call(this);
                };
                /**
                 * Map field decorator (TypeScript).
                 * @name MapField.d
                 * @function
                 * @param {number} fieldId Field id
                 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
                 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
                 * @returns {FieldDecorator} Decorator function
                 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
                 */


                MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
                  // submessage value: decorate the submessage and use its name as the type
                  if (typeof fieldValueType === "function") fieldValueType = util.decorateType(fieldValueType).name; // enum reference value: create a reflected copy of the enum and keep reuseing it
                  else if (fieldValueType && typeof fieldValueType === "object") fieldValueType = util.decorateEnum(fieldValueType).name;
                  return function mapFieldDecorator(prototype, fieldName) {
                    util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
                  };
                };
              }, {
                "16": 16,
                "36": 36,
                "37": 37
              }],
              21: [function (require, module, exports) {
                module.exports = Message;

                var util = require(39);
                /**
                 * Constructs a new message instance.
                 * @classdesc Abstract runtime message.
                 * @constructor
                 * @param {Properties<T>} [properties] Properties to set
                 * @template T extends object
                 */


                function Message(properties) {
                  // not used internally
                  if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                    this[keys[i]] = properties[keys[i]];
                  }
                }
                /**
                 * Reference to the reflected type.
                 * @name Message.$type
                 * @type {Type}
                 * @readonly
                 */

                /**
                 * Reference to the reflected type.
                 * @name Message#$type
                 * @type {Type}
                 * @readonly
                 */

                /*eslint-disable valid-jsdoc*/

                /**
                 * Creates a new message of this type using the specified properties.
                 * @param {Object.<string,*>} [properties] Properties to set
                 * @returns {Message<T>} Message instance
                 * @template T extends Message<T>
                 * @this Constructor<T>
                 */


                Message.create = function create(properties) {
                  return this.$type.create(properties);
                };
                /**
                 * Encodes a message of this type.
                 * @param {T|Object.<string,*>} message Message to encode
                 * @param {Writer} [writer] Writer to use
                 * @returns {Writer} Writer
                 * @template T extends Message<T>
                 * @this Constructor<T>
                 */


                Message.encode = function encode(message, writer) {
                  return this.$type.encode(message, writer);
                };
                /**
                 * Encodes a message of this type preceeded by its length as a varint.
                 * @param {T|Object.<string,*>} message Message to encode
                 * @param {Writer} [writer] Writer to use
                 * @returns {Writer} Writer
                 * @template T extends Message<T>
                 * @this Constructor<T>
                 */


                Message.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.$type.encodeDelimited(message, writer);
                };
                /**
                 * Decodes a message of this type.
                 * @name Message.decode
                 * @function
                 * @param {Reader|Uint8Array} reader Reader or buffer to decode
                 * @returns {T} Decoded message
                 * @template T extends Message<T>
                 * @this Constructor<T>
                 */


                Message.decode = function decode(reader) {
                  return this.$type.decode(reader);
                };
                /**
                 * Decodes a message of this type preceeded by its length as a varint.
                 * @name Message.decodeDelimited
                 * @function
                 * @param {Reader|Uint8Array} reader Reader or buffer to decode
                 * @returns {T} Decoded message
                 * @template T extends Message<T>
                 * @this Constructor<T>
                 */


                Message.decodeDelimited = function decodeDelimited(reader) {
                  return this.$type.decodeDelimited(reader);
                };
                /**
                 * Verifies a message of this type.
                 * @name Message.verify
                 * @function
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */


                Message.verify = function verify(message) {
                  return this.$type.verify(message);
                };
                /**
                 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {T} Message instance
                 * @template T extends Message<T>
                 * @this Constructor<T>
                 */


                Message.fromObject = function fromObject(object) {
                  return this.$type.fromObject(object);
                };
                /**
                 * Creates a plain object from a message of this type. Also converts values to other types if specified.
                 * @param {T} message Message instance
                 * @param {IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 * @template T extends Message<T>
                 * @this Constructor<T>
                 */


                Message.toObject = function toObject(message, options) {
                  return this.$type.toObject(message, options);
                };
                /**
                 * Converts this message to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */


                Message.prototype.toJSON = function toJSON() {
                  return this.$type.toObject(this, util.toJSONOptions);
                };
                /*eslint-enable valid-jsdoc*/

              }, {
                "39": 39
              }],
              22: [function (require, module, exports) {
                module.exports = Method; // extends ReflectionObject

                var ReflectionObject = require(24);

                ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

                var util = require(37);
                /**
                 * Constructs a new service method instance.
                 * @classdesc Reflected service method.
                 * @extends ReflectionObject
                 * @constructor
                 * @param {string} name Method name
                 * @param {string|undefined} type Method type, usually `"rpc"`
                 * @param {string} requestType Request message type
                 * @param {string} responseType Response message type
                 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
                 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
                 * @param {Object.<string,*>} [options] Declared options
                 */


                function Method(name, type, requestType, responseType, requestStream, responseStream, options) {
                  /* istanbul ignore next */
                  if (util.isObject(requestStream)) {
                    options = requestStream;
                    requestStream = responseStream = undefined$1;
                  } else if (util.isObject(responseStream)) {
                    options = responseStream;
                    responseStream = undefined$1;
                  }
                  /* istanbul ignore if */


                  if (!(type === undefined$1 || util.isString(type))) throw TypeError("type must be a string");
                  /* istanbul ignore if */

                  if (!util.isString(requestType)) throw TypeError("requestType must be a string");
                  /* istanbul ignore if */

                  if (!util.isString(responseType)) throw TypeError("responseType must be a string");
                  ReflectionObject.call(this, name, options);
                  /**
                   * Method type.
                   * @type {string}
                   */

                  this.type = type || "rpc"; // toJSON

                  /**
                   * Request type.
                   * @type {string}
                   */

                  this.requestType = requestType; // toJSON, marker

                  /**
                   * Whether requests are streamed or not.
                   * @type {boolean|undefined}
                   */

                  this.requestStream = requestStream ? true : undefined$1; // toJSON

                  /**
                   * Response type.
                   * @type {string}
                   */

                  this.responseType = responseType; // toJSON

                  /**
                   * Whether responses are streamed or not.
                   * @type {boolean|undefined}
                   */

                  this.responseStream = responseStream ? true : undefined$1; // toJSON

                  /**
                   * Resolved request type.
                   * @type {Type|null}
                   */

                  this.resolvedRequestType = null;
                  /**
                   * Resolved response type.
                   * @type {Type|null}
                   */

                  this.resolvedResponseType = null;
                }
                /**
                 * Method descriptor.
                 * @interface IMethod
                 * @property {string} [type="rpc"] Method type
                 * @property {string} requestType Request type
                 * @property {string} responseType Response type
                 * @property {boolean} [requestStream=false] Whether requests are streamed
                 * @property {boolean} [responseStream=false] Whether responses are streamed
                 * @property {Object.<string,*>} [options] Method options
                 */

                /**
                 * Constructs a method from a method descriptor.
                 * @param {string} name Method name
                 * @param {IMethod} json Method descriptor
                 * @returns {Method} Created method
                 * @throws {TypeError} If arguments are invalid
                 */


                Method.fromJSON = function fromJSON(name, json) {
                  return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options);
                };
                /**
                 * Converts this method to a method descriptor.
                 * @returns {IMethod} Method descriptor
                 */


                Method.prototype.toJSON = function toJSON() {
                  return util.toObject(["type", this.type !== "rpc" &&
                  /* istanbul ignore next */
                  this.type || undefined$1, "requestType", this.requestType, "requestStream", this.requestStream, "responseType", this.responseType, "responseStream", this.responseStream, "options", this.options]);
                };
                /**
                 * @override
                 */


                Method.prototype.resolve = function resolve() {
                  /* istanbul ignore if */
                  if (this.resolved) return this;
                  this.resolvedRequestType = this.parent.lookupType(this.requestType);
                  this.resolvedResponseType = this.parent.lookupType(this.responseType);
                  return ReflectionObject.prototype.resolve.call(this);
                };
              }, {
                "24": 24,
                "37": 37
              }],
              23: [function (require, module, exports) {
                module.exports = Namespace; // extends ReflectionObject

                var ReflectionObject = require(24);

                ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

                var Enum = require(15),
                    Field = require(16),
                    util = require(37);

                var Type, // cyclic
                Service; // "

                /**
                 * Constructs a new namespace instance.
                 * @name Namespace
                 * @classdesc Reflected namespace.
                 * @extends NamespaceBase
                 * @constructor
                 * @param {string} name Namespace name
                 * @param {Object.<string,*>} [options] Declared options
                 */

                /**
                 * Constructs a namespace from JSON.
                 * @memberof Namespace
                 * @function
                 * @param {string} name Namespace name
                 * @param {Object.<string,*>} json JSON object
                 * @returns {Namespace} Created namespace
                 * @throws {TypeError} If arguments are invalid
                 */

                Namespace.fromJSON = function fromJSON(name, json) {
                  return new Namespace(name, json.options).addJSON(json.nested);
                };
                /**
                 * Converts an array of reflection objects to JSON.
                 * @memberof Namespace
                 * @param {ReflectionObject[]} array Object array
                 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
                 */


                function arrayToJSON(array) {
                  if (!(array && array.length)) return undefined$1;
                  var obj = {};

                  for (var i = 0; i < array.length; ++i) {
                    obj[array[i].name] = array[i].toJSON();
                  }

                  return obj;
                }

                Namespace.arrayToJSON = arrayToJSON;
                /**
                 * Tests if the specified id is reserved.
                 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
                 * @param {number} id Id to test
                 * @returns {boolean} `true` if reserved, otherwise `false`
                 */

                Namespace.isReservedId = function isReservedId(reserved, id) {
                  if (reserved) for (var i = 0; i < reserved.length; ++i) {
                    if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] >= id) return true;
                  }
                  return false;
                };
                /**
                 * Tests if the specified name is reserved.
                 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
                 * @param {string} name Name to test
                 * @returns {boolean} `true` if reserved, otherwise `false`
                 */


                Namespace.isReservedName = function isReservedName(reserved, name) {
                  if (reserved) for (var i = 0; i < reserved.length; ++i) {
                    if (reserved[i] === name) return true;
                  }
                  return false;
                };
                /**
                 * Not an actual constructor. Use {@link Namespace} instead.
                 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
                 * @exports NamespaceBase
                 * @extends ReflectionObject
                 * @abstract
                 * @constructor
                 * @param {string} name Namespace name
                 * @param {Object.<string,*>} [options] Declared options
                 * @see {@link Namespace}
                 */


                function Namespace(name, options) {
                  ReflectionObject.call(this, name, options);
                  /**
                   * Nested objects by name.
                   * @type {Object.<string,ReflectionObject>|undefined}
                   */

                  this.nested = undefined$1; // toJSON

                  /**
                   * Cached nested objects as an array.
                   * @type {ReflectionObject[]|null}
                   * @private
                   */

                  this._nestedArray = null;
                }

                function clearCache(namespace) {
                  namespace._nestedArray = null;
                  return namespace;
                }
                /**
                 * Nested objects of this namespace as an array for iteration.
                 * @name NamespaceBase#nestedArray
                 * @type {ReflectionObject[]}
                 * @readonly
                 */


                Object.defineProperty(Namespace.prototype, "nestedArray", {
                  get: function get() {
                    return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
                  }
                });
                /**
                 * Namespace descriptor.
                 * @interface INamespace
                 * @property {Object.<string,*>} [options] Namespace options
                 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
                 */

                /**
                 * Any extension field descriptor.
                 * @typedef AnyExtensionField
                 * @type {IExtensionField|IExtensionMapField}
                 */

                /**
                 * Any nested object descriptor.
                 * @typedef AnyNestedObject
                 * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
                 */
                // ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

                /**
                 * Converts this namespace to a namespace descriptor.
                 * @returns {INamespace} Namespace descriptor
                 */

                Namespace.prototype.toJSON = function toJSON() {
                  return util.toObject(["options", this.options, "nested", arrayToJSON(this.nestedArray)]);
                };
                /**
                 * Adds nested objects to this namespace from nested object descriptors.
                 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
                 * @returns {Namespace} `this`
                 */


                Namespace.prototype.addJSON = function addJSON(nestedJson) {
                  var ns = this;
                  /* istanbul ignore else */

                  if (nestedJson) {
                    for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
                      nested = nestedJson[names[i]];
                      ns.add( // most to least likely
                      (nested.fields !== undefined$1 ? Type.fromJSON : nested.values !== undefined$1 ? Enum.fromJSON : nested.methods !== undefined$1 ? Service.fromJSON : nested.id !== undefined$1 ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));
                    }
                  }

                  return this;
                };
                /**
                 * Gets the nested object of the specified name.
                 * @param {string} name Nested object name
                 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
                 */


                Namespace.prototype.get = function get(name) {
                  return this.nested && this.nested[name] || null;
                };
                /**
                 * Gets the values of the nested {@link Enum|enum} of the specified name.
                 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
                 * @param {string} name Nested enum name
                 * @returns {Object.<string,number>} Enum values
                 * @throws {Error} If there is no such enum
                 */


                Namespace.prototype.getEnum = function getEnum(name) {
                  if (this.nested && this.nested[name] instanceof Enum) return this.nested[name].values;
                  throw Error("no such enum");
                };
                /**
                 * Adds a nested object to this namespace.
                 * @param {ReflectionObject} object Nested object to add
                 * @returns {Namespace} `this`
                 * @throws {TypeError} If arguments are invalid
                 * @throws {Error} If there is already a nested object with this name
                 */


                Namespace.prototype.add = function add(object) {
                  if (!(object instanceof Field && object.extend !== undefined$1 || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace)) throw TypeError("object must be a valid nested object");
                  if (!this.nested) this.nested = {};else {
                    var prev = this.get(object.name);

                    if (prev) {
                      if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                        // replace plain namespace but keep existing nested elements and options
                        var nested = prev.nestedArray;

                        for (var i = 0; i < nested.length; ++i) {
                          object.add(nested[i]);
                        }

                        this.remove(prev);
                        if (!this.nested) this.nested = {};
                        object.setOptions(prev.options, true);
                      } else throw Error("duplicate name '" + object.name + "' in " + this);
                    }
                  }
                  this.nested[object.name] = object;
                  object.onAdd(this);
                  return clearCache(this);
                };
                /**
                 * Removes a nested object from this namespace.
                 * @param {ReflectionObject} object Nested object to remove
                 * @returns {Namespace} `this`
                 * @throws {TypeError} If arguments are invalid
                 * @throws {Error} If `object` is not a member of this namespace
                 */


                Namespace.prototype.remove = function remove(object) {
                  if (!(object instanceof ReflectionObject)) throw TypeError("object must be a ReflectionObject");
                  if (object.parent !== this) throw Error(object + " is not a member of " + this);
                  delete this.nested[object.name];
                  if (!Object.keys(this.nested).length) this.nested = undefined$1;
                  object.onRemove(this);
                  return clearCache(this);
                };
                /**
                 * Defines additial namespaces within this one if not yet existing.
                 * @param {string|string[]} path Path to create
                 * @param {*} [json] Nested types to create from JSON
                 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
                 */


                Namespace.prototype.define = function define(path, json) {
                  if (util.isString(path)) path = path.split(".");else if (!Array.isArray(path)) throw TypeError("illegal path");
                  if (path && path.length && path[0] === "") throw Error("path must be relative");
                  var ptr = this;

                  while (path.length > 0) {
                    var part = path.shift();

                    if (ptr.nested && ptr.nested[part]) {
                      ptr = ptr.nested[part];
                      if (!(ptr instanceof Namespace)) throw Error("path conflicts with non-namespace objects");
                    } else ptr.add(ptr = new Namespace(part));
                  }

                  if (json) ptr.addJSON(json);
                  return ptr;
                };
                /**
                 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
                 * @returns {Namespace} `this`
                 */


                Namespace.prototype.resolveAll = function resolveAll() {
                  var nested = this.nestedArray,
                      i = 0;

                  while (i < nested.length) {
                    if (nested[i] instanceof Namespace) nested[i++].resolveAll();else nested[i++].resolve();
                  }

                  return this.resolve();
                };
                /**
                 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
                 * @param {string|string[]} path Path to look up
                 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
                 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
                 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
                 */


                Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {
                  /* istanbul ignore next */
                  if (typeof filterTypes === "boolean") {
                    parentAlreadyChecked = filterTypes;
                    filterTypes = undefined$1;
                  } else if (filterTypes && !Array.isArray(filterTypes)) filterTypes = [filterTypes];

                  if (util.isString(path) && path.length) {
                    if (path === ".") return this.root;
                    path = path.split(".");
                  } else if (!path.length) return this; // Start at root if path is absolute


                  if (path[0] === "") return this.root.lookup(path.slice(1), filterTypes); // Test if the first part matches any nested object, and if so, traverse if path contains more

                  var found = this.get(path[0]);

                  if (found) {
                    if (path.length === 1) {
                      if (!filterTypes || filterTypes.indexOf(found.constructor) > -1) return found;
                    } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true))) return found; // Otherwise try each nested namespace

                  } else for (var i = 0; i < this.nestedArray.length; ++i) {
                    if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true))) return found;
                  } // If there hasn't been a match, try again at the parent


                  if (this.parent === null || parentAlreadyChecked) return null;
                  return this.parent.lookup(path, filterTypes);
                };
                /**
                 * Looks up the reflection object at the specified path, relative to this namespace.
                 * @name NamespaceBase#lookup
                 * @function
                 * @param {string|string[]} path Path to look up
                 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
                 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
                 * @variation 2
                 */
                // lookup(path: string, [parentAlreadyChecked: boolean])

                /**
                 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
                 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
                 * @param {string|string[]} path Path to look up
                 * @returns {Type} Looked up type
                 * @throws {Error} If `path` does not point to a type
                 */


                Namespace.prototype.lookupType = function lookupType(path) {
                  var found = this.lookup(path, [Type]);
                  if (!found) throw Error("no such type");
                  return found;
                };
                /**
                 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
                 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
                 * @param {string|string[]} path Path to look up
                 * @returns {Enum} Looked up enum
                 * @throws {Error} If `path` does not point to an enum
                 */


                Namespace.prototype.lookupEnum = function lookupEnum(path) {
                  var found = this.lookup(path, [Enum]);
                  if (!found) throw Error("no such Enum '" + path + "' in " + this);
                  return found;
                };
                /**
                 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
                 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
                 * @param {string|string[]} path Path to look up
                 * @returns {Type} Looked up type or enum
                 * @throws {Error} If `path` does not point to a type or enum
                 */


                Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
                  var found = this.lookup(path, [Type, Enum]);
                  if (!found) throw Error("no such Type or Enum '" + path + "' in " + this);
                  return found;
                };
                /**
                 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
                 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
                 * @param {string|string[]} path Path to look up
                 * @returns {Service} Looked up service
                 * @throws {Error} If `path` does not point to a service
                 */


                Namespace.prototype.lookupService = function lookupService(path) {
                  var found = this.lookup(path, [Service]);
                  if (!found) throw Error("no such Service '" + path + "' in " + this);
                  return found;
                };

                Namespace._configure = function (Type_, Service_) {
                  Type = Type_;
                  Service = Service_;
                };
              }, {
                "15": 15,
                "16": 16,
                "24": 24,
                "37": 37
              }],
              24: [function (require, module, exports) {
                module.exports = ReflectionObject;
                ReflectionObject.className = "ReflectionObject";

                var util = require(37);

                var Root; // cyclic

                /**
                 * Constructs a new reflection object instance.
                 * @classdesc Base class of all reflection objects.
                 * @constructor
                 * @param {string} name Object name
                 * @param {Object.<string,*>} [options] Declared options
                 * @abstract
                 */

                function ReflectionObject(name, options) {
                  if (!util.isString(name)) throw TypeError("name must be a string");
                  if (options && !util.isObject(options)) throw TypeError("options must be an object");
                  /**
                   * Options.
                   * @type {Object.<string,*>|undefined}
                   */

                  this.options = options; // toJSON

                  /**
                   * Unique name within its namespace.
                   * @type {string}
                   */

                  this.name = name;
                  /**
                   * Parent namespace.
                   * @type {Namespace|null}
                   */

                  this.parent = null;
                  /**
                   * Whether already resolved or not.
                   * @type {boolean}
                   */

                  this.resolved = false;
                  /**
                   * Comment text, if any.
                   * @type {string|null}
                   */

                  this.comment = null;
                  /**
                   * Defining file name.
                   * @type {string|null}
                   */

                  this.filename = null;
                }

                Object.defineProperties(ReflectionObject.prototype, {
                  /**
                   * Reference to the root namespace.
                   * @name ReflectionObject#root
                   * @type {Root}
                   * @readonly
                   */
                  root: {
                    get: function get() {
                      var ptr = this;

                      while (ptr.parent !== null) {
                        ptr = ptr.parent;
                      }

                      return ptr;
                    }
                  },

                  /**
                   * Full name including leading dot.
                   * @name ReflectionObject#fullName
                   * @type {string}
                   * @readonly
                   */
                  fullName: {
                    get: function get() {
                      var path = [this.name],
                          ptr = this.parent;

                      while (ptr) {
                        path.unshift(ptr.name);
                        ptr = ptr.parent;
                      }

                      return path.join(".");
                    }
                  }
                });
                /**
                 * Converts this reflection object to its descriptor representation.
                 * @returns {Object.<string,*>} Descriptor
                 * @abstract
                 */

                ReflectionObject.prototype.toJSON =
                /* istanbul ignore next */
                function toJSON() {
                  throw Error(); // not implemented, shouldn't happen
                };
                /**
                 * Called when this object is added to a parent.
                 * @param {ReflectionObject} parent Parent added to
                 * @returns {undefined}
                 */


                ReflectionObject.prototype.onAdd = function onAdd(parent) {
                  if (this.parent && this.parent !== parent) this.parent.remove(this);
                  this.parent = parent;
                  this.resolved = false;
                  var root = parent.root;
                  if (root instanceof Root) root._handleAdd(this);
                };
                /**
                 * Called when this object is removed from a parent.
                 * @param {ReflectionObject} parent Parent removed from
                 * @returns {undefined}
                 */


                ReflectionObject.prototype.onRemove = function onRemove(parent) {
                  var root = parent.root;
                  if (root instanceof Root) root._handleRemove(this);
                  this.parent = null;
                  this.resolved = false;
                };
                /**
                 * Resolves this objects type references.
                 * @returns {ReflectionObject} `this`
                 */


                ReflectionObject.prototype.resolve = function resolve() {
                  if (this.resolved) return this;
                  if (this.root instanceof Root) this.resolved = true; // only if part of a root

                  return this;
                };
                /**
                 * Gets an option value.
                 * @param {string} name Option name
                 * @returns {*} Option value or `undefined` if not set
                 */


                ReflectionObject.prototype.getOption = function getOption(name) {
                  if (this.options) return this.options[name];
                  return undefined$1;
                };
                /**
                 * Sets an option.
                 * @param {string} name Option name
                 * @param {*} value Option value
                 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
                 * @returns {ReflectionObject} `this`
                 */


                ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
                  if (!ifNotSet || !this.options || this.options[name] === undefined$1) (this.options || (this.options = {}))[name] = value;
                  return this;
                };
                /**
                 * Sets multiple options.
                 * @param {Object.<string,*>} options Options to set
                 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
                 * @returns {ReflectionObject} `this`
                 */


                ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
                  if (options) for (var keys = Object.keys(options), i = 0; i < keys.length; ++i) {
                    this.setOption(keys[i], options[keys[i]], ifNotSet);
                  }
                  return this;
                };
                /**
                 * Converts this instance to its string representation.
                 * @returns {string} Class name[, space, full name]
                 */


                ReflectionObject.prototype.toString = function toString() {
                  var className = this.constructor.className,
                      fullName = this.fullName;
                  if (fullName.length) return className + " " + fullName;
                  return className;
                };

                ReflectionObject._configure = function (Root_) {
                  Root = Root_;
                };
              }, {
                "37": 37
              }],
              25: [function (require, module, exports) {
                module.exports = OneOf; // extends ReflectionObject

                var ReflectionObject = require(24);

                ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

                var Field = require(16),
                    util = require(37);
                /**
                 * Constructs a new oneof instance.
                 * @classdesc Reflected oneof.
                 * @extends ReflectionObject
                 * @constructor
                 * @param {string} name Oneof name
                 * @param {string[]|Object.<string,*>} [fieldNames] Field names
                 * @param {Object.<string,*>} [options] Declared options
                 */


                function OneOf(name, fieldNames, options) {
                  if (!Array.isArray(fieldNames)) {
                    options = fieldNames;
                    fieldNames = undefined$1;
                  }

                  ReflectionObject.call(this, name, options);
                  /* istanbul ignore if */

                  if (!(fieldNames === undefined$1 || Array.isArray(fieldNames))) throw TypeError("fieldNames must be an Array");
                  /**
                   * Field names that belong to this oneof.
                   * @type {string[]}
                   */

                  this.oneof = fieldNames || []; // toJSON, marker

                  /**
                   * Fields that belong to this oneof as an array for iteration.
                   * @type {Field[]}
                   * @readonly
                   */

                  this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent
                }
                /**
                 * Oneof descriptor.
                 * @interface IOneOf
                 * @property {Array.<string>} oneof Oneof field names
                 * @property {Object.<string,*>} [options] Oneof options
                 */

                /**
                 * Constructs a oneof from a oneof descriptor.
                 * @param {string} name Oneof name
                 * @param {IOneOf} json Oneof descriptor
                 * @returns {OneOf} Created oneof
                 * @throws {TypeError} If arguments are invalid
                 */


                OneOf.fromJSON = function fromJSON(name, json) {
                  return new OneOf(name, json.oneof, json.options);
                };
                /**
                 * Converts this oneof to a oneof descriptor.
                 * @returns {IOneOf} Oneof descriptor
                 */


                OneOf.prototype.toJSON = function toJSON() {
                  return util.toObject(["options", this.options, "oneof", this.oneof]);
                };
                /**
                 * Adds the fields of the specified oneof to the parent if not already done so.
                 * @param {OneOf} oneof The oneof
                 * @returns {undefined}
                 * @inner
                 * @ignore
                 */


                function addFieldsToParent(oneof) {
                  if (oneof.parent) for (var i = 0; i < oneof.fieldsArray.length; ++i) {
                    if (!oneof.fieldsArray[i].parent) oneof.parent.add(oneof.fieldsArray[i]);
                  }
                }
                /**
                 * Adds a field to this oneof and removes it from its current parent, if any.
                 * @param {Field} field Field to add
                 * @returns {OneOf} `this`
                 */


                OneOf.prototype.add = function add(field) {
                  /* istanbul ignore if */
                  if (!(field instanceof Field)) throw TypeError("field must be a Field");
                  if (field.parent && field.parent !== this.parent) field.parent.remove(field);
                  this.oneof.push(field.name);
                  this.fieldsArray.push(field);
                  field.partOf = this; // field.parent remains null

                  addFieldsToParent(this);
                  return this;
                };
                /**
                 * Removes a field from this oneof and puts it back to the oneof's parent.
                 * @param {Field} field Field to remove
                 * @returns {OneOf} `this`
                 */


                OneOf.prototype.remove = function remove(field) {
                  /* istanbul ignore if */
                  if (!(field instanceof Field)) throw TypeError("field must be a Field");
                  var index = this.fieldsArray.indexOf(field);
                  /* istanbul ignore if */

                  if (index < 0) throw Error(field + " is not a member of " + this);
                  this.fieldsArray.splice(index, 1);
                  index = this.oneof.indexOf(field.name);
                  /* istanbul ignore else */

                  if (index > -1) // theoretical
                    this.oneof.splice(index, 1);
                  field.partOf = null;
                  return this;
                };
                /**
                 * @override
                 */


                OneOf.prototype.onAdd = function onAdd(parent) {
                  ReflectionObject.prototype.onAdd.call(this, parent);
                  var self = this; // Collect present fields

                  for (var i = 0; i < this.oneof.length; ++i) {
                    var field = parent.get(this.oneof[i]);

                    if (field && !field.partOf) {
                      field.partOf = self;
                      self.fieldsArray.push(field);
                    }
                  } // Add not yet present fields


                  addFieldsToParent(this);
                };
                /**
                 * @override
                 */


                OneOf.prototype.onRemove = function onRemove(parent) {
                  for (var i = 0, field; i < this.fieldsArray.length; ++i) {
                    if ((field = this.fieldsArray[i]).parent) field.parent.remove(field);
                  }

                  ReflectionObject.prototype.onRemove.call(this, parent);
                };
                /**
                 * Decorator function as returned by {@link OneOf.d} (TypeScript).
                 * @typedef OneOfDecorator
                 * @type {function}
                 * @param {Object} prototype Target prototype
                 * @param {string} oneofName OneOf name
                 * @returns {undefined}
                 */

                /**
                 * OneOf decorator (TypeScript).
                 * @function
                 * @param {...string} fieldNames Field names
                 * @returns {OneOfDecorator} Decorator function
                 * @template T extends string
                 */


                OneOf.d = function decorateOneOf() {
                  var fieldNames = new Array(arguments.length),
                      index = 0;

                  while (index < arguments.length) {
                    fieldNames[index] = arguments[index++];
                  }

                  return function oneOfDecorator(prototype, oneofName) {
                    util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
                    Object.defineProperty(prototype, oneofName, {
                      get: util.oneOfGetter(fieldNames),
                      set: util.oneOfSetter(fieldNames)
                    });
                  };
                };
              }, {
                "16": 16,
                "24": 24,
                "37": 37
              }],
              26: [function (require, module, exports) {
                module.exports = parse;
                parse.filename = null;
                parse.defaults = {
                  keepCase: false
                };

                var tokenize = require(34),
                    Root = require(29),
                    Type = require(35),
                    Field = require(16),
                    MapField = require(20),
                    OneOf = require(25),
                    Enum = require(15),
                    Service = require(33),
                    Method = require(22),
                    types = require(36),
                    util = require(37);

                var base10Re = /^[1-9][0-9]*$/,
                    base10NegRe = /^-?[1-9][0-9]*$/,
                    base16Re = /^0[x][0-9a-fA-F]+$/,
                    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
                    base8Re = /^0[0-7]+$/,
                    base8NegRe = /^-?0[0-7]+$/,
                    numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
                    nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
                    typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
                    fqTypeRefRe = /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/;
                /**
                 * Result object returned from {@link parse}.
                 * @interface IParserResult
                 * @property {string|undefined} package Package name, if declared
                 * @property {string[]|undefined} imports Imports, if any
                 * @property {string[]|undefined} weakImports Weak imports, if any
                 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
                 * @property {Root} root Populated root instance
                 */

                /**
                 * Options modifying the behavior of {@link parse}.
                 * @interface IParseOptions
                 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
                 */

                /**
                 * Parses the given .proto source and returns an object with the parsed contents.
                 * @param {string} source Source contents
                 * @param {Root} root Root to populate
                 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
                 * @returns {IParserResult} Parser result
                 * @property {string} filename=null Currently processing file name for error reporting, if known
                 * @property {IParseOptions} defaults Default {@link IParseOptions}
                 */

                function parse(source, root, options) {
                  /* eslint-disable callback-return */
                  if (!(root instanceof Root)) {
                    options = root;
                    root = new Root();
                  }

                  if (!options) options = parse.defaults;
                  var tn = tokenize(source),
                      next = tn.next,
                      push = tn.push,
                      peek = tn.peek,
                      skip = tn.skip,
                      cmnt = tn.cmnt;
                  var head = true,
                      pkg,
                      imports,
                      weakImports,
                      syntax,
                      isProto3 = false;
                  var ptr = root;
                  var applyCase = options.keepCase ? function (name) {
                    return name;
                  } : util.camelCase;
                  /* istanbul ignore next */

                  function illegal(token, name, insideTryCatch) {
                    var filename = parse.filename;
                    if (!insideTryCatch) parse.filename = null;
                    return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
                  }

                  function readString() {
                    var values = [],
                        token;

                    do {
                      /* istanbul ignore if */
                      if ((token = next()) !== "\"" && token !== "'") throw illegal(token);
                      values.push(next());
                      skip(token);
                      token = peek();
                    } while (token === "\"" || token === "'");

                    return values.join("");
                  }

                  function readValue(acceptTypeRef) {
                    var token = next();

                    switch (token) {
                      case "'":
                      case "\"":
                        push(token);
                        return readString();

                      case "true":
                      case "TRUE":
                        return true;

                      case "false":
                      case "FALSE":
                        return false;
                    }

                    try {
                      return parseNumber(token,
                      /* insideTryCatch */
                      true);
                    } catch (e) {
                      /* istanbul ignore else */
                      if (acceptTypeRef && typeRefRe.test(token)) return token;
                      /* istanbul ignore next */

                      throw illegal(token, "value");
                    }
                  }

                  function readRanges(target, acceptStrings) {
                    var token, start;

                    do {
                      if (acceptStrings && ((token = peek()) === "\"" || token === "'")) target.push(readString());else target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
                    } while (skip(",", true));

                    skip(";");
                  }

                  function parseNumber(token, insideTryCatch) {
                    var sign = 1;

                    if (token.charAt(0) === "-") {
                      sign = -1;
                      token = token.substring(1);
                    }

                    switch (token) {
                      case "inf":
                      case "INF":
                      case "Inf":
                        return sign * Infinity;

                      case "nan":
                      case "NAN":
                      case "Nan":
                      case "NaN":
                        return NaN;

                      case "0":
                        return 0;
                    }

                    if (base10Re.test(token)) return sign * parseInt(token, 10);
                    if (base16Re.test(token)) return sign * parseInt(token, 16);
                    if (base8Re.test(token)) return sign * parseInt(token, 8);
                    /* istanbul ignore else */

                    if (numberRe.test(token)) return sign * parseFloat(token);
                    /* istanbul ignore next */

                    throw illegal(token, "number", insideTryCatch);
                  }

                  function parseId(token, acceptNegative) {
                    switch (token) {
                      case "max":
                      case "MAX":
                      case "Max":
                        return 536870911;

                      case "0":
                        return 0;
                    }
                    /* istanbul ignore if */


                    if (!acceptNegative && token.charAt(0) === "-") throw illegal(token, "id");
                    if (base10NegRe.test(token)) return parseInt(token, 10);
                    if (base16NegRe.test(token)) return parseInt(token, 16);
                    /* istanbul ignore else */

                    if (base8NegRe.test(token)) return parseInt(token, 8);
                    /* istanbul ignore next */

                    throw illegal(token, "id");
                  }

                  function parsePackage() {
                    /* istanbul ignore if */
                    if (pkg !== undefined$1) throw illegal("package");
                    pkg = next();
                    /* istanbul ignore if */

                    if (!typeRefRe.test(pkg)) throw illegal(pkg, "name");
                    ptr = ptr.define(pkg);
                    skip(";");
                  }

                  function parseImport() {
                    var token = peek();
                    var whichImports;

                    switch (token) {
                      case "weak":
                        whichImports = weakImports || (weakImports = []);
                        next();
                        break;

                      case "public":
                        next();
                      // eslint-disable-line no-fallthrough

                      default:
                        whichImports = imports || (imports = []);
                        break;
                    }

                    token = readString();
                    skip(";");
                    whichImports.push(token);
                  }

                  function parseSyntax() {
                    skip("=");
                    syntax = readString();
                    isProto3 = syntax === "proto3";
                    /* istanbul ignore if */

                    if (!isProto3 && syntax !== "proto2") throw illegal(syntax, "syntax");
                    skip(";");
                  }

                  function parseCommon(parent, token) {
                    switch (token) {
                      case "option":
                        parseOption(parent, token);
                        skip(";");
                        return true;

                      case "message":
                        parseType(parent, token);
                        return true;

                      case "enum":
                        parseEnum(parent, token);
                        return true;

                      case "service":
                        parseService(parent, token);
                        return true;

                      case "extend":
                        parseExtension(parent, token);
                        return true;
                    }

                    return false;
                  }

                  function ifBlock(obj, fnIf, fnElse) {
                    var trailingLine = tn.line;

                    if (obj) {
                      obj.comment = cmnt(); // try block-type comment

                      obj.filename = parse.filename;
                    }

                    if (skip("{", true)) {
                      var token;

                      while ((token = next()) !== "}") {
                        fnIf(token);
                      }

                      skip(";", true);
                    } else {
                      if (fnElse) fnElse();
                      skip(";");
                      if (obj && typeof obj.comment !== "string") obj.comment = cmnt(trailingLine); // try line-type comment if no block
                    }
                  }

                  function parseType(parent, token) {
                    /* istanbul ignore if */
                    if (!nameRe.test(token = next())) throw illegal(token, "type name");
                    var type = new Type(token);
                    ifBlock(type, function parseType_block(token) {
                      if (parseCommon(type, token)) return;

                      switch (token) {
                        case "map":
                          parseMapField(type);
                          break;

                        case "required":
                        case "optional":
                        case "repeated":
                          parseField(type, token);
                          break;

                        case "oneof":
                          parseOneOf(type, token);
                          break;

                        case "extensions":
                          readRanges(type.extensions || (type.extensions = []));
                          break;

                        case "reserved":
                          readRanges(type.reserved || (type.reserved = []), true);
                          break;

                        default:
                          /* istanbul ignore if */
                          if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);
                          push(token);
                          parseField(type, "optional");
                          break;
                      }
                    });
                    parent.add(type);
                  }

                  function parseField(parent, rule, extend) {
                    var type = next();

                    if (type === "group") {
                      parseGroup(parent, rule);
                      return;
                    }
                    /* istanbul ignore if */


                    if (!typeRefRe.test(type)) throw illegal(type, "type");
                    var name = next();
                    /* istanbul ignore if */

                    if (!nameRe.test(name)) throw illegal(name, "name");
                    name = applyCase(name);
                    skip("=");
                    var field = new Field(name, parseId(next()), type, rule, extend);
                    ifBlock(field, function parseField_block(token) {
                      /* istanbul ignore else */
                      if (token === "option") {
                        parseOption(field, token);
                        skip(";");
                      } else throw illegal(token);
                    }, function parseField_line() {
                      parseInlineOptions(field);
                    });
                    parent.add(field); // JSON defaults to packed=true if not set so we have to set packed=false explicity when
                    // parsing proto2 descriptors without the option, where applicable. This must be done for
                    // all known packable types and anything that could be an enum (= is not a basic type).

                    if (!isProto3 && field.repeated && (types.packed[type] !== undefined$1 || types.basic[type] === undefined$1)) field.setOption("packed", false,
                    /* ifNotSet */
                    true);
                  }

                  function parseGroup(parent, rule) {
                    var name = next();
                    /* istanbul ignore if */

                    if (!nameRe.test(name)) throw illegal(name, "name");
                    var fieldName = util.lcFirst(name);
                    if (name === fieldName) name = util.ucFirst(name);
                    skip("=");
                    var id = parseId(next());
                    var type = new Type(name);
                    type.group = true;
                    var field = new Field(fieldName, id, name, rule);
                    field.filename = parse.filename;
                    ifBlock(type, function parseGroup_block(token) {
                      switch (token) {
                        case "option":
                          parseOption(type, token);
                          skip(";");
                          break;

                        case "required":
                        case "optional":
                        case "repeated":
                          parseField(type, token);
                          break;

                        /* istanbul ignore next */

                        default:
                          throw illegal(token);
                        // there are no groups with proto3 semantics
                      }
                    });
                    parent.add(type).add(field);
                  }

                  function parseMapField(parent) {
                    skip("<");
                    var keyType = next();
                    /* istanbul ignore if */

                    if (types.mapKey[keyType] === undefined$1) throw illegal(keyType, "type");
                    skip(",");
                    var valueType = next();
                    /* istanbul ignore if */

                    if (!typeRefRe.test(valueType)) throw illegal(valueType, "type");
                    skip(">");
                    var name = next();
                    /* istanbul ignore if */

                    if (!nameRe.test(name)) throw illegal(name, "name");
                    skip("=");
                    var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
                    ifBlock(field, function parseMapField_block(token) {
                      /* istanbul ignore else */
                      if (token === "option") {
                        parseOption(field, token);
                        skip(";");
                      } else throw illegal(token);
                    }, function parseMapField_line() {
                      parseInlineOptions(field);
                    });
                    parent.add(field);
                  }

                  function parseOneOf(parent, token) {
                    /* istanbul ignore if */
                    if (!nameRe.test(token = next())) throw illegal(token, "name");
                    var oneof = new OneOf(applyCase(token));
                    ifBlock(oneof, function parseOneOf_block(token) {
                      if (token === "option") {
                        parseOption(oneof, token);
                        skip(";");
                      } else {
                        push(token);
                        parseField(oneof, "optional");
                      }
                    });
                    parent.add(oneof);
                  }

                  function parseEnum(parent, token) {
                    /* istanbul ignore if */
                    if (!nameRe.test(token = next())) throw illegal(token, "name");
                    var enm = new Enum(token);
                    ifBlock(enm, function parseEnum_block(token) {
                      switch (token) {
                        case "option":
                          parseOption(enm, token);
                          skip(";");
                          break;

                        case "reserved":
                          readRanges(enm.reserved || (enm.reserved = []), true);
                          break;

                        default:
                          parseEnumValue(enm, token);
                      }
                    });
                    parent.add(enm);
                  }

                  function parseEnumValue(parent, token) {
                    /* istanbul ignore if */
                    if (!nameRe.test(token)) throw illegal(token, "name");
                    skip("=");
                    var value = parseId(next(), true),
                        dummy = {};
                    ifBlock(dummy, function parseEnumValue_block(token) {
                      /* istanbul ignore else */
                      if (token === "option") {
                        parseOption(dummy, token); // skip

                        skip(";");
                      } else throw illegal(token);
                    }, function parseEnumValue_line() {
                      parseInlineOptions(dummy); // skip
                    });
                    parent.add(token, value, dummy.comment);
                  }

                  function parseOption(parent, token) {
                    var isCustom = skip("(", true);
                    /* istanbul ignore if */

                    if (!typeRefRe.test(token = next())) throw illegal(token, "name");
                    var name = token;

                    if (isCustom) {
                      skip(")");
                      name = "(" + name + ")";
                      token = peek();

                      if (fqTypeRefRe.test(token)) {
                        name += token;
                        next();
                      }
                    }

                    skip("=");
                    parseOptionValue(parent, name);
                  }

                  function parseOptionValue(parent, name) {
                    if (skip("{", true)) {
                      // { a: "foo" b { c: "bar" } }
                      do {
                        /* istanbul ignore if */
                        if (!nameRe.test(token = next())) throw illegal(token, "name");
                        if (peek() === "{") parseOptionValue(parent, name + "." + token);else {
                          skip(":");
                          if (peek() === "{") parseOptionValue(parent, name + "." + token);else setOption(parent, name + "." + token, readValue(true));
                        }
                      } while (!skip("}", true));
                    } else setOption(parent, name, readValue(true)); // Does not enforce a delimiter to be universal

                  }

                  function setOption(parent, name, value) {
                    if (parent.setOption) parent.setOption(name, value);
                  }

                  function parseInlineOptions(parent) {
                    if (skip("[", true)) {
                      do {
                        parseOption(parent, "option");
                      } while (skip(",", true));

                      skip("]");
                    }

                    return parent;
                  }

                  function parseService(parent, token) {
                    /* istanbul ignore if */
                    if (!nameRe.test(token = next())) throw illegal(token, "service name");
                    var service = new Service(token);
                    ifBlock(service, function parseService_block(token) {
                      if (parseCommon(service, token)) return;
                      /* istanbul ignore else */

                      if (token === "rpc") parseMethod(service, token);else throw illegal(token);
                    });
                    parent.add(service);
                  }

                  function parseMethod(parent, token) {
                    var type = token;
                    /* istanbul ignore if */

                    if (!nameRe.test(token = next())) throw illegal(token, "name");
                    var name = token,
                        requestType,
                        requestStream,
                        responseType,
                        responseStream;
                    skip("(");
                    if (skip("stream", true)) requestStream = true;
                    /* istanbul ignore if */

                    if (!typeRefRe.test(token = next())) throw illegal(token);
                    requestType = token;
                    skip(")");
                    skip("returns");
                    skip("(");
                    if (skip("stream", true)) responseStream = true;
                    /* istanbul ignore if */

                    if (!typeRefRe.test(token = next())) throw illegal(token);
                    responseType = token;
                    skip(")");
                    var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
                    ifBlock(method, function parseMethod_block(token) {
                      /* istanbul ignore else */
                      if (token === "option") {
                        parseOption(method, token);
                        skip(";");
                      } else throw illegal(token);
                    });
                    parent.add(method);
                  }

                  function parseExtension(parent, token) {
                    /* istanbul ignore if */
                    if (!typeRefRe.test(token = next())) throw illegal(token, "reference");
                    var reference = token;
                    ifBlock(null, function parseExtension_block(token) {
                      switch (token) {
                        case "required":
                        case "repeated":
                        case "optional":
                          parseField(parent, token, reference);
                          break;

                        default:
                          /* istanbul ignore if */
                          if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);
                          push(token);
                          parseField(parent, "optional", reference);
                          break;
                      }
                    });
                  }

                  var token;

                  while ((token = next()) !== null) {
                    switch (token) {
                      case "package":
                        /* istanbul ignore if */
                        if (!head) throw illegal(token);
                        parsePackage();
                        break;

                      case "import":
                        /* istanbul ignore if */
                        if (!head) throw illegal(token);
                        parseImport();
                        break;

                      case "syntax":
                        /* istanbul ignore if */
                        if (!head) throw illegal(token);
                        parseSyntax();
                        break;

                      case "option":
                        /* istanbul ignore if */
                        if (!head) throw illegal(token);
                        parseOption(ptr, token);
                        skip(";");
                        break;

                      default:
                        /* istanbul ignore else */
                        if (parseCommon(ptr, token)) {
                          head = false;
                          continue;
                        }
                        /* istanbul ignore next */


                        throw illegal(token);
                    }
                  }

                  parse.filename = null;
                  return {
                    "package": pkg,
                    "imports": imports,
                    weakImports: weakImports,
                    syntax: syntax,
                    root: root
                  };
                }
                /**
                 * Parses the given .proto source and returns an object with the parsed contents.
                 * @name parse
                 * @function
                 * @param {string} source Source contents
                 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
                 * @returns {IParserResult} Parser result
                 * @property {string} filename=null Currently processing file name for error reporting, if known
                 * @property {IParseOptions} defaults Default {@link IParseOptions}
                 * @variation 2
                 */

              }, {
                "15": 15,
                "16": 16,
                "20": 20,
                "22": 22,
                "25": 25,
                "29": 29,
                "33": 33,
                "34": 34,
                "35": 35,
                "36": 36,
                "37": 37
              }],
              27: [function (require, module, exports) {
                module.exports = Reader;

                var util = require(39);

                var BufferReader; // cyclic

                var LongBits = util.LongBits,
                    utf8 = util.utf8;
                /* istanbul ignore next */

                function indexOutOfRange(reader, writeLength) {
                  return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
                }
                /**
                 * Constructs a new reader instance using the specified buffer.
                 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
                 * @constructor
                 * @param {Uint8Array} buffer Buffer to read from
                 */


                function Reader(buffer) {
                  /**
                   * Read buffer.
                   * @type {Uint8Array}
                   */
                  this.buf = buffer;
                  /**
                   * Read buffer position.
                   * @type {number}
                   */

                  this.pos = 0;
                  /**
                   * Read buffer length.
                   * @type {number}
                   */

                  this.len = buffer.length;
                }

                var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
                  if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);
                  throw Error("illegal buffer");
                }
                /* istanbul ignore next */
                : function create_array(buffer) {
                  if (Array.isArray(buffer)) return new Reader(buffer);
                  throw Error("illegal buffer");
                };
                /**
                 * Creates a new reader using the specified buffer.
                 * @function
                 * @param {Uint8Array|Buffer} buffer Buffer to read from
                 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
                 * @throws {Error} If `buffer` is not a valid buffer
                 */

                Reader.create = util.Buffer ? function create_buffer_setup(buffer) {
                  return (Reader.create = function create_buffer(buffer) {
                    return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
                  })(buffer);
                }
                /* istanbul ignore next */
                : create_array;
                Reader.prototype._slice = util.Array.prototype.subarray ||
                /* istanbul ignore next */
                util.Array.prototype.slice;
                /**
                 * Reads a varint as an unsigned 32 bit value.
                 * @function
                 * @returns {number} Value read
                 */

                Reader.prototype.uint32 = function read_uint32_setup() {
                  var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)

                  return function read_uint32() {
                    value = (this.buf[this.pos] & 127) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    /* istanbul ignore if */

                    if ((this.pos += 5) > this.len) {
                      this.pos = this.len;
                      throw indexOutOfRange(this, 10);
                    }

                    return value;
                  };
                }();
                /**
                 * Reads a varint as a signed 32 bit value.
                 * @returns {number} Value read
                 */


                Reader.prototype.int32 = function read_int32() {
                  return this.uint32() | 0;
                };
                /**
                 * Reads a zig-zag encoded varint as a signed 32 bit value.
                 * @returns {number} Value read
                 */


                Reader.prototype.sint32 = function read_sint32() {
                  var value = this.uint32();
                  return value >>> 1 ^ -(value & 1) | 0;
                };
                /* eslint-disable no-invalid-this */


                function readLongVarint() {
                  // tends to deopt with local vars for octet etc.
                  var bits = new LongBits(0, 0);
                  var i = 0;

                  if (this.len - this.pos > 4) {
                    // fast route (lo)
                    for (; i < 4; ++i) {
                      // 1st..4th
                      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
                      if (this.buf[this.pos++] < 128) return bits;
                    } // 5th


                    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
                    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
                    if (this.buf[this.pos++] < 128) return bits;
                    i = 0;
                  } else {
                    for (; i < 3; ++i) {
                      /* istanbul ignore if */
                      if (this.pos >= this.len) throw indexOutOfRange(this); // 1st..3th

                      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
                      if (this.buf[this.pos++] < 128) return bits;
                    } // 4th


                    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
                    return bits;
                  }

                  if (this.len - this.pos > 4) {
                    // fast route (hi)
                    for (; i < 5; ++i) {
                      // 6th..10th
                      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
                      if (this.buf[this.pos++] < 128) return bits;
                    }
                  } else {
                    for (; i < 5; ++i) {
                      /* istanbul ignore if */
                      if (this.pos >= this.len) throw indexOutOfRange(this); // 6th..10th

                      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
                      if (this.buf[this.pos++] < 128) return bits;
                    }
                  }
                  /* istanbul ignore next */


                  throw Error("invalid varint encoding");
                }
                /* eslint-enable no-invalid-this */

                /**
                 * Reads a varint as a signed 64 bit value.
                 * @name Reader#int64
                 * @function
                 * @returns {Long} Value read
                 */

                /**
                 * Reads a varint as an unsigned 64 bit value.
                 * @name Reader#uint64
                 * @function
                 * @returns {Long} Value read
                 */

                /**
                 * Reads a zig-zag encoded varint as a signed 64 bit value.
                 * @name Reader#sint64
                 * @function
                 * @returns {Long} Value read
                 */

                /**
                 * Reads a varint as a boolean.
                 * @returns {boolean} Value read
                 */


                Reader.prototype.bool = function read_bool() {
                  return this.uint32() !== 0;
                };

                function readFixed32_end(buf, end) {
                  // note that this uses `end`, not `pos`
                  return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
                }
                /**
                 * Reads fixed 32 bits as an unsigned 32 bit integer.
                 * @returns {number} Value read
                 */


                Reader.prototype.fixed32 = function read_fixed32() {
                  /* istanbul ignore if */
                  if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
                  return readFixed32_end(this.buf, this.pos += 4);
                };
                /**
                 * Reads fixed 32 bits as a signed 32 bit integer.
                 * @returns {number} Value read
                 */


                Reader.prototype.sfixed32 = function read_sfixed32() {
                  /* istanbul ignore if */
                  if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
                  return readFixed32_end(this.buf, this.pos += 4) | 0;
                };
                /* eslint-disable no-invalid-this */


                function readFixed64()
                /* this: Reader */
                {
                  /* istanbul ignore if */
                  if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
                  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
                }
                /* eslint-enable no-invalid-this */

                /**
                 * Reads fixed 64 bits.
                 * @name Reader#fixed64
                 * @function
                 * @returns {Long} Value read
                 */

                /**
                 * Reads zig-zag encoded fixed 64 bits.
                 * @name Reader#sfixed64
                 * @function
                 * @returns {Long} Value read
                 */

                /**
                 * Reads a float (32 bit) as a number.
                 * @function
                 * @returns {number} Value read
                 */


                Reader.prototype["float"] = function read_float() {
                  /* istanbul ignore if */
                  if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
                  var value = util["float"].readFloatLE(this.buf, this.pos);
                  this.pos += 4;
                  return value;
                };
                /**
                 * Reads a double (64 bit float) as a number.
                 * @function
                 * @returns {number} Value read
                 */


                Reader.prototype["double"] = function read_double() {
                  /* istanbul ignore if */
                  if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
                  var value = util["float"].readDoubleLE(this.buf, this.pos);
                  this.pos += 8;
                  return value;
                };
                /**
                 * Reads a sequence of bytes preceeded by its length as a varint.
                 * @returns {Uint8Array} Value read
                 */


                Reader.prototype.bytes = function read_bytes() {
                  var length = this.uint32(),
                      start = this.pos,
                      end = this.pos + length;
                  /* istanbul ignore if */

                  if (end > this.len) throw indexOutOfRange(this, length);
                  this.pos += length;
                  if (Array.isArray(this.buf)) // plain array
                    return this.buf.slice(start, end);
                  return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
                  ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
                };
                /**
                 * Reads a string preceeded by its byte length as a varint.
                 * @returns {string} Value read
                 */


                Reader.prototype.string = function read_string() {
                  var bytes = this.bytes();
                  return utf8.read(bytes, 0, bytes.length);
                };
                /**
                 * Skips the specified number of bytes if specified, otherwise skips a varint.
                 * @param {number} [length] Length if known, otherwise a varint is assumed
                 * @returns {Reader} `this`
                 */


                Reader.prototype.skip = function skip(length) {
                  if (typeof length === "number") {
                    /* istanbul ignore if */
                    if (this.pos + length > this.len) throw indexOutOfRange(this, length);
                    this.pos += length;
                  } else {
                    do {
                      /* istanbul ignore if */
                      if (this.pos >= this.len) throw indexOutOfRange(this);
                    } while (this.buf[this.pos++] & 128);
                  }

                  return this;
                };
                /**
                 * Skips the next element of the specified wire type.
                 * @param {number} wireType Wire type received
                 * @returns {Reader} `this`
                 */


                Reader.prototype.skipType = function (wireType) {
                  switch (wireType) {
                    case 0:
                      this.skip();
                      break;

                    case 1:
                      this.skip(8);
                      break;

                    case 2:
                      this.skip(this.uint32());
                      break;

                    case 3:
                      do {
                        // eslint-disable-line no-constant-condition
                        if ((wireType = this.uint32() & 7) === 4) break;
                        this.skipType(wireType);
                      } while (true);

                      break;

                    case 5:
                      this.skip(4);
                      break;

                    /* istanbul ignore next */

                    default:
                      throw Error("invalid wire type " + wireType + " at offset " + this.pos);
                  }

                  return this;
                };

                Reader._configure = function (BufferReader_) {
                  BufferReader = BufferReader_;
                  var fn = util.Long ? "toLong" :
                  /* istanbul ignore next */
                  "toNumber";
                  util.merge(Reader.prototype, {
                    int64: function read_int64() {
                      return readLongVarint.call(this)[fn](false);
                    },
                    uint64: function read_uint64() {
                      return readLongVarint.call(this)[fn](true);
                    },
                    sint64: function read_sint64() {
                      return readLongVarint.call(this).zzDecode()[fn](false);
                    },
                    fixed64: function read_fixed64() {
                      return readFixed64.call(this)[fn](true);
                    },
                    sfixed64: function read_sfixed64() {
                      return readFixed64.call(this)[fn](false);
                    }
                  });
                };
              }, {
                "39": 39
              }],
              28: [function (require, module, exports) {
                module.exports = BufferReader; // extends Reader

                var Reader = require(27);

                (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

                var util = require(39);
                /**
                 * Constructs a new buffer reader instance.
                 * @classdesc Wire format reader using node buffers.
                 * @extends Reader
                 * @constructor
                 * @param {Buffer} buffer Buffer to read from
                 */


                function BufferReader(buffer) {
                  Reader.call(this, buffer);
                  /**
                   * Read buffer.
                   * @name BufferReader#buf
                   * @type {Buffer}
                   */
                }
                /* istanbul ignore else */


                if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;
                /**
                 * @override
                 */

                BufferReader.prototype.string = function read_string_buffer() {
                  var len = this.uint32(); // modifies pos

                  return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
                };
                /**
                 * Reads a sequence of bytes preceeded by its length as a varint.
                 * @name BufferReader#bytes
                 * @function
                 * @returns {Buffer} Value read
                 */

              }, {
                "27": 27,
                "39": 39
              }],
              29: [function (require, module, exports) {
                module.exports = Root; // extends Namespace

                var Namespace = require(23);

                ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

                var Field = require(16),
                    Enum = require(15),
                    OneOf = require(25),
                    util = require(37);

                var Type, // cyclic
                parse, // might be excluded
                common; // "

                /**
                 * Constructs a new root namespace instance.
                 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
                 * @extends NamespaceBase
                 * @constructor
                 * @param {Object.<string,*>} [options] Top level options
                 */

                function Root(options) {
                  Namespace.call(this, "", options);
                  /**
                   * Deferred extension fields.
                   * @type {Field[]}
                   */

                  this.deferred = [];
                  /**
                   * Resolved file names of loaded files.
                   * @type {string[]}
                   */

                  this.files = [];
                }
                /**
                 * Loads a namespace descriptor into a root namespace.
                 * @param {INamespace} json Nameespace descriptor
                 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
                 * @returns {Root} Root namespace
                 */


                Root.fromJSON = function fromJSON(json, root) {
                  if (!root) root = new Root();
                  if (json.options) root.setOptions(json.options);
                  return root.addJSON(json.nested);
                };
                /**
                 * Resolves the path of an imported file, relative to the importing origin.
                 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
                 * @function
                 * @param {string} origin The file name of the importing file
                 * @param {string} target The file name being imported
                 * @returns {string|null} Resolved path to `target` or `null` to skip the file
                 */


                Root.prototype.resolvePath = util.path.resolve; // A symbol-like function to safely signal synchronous loading

                /* istanbul ignore next */

                function SYNC() {} // eslint-disable-line no-empty-function

                /**
                 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
                 * @param {string|string[]} filename Names of one or multiple files to load
                 * @param {IParseOptions} options Parse options
                 * @param {LoadCallback} callback Callback function
                 * @returns {undefined}
                 */


                Root.prototype.load = function load(filename, options, callback) {
                  if (typeof options === "function") {
                    callback = options;
                    options = undefined$1;
                  }

                  var self = this;
                  if (!callback) return util.asPromise(load, self, filename, options);
                  var sync = callback === SYNC; // undocumented
                  // Finishes loading by calling the callback (exactly once)

                  function finish(err, root) {
                    /* istanbul ignore if */
                    if (!callback) return;
                    var cb = callback;
                    callback = null;
                    if (sync) throw err;
                    cb(err, root);
                  } // Processes a single file


                  function process(filename, source) {
                    try {
                      if (util.isString(source) && source.charAt(0) === "{") source = JSON.parse(source);
                      if (!util.isString(source)) self.setOptions(source.options).addJSON(source.nested);else {
                        parse.filename = filename;
                        var parsed = parse(source, self, options),
                            resolved,
                            i = 0;
                        if (parsed.imports) for (; i < parsed.imports.length; ++i) {
                          if (resolved = self.resolvePath(filename, parsed.imports[i])) fetch(resolved);
                        }
                        if (parsed.weakImports) for (i = 0; i < parsed.weakImports.length; ++i) {
                          if (resolved = self.resolvePath(filename, parsed.weakImports[i])) fetch(resolved, true);
                        }
                      }
                    } catch (err) {
                      finish(err);
                    }

                    if (!sync && !queued) finish(null, self); // only once anyway
                  } // Fetches a single file


                  function fetch(filename, weak) {
                    // Strip path if this file references a bundled definition
                    var idx = filename.lastIndexOf("google/protobuf/");

                    if (idx > -1) {
                      var altname = filename.substring(idx);
                      if (altname in common) filename = altname;
                    } // Skip if already loaded / attempted


                    if (self.files.indexOf(filename) > -1) return;
                    self.files.push(filename); // Shortcut bundled definitions

                    if (filename in common) {
                      if (sync) process(filename, common[filename]);else {
                        ++queued;
                        setTimeout(function () {
                          --queued;
                          process(filename, common[filename]);
                        });
                      }
                      return;
                    } // Otherwise fetch from disk or network


                    if (sync) {
                      var source;

                      try {
                        source = util.fs.readFileSync(filename).toString("utf8");
                      } catch (err) {
                        if (!weak) finish(err);
                        return;
                      }

                      process(filename, source);
                    } else {
                      ++queued;
                      util.fetch(filename, function (err, source) {
                        --queued;
                        /* istanbul ignore if */

                        if (!callback) return; // terminated meanwhile

                        if (err) {
                          /* istanbul ignore else */
                          if (!weak) finish(err);else if (!queued) // can't be covered reliably
                            finish(null, self);
                          return;
                        }

                        process(filename, source);
                      });
                    }
                  }

                  var queued = 0; // Assembling the root namespace doesn't require working type
                  // references anymore, so we can load everything in parallel

                  if (util.isString(filename)) filename = [filename];

                  for (var i = 0, resolved; i < filename.length; ++i) {
                    if (resolved = self.resolvePath("", filename[i])) fetch(resolved);
                  }

                  if (sync) return self;
                  if (!queued) finish(null, self);
                  return undefined$1;
                }; // function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

                /**
                 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
                 * @function Root#load
                 * @param {string|string[]} filename Names of one or multiple files to load
                 * @param {LoadCallback} callback Callback function
                 * @returns {undefined}
                 * @variation 2
                 */
                // function load(filename:string, callback:LoadCallback):undefined

                /**
                 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
                 * @function Root#load
                 * @param {string|string[]} filename Names of one or multiple files to load
                 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
                 * @returns {Promise<Root>} Promise
                 * @variation 3
                 */
                // function load(filename:string, [options:IParseOptions]):Promise<Root>

                /**
                 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
                 * @function Root#loadSync
                 * @param {string|string[]} filename Names of one or multiple files to load
                 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
                 * @returns {Root} Root namespace
                 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
                 */


                Root.prototype.loadSync = function loadSync(filename, options) {
                  if (!util.isNode) throw Error("not supported");
                  return this.load(filename, options, SYNC);
                };
                /**
                 * @override
                 */


                Root.prototype.resolveAll = function resolveAll() {
                  if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function (field) {
                    return "'extend " + field.extend + "' in " + field.parent.fullName;
                  }).join(", "));
                  return Namespace.prototype.resolveAll.call(this);
                }; // only uppercased (and thus conflict-free) children are exposed, see below


                var exposeRe = /^[A-Z]/;
                /**
                 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
                 * @param {Root} root Root instance
                 * @param {Field} field Declaring extension field witin the declaring type
                 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
                 * @inner
                 * @ignore
                 */

                function tryHandleExtension(root, field) {
                  var extendedType = field.parent.lookup(field.extend);

                  if (extendedType) {
                    var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined$1, field.options);
                    sisterField.declaringField = field;
                    field.extensionField = sisterField;
                    extendedType.add(sisterField);
                    return true;
                  }

                  return false;
                }
                /**
                 * Called when any object is added to this root or its sub-namespaces.
                 * @param {ReflectionObject} object Object added
                 * @returns {undefined}
                 * @private
                 */


                Root.prototype._handleAdd = function _handleAdd(object) {
                  if (object instanceof Field) {
                    if (
                    /* an extension field (implies not part of a oneof) */
                    object.extend !== undefined$1 &&
                    /* not already handled */
                    !object.extensionField) if (!tryHandleExtension(this, object)) this.deferred.push(object);
                  } else if (object instanceof Enum) {
                    if (exposeRe.test(object.name)) object.parent[object.name] = object.values; // expose enum values as property of its parent
                  } else if (!(object instanceof OneOf))
                    /* everything else is a namespace */
                    {
                      if (object instanceof Type) // Try to handle any deferred extensions
                        for (var i = 0; i < this.deferred.length;) {
                          if (tryHandleExtension(this, this.deferred[i])) this.deferred.splice(i, 1);else ++i;
                        }

                      for (var j = 0; j <
                      /* initializes */
                      object.nestedArray.length; ++j) {
                        // recurse into the namespace
                        this._handleAdd(object._nestedArray[j]);
                      }

                      if (exposeRe.test(object.name)) object.parent[object.name] = object; // expose namespace as property of its parent
                    } // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
                  // properties of namespaces just like static code does. This allows using a .d.ts generated for
                  // a static module with reflection-based solutions where the condition is met.

                };
                /**
                 * Called when any object is removed from this root or its sub-namespaces.
                 * @param {ReflectionObject} object Object removed
                 * @returns {undefined}
                 * @private
                 */


                Root.prototype._handleRemove = function _handleRemove(object) {
                  if (object instanceof Field) {
                    if (
                    /* an extension field */
                    object.extend !== undefined$1) {
                      if (
                      /* already handled */
                      object.extensionField) {
                        // remove its sister field
                        object.extensionField.parent.remove(object.extensionField);
                        object.extensionField = null;
                      } else {
                        // cancel the extension
                        var index = this.deferred.indexOf(object);
                        /* istanbul ignore else */

                        if (index > -1) this.deferred.splice(index, 1);
                      }
                    }
                  } else if (object instanceof Enum) {
                    if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose enum values
                  } else if (object instanceof Namespace) {
                    for (var i = 0; i <
                    /* initializes */
                    object.nestedArray.length; ++i) {
                      // recurse into the namespace
                      this._handleRemove(object._nestedArray[i]);
                    }

                    if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose namespaces
                  }
                };

                Root._configure = function (Type_, parse_, common_) {
                  Type = Type_;
                  parse = parse_;
                  common = common_;
                };
              }, {
                "15": 15,
                "16": 16,
                "23": 23,
                "25": 25,
                "37": 37
              }],
              30: [function (require, module, exports) {
                module.exports = {};
                /**
                 * Named roots.
                 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
                 * Can also be used manually to make roots available accross modules.
                 * @name roots
                 * @type {Object.<string,Root>}
                 * @example
                 * // pbjs -r myroot -o compiled.js ...
                 *
                 * // in another module:
                 * require("./compiled.js");
                 *
                 * // in any subsequent module:
                 * var root = protobuf.roots["myroot"];
                 */
              }, {}],
              31: [function (require, module, exports) {
                /**
                 * Streaming RPC helpers.
                 * @namespace
                 */
                var rpc = exports;
                /**
                 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
                 * @typedef RPCImpl
                 * @type {function}
                 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
                 * @param {Uint8Array} requestData Request data
                 * @param {RPCImplCallback} callback Callback function
                 * @returns {undefined}
                 * @example
                 * function rpcImpl(method, requestData, callback) {
                 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
                 *         throw Error("no such method");
                 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
                 *         callback(err, responseData);
                 *     });
                 * }
                 */

                /**
                 * Node-style callback as used by {@link RPCImpl}.
                 * @typedef RPCImplCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any, otherwise `null`
                 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
                 * @returns {undefined}
                 */

                rpc.Service = require(32);
              }, {
                "32": 32
              }],
              32: [function (require, module, exports) {
                module.exports = Service;

                var util = require(39); // Extends EventEmitter


                (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
                /**
                 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
                 *
                 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
                 * @typedef rpc.ServiceMethodCallback
                 * @template TRes extends Message<TRes>
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {TRes} [response] Response message
                 * @returns {undefined}
                 */

                /**
                 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
                 * @typedef rpc.ServiceMethod
                 * @template TReq extends Message<TReq>
                 * @template TRes extends Message<TRes>
                 * @type {function}
                 * @param {TReq|Properties<TReq>} request Request message or plain object
                 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
                 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
                 */

                /**
                 * Constructs a new RPC service instance.
                 * @classdesc An RPC service as returned by {@link Service#create}.
                 * @exports rpc.Service
                 * @extends util.EventEmitter
                 * @constructor
                 * @param {RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */

                function Service(rpcImpl, requestDelimited, responseDelimited) {
                  if (typeof rpcImpl !== "function") throw TypeError("rpcImpl must be a function");
                  util.EventEmitter.call(this);
                  /**
                   * RPC implementation. Becomes `null` once the service is ended.
                   * @type {RPCImpl|null}
                   */

                  this.rpcImpl = rpcImpl;
                  /**
                   * Whether requests are length-delimited.
                   * @type {boolean}
                   */

                  this.requestDelimited = Boolean(requestDelimited);
                  /**
                   * Whether responses are length-delimited.
                   * @type {boolean}
                   */

                  this.responseDelimited = Boolean(responseDelimited);
                }
                /**
                 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
                 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
                 * @param {Constructor<TReq>} requestCtor Request constructor
                 * @param {Constructor<TRes>} responseCtor Response constructor
                 * @param {TReq|Properties<TReq>} request Request message or plain object
                 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
                 * @returns {undefined}
                 * @template TReq extends Message<TReq>
                 * @template TRes extends Message<TRes>
                 */


                Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
                  if (!request) throw TypeError("request must be specified");
                  var self = this;
                  if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

                  if (!self.rpcImpl) {
                    setTimeout(function () {
                      callback(Error("already ended"));
                    }, 0);
                    return undefined$1;
                  }

                  try {
                    return self.rpcImpl(method, requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
                      if (err) {
                        self.emit("error", err, method);
                        return callback(err);
                      }

                      if (response === null) {
                        self.end(
                        /* endedByRPC */
                        true);
                        return undefined$1;
                      }

                      if (!(response instanceof responseCtor)) {
                        try {
                          response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                        } catch (err) {
                          self.emit("error", err, method);
                          return callback(err);
                        }
                      }

                      self.emit("data", response, method);
                      return callback(null, response);
                    });
                  } catch (err) {
                    self.emit("error", err, method);
                    setTimeout(function () {
                      callback(err);
                    }, 0);
                    return undefined$1;
                  }
                };
                /**
                 * Ends this service and emits the `end` event.
                 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
                 * @returns {rpc.Service} `this`
                 */


                Service.prototype.end = function end(endedByRPC) {
                  if (this.rpcImpl) {
                    if (!endedByRPC) // signal end to rpcImpl
                      this.rpcImpl(null, null, null);
                    this.rpcImpl = null;
                    this.emit("end").off();
                  }

                  return this;
                };
              }, {
                "39": 39
              }],
              33: [function (require, module, exports) {
                module.exports = Service; // extends Namespace

                var Namespace = require(23);

                ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

                var Method = require(22),
                    util = require(37),
                    rpc = require(31);
                /**
                 * Constructs a new service instance.
                 * @classdesc Reflected service.
                 * @extends NamespaceBase
                 * @constructor
                 * @param {string} name Service name
                 * @param {Object.<string,*>} [options] Service options
                 * @throws {TypeError} If arguments are invalid
                 */


                function Service(name, options) {
                  Namespace.call(this, name, options);
                  /**
                   * Service methods.
                   * @type {Object.<string,Method>}
                   */

                  this.methods = {}; // toJSON, marker

                  /**
                   * Cached methods as an array.
                   * @type {Method[]|null}
                   * @private
                   */

                  this._methodsArray = null;
                }
                /**
                 * Service descriptor.
                 * @interface IService
                 * @extends INamespace
                 * @property {Object.<string,IMethod>} methods Method descriptors
                 */

                /**
                 * Constructs a service from a service descriptor.
                 * @param {string} name Service name
                 * @param {IService} json Service descriptor
                 * @returns {Service} Created service
                 * @throws {TypeError} If arguments are invalid
                 */


                Service.fromJSON = function fromJSON(name, json) {
                  var service = new Service(name, json.options);
                  /* istanbul ignore else */

                  if (json.methods) for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i) {
                    service.add(Method.fromJSON(names[i], json.methods[names[i]]));
                  }
                  if (json.nested) service.addJSON(json.nested);
                  return service;
                };
                /**
                 * Converts this service to a service descriptor.
                 * @returns {IService} Service descriptor
                 */


                Service.prototype.toJSON = function toJSON() {
                  var inherited = Namespace.prototype.toJSON.call(this);
                  return util.toObject(["options", inherited && inherited.options || undefined$1, "methods", Namespace.arrayToJSON(this.methodsArray) ||
                  /* istanbul ignore next */
                  {}, "nested", inherited && inherited.nested || undefined$1]);
                };
                /**
                 * Methods of this service as an array for iteration.
                 * @name Service#methodsArray
                 * @type {Method[]}
                 * @readonly
                 */


                Object.defineProperty(Service.prototype, "methodsArray", {
                  get: function get() {
                    return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
                  }
                });

                function clearCache(service) {
                  service._methodsArray = null;
                  return service;
                }
                /**
                 * @override
                 */


                Service.prototype.get = function get(name) {
                  return this.methods[name] || Namespace.prototype.get.call(this, name);
                };
                /**
                 * @override
                 */


                Service.prototype.resolveAll = function resolveAll() {
                  var methods = this.methodsArray;

                  for (var i = 0; i < methods.length; ++i) {
                    methods[i].resolve();
                  }

                  return Namespace.prototype.resolve.call(this);
                };
                /**
                 * @override
                 */


                Service.prototype.add = function add(object) {
                  /* istanbul ignore if */
                  if (this.get(object.name)) throw Error("duplicate name '" + object.name + "' in " + this);

                  if (object instanceof Method) {
                    this.methods[object.name] = object;
                    object.parent = this;
                    return clearCache(this);
                  }

                  return Namespace.prototype.add.call(this, object);
                };
                /**
                 * @override
                 */


                Service.prototype.remove = function remove(object) {
                  if (object instanceof Method) {
                    /* istanbul ignore if */
                    if (this.methods[object.name] !== object) throw Error(object + " is not a member of " + this);
                    delete this.methods[object.name];
                    object.parent = null;
                    return clearCache(this);
                  }

                  return Namespace.prototype.remove.call(this, object);
                };
                /**
                 * Creates a runtime service using the specified rpc implementation.
                 * @param {RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
                 */


                Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                  var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);

                  for (var i = 0, method; i <
                  /* initializes */
                  this.methodsArray.length; ++i) {
                    var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
                    rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
                      m: method,
                      q: method.resolvedRequestType.ctor,
                      s: method.resolvedResponseType.ctor
                    });
                  }

                  return rpcService;
                };
              }, {
                "22": 22,
                "23": 23,
                "31": 31,
                "37": 37
              }],
              34: [function (require, module, exports) {
                module.exports = tokenize;
                var delimRe = /[\s{}=;:[\],'"()<>]/g,
                    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
                    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
                var setCommentRe = /^ *[*/]+ */,
                    setCommentSplitRe = /\n/g,
                    whitespaceRe = /\s/,
                    unescapeRe = /\\(.?)/g;
                var unescapeMap = {
                  "0": "\0",
                  "r": "\r",
                  "n": "\n",
                  "t": "\t"
                };
                /**
                 * Unescapes a string.
                 * @param {string} str String to unescape
                 * @returns {string} Unescaped string
                 * @property {Object.<string,string>} map Special characters map
                 * @memberof tokenize
                 */

                function unescape(str) {
                  return str.replace(unescapeRe, function ($0, $1) {
                    switch ($1) {
                      case "\\":
                      case "":
                        return $1;

                      default:
                        return unescapeMap[$1] || "";
                    }
                  });
                }

                tokenize.unescape = unescape;
                /**
                 * Gets the next token and advances.
                 * @typedef TokenizerHandleNext
                 * @type {function}
                 * @returns {string|null} Next token or `null` on eof
                 */

                /**
                 * Peeks for the next token.
                 * @typedef TokenizerHandlePeek
                 * @type {function}
                 * @returns {string|null} Next token or `null` on eof
                 */

                /**
                 * Pushes a token back to the stack.
                 * @typedef TokenizerHandlePush
                 * @type {function}
                 * @param {string} token Token
                 * @returns {undefined}
                 */

                /**
                 * Skips the next token.
                 * @typedef TokenizerHandleSkip
                 * @type {function}
                 * @param {string} expected Expected token
                 * @param {boolean} [optional=false] If optional
                 * @returns {boolean} Whether the token matched
                 * @throws {Error} If the token didn't match and is not optional
                 */

                /**
                 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
                 * @typedef TokenizerHandleCmnt
                 * @type {function}
                 * @param {number} [line] Line number
                 * @returns {string|null} Comment text or `null` if none
                 */

                /**
                 * Handle object returned from {@link tokenize}.
                 * @interface ITokenizerHandle
                 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
                 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
                 * @property {TokenizerHandlePush} push Pushes a token back to the stack
                 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
                 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
                 * @property {number} line Current line number
                 */

                /**
                 * Tokenizes the given .proto source and returns an object with useful utility functions.
                 * @param {string} source Source contents
                 * @returns {ITokenizerHandle} Tokenizer handle
                 */

                function tokenize(source) {
                  /* eslint-disable callback-return */
                  source = source.toString();
                  var offset = 0,
                      length = source.length,
                      line = 1,
                      commentType = null,
                      commentText = null,
                      commentLine = 0,
                      commentLineEmpty = false;
                  var stack = [];
                  var stringDelim = null;
                  /* istanbul ignore next */

                  /**
                   * Creates an error for illegal syntax.
                   * @param {string} subject Subject
                   * @returns {Error} Error created
                   * @inner
                   */

                  function illegal(subject) {
                    return Error("illegal " + subject + " (line " + line + ")");
                  }
                  /**
                   * Reads a string till its end.
                   * @returns {string} String read
                   * @inner
                   */


                  function readString() {
                    var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
                    re.lastIndex = offset - 1;
                    var match = re.exec(source);
                    if (!match) throw illegal("string");
                    offset = re.lastIndex;
                    push(stringDelim);
                    stringDelim = null;
                    return unescape(match[1]);
                  }
                  /**
                   * Gets the character at `pos` within the source.
                   * @param {number} pos Position
                   * @returns {string} Character
                   * @inner
                   */


                  function charAt(pos) {
                    return source.charAt(pos);
                  }
                  /**
                   * Sets the current comment text.
                   * @param {number} start Start offset
                   * @param {number} end End offset
                   * @returns {undefined}
                   * @inner
                   */


                  function setComment(start, end) {
                    commentType = source.charAt(start++);
                    commentLine = line;
                    commentLineEmpty = false;
                    var offset = start - 3,
                        // "///" or "/**"
                    c;

                    do {
                      if (--offset < 0 || (c = source.charAt(offset)) === "\n") {
                        commentLineEmpty = true;
                        break;
                      }
                    } while (c === " " || c === "\t");

                    var lines = source.substring(start, end).split(setCommentSplitRe);

                    for (var i = 0; i < lines.length; ++i) {
                      lines[i] = lines[i].replace(setCommentRe, "").trim();
                    }

                    commentText = lines.join("\n").trim();
                  }
                  /**
                   * Obtains the next token.
                   * @returns {string|null} Next token or `null` on eof
                   * @inner
                   */


                  function next() {
                    if (stack.length > 0) return stack.shift();
                    if (stringDelim) return readString();
                    var repeat, prev, curr, start, isDoc;

                    do {
                      if (offset === length) return null;
                      repeat = false;

                      while (whitespaceRe.test(curr = charAt(offset))) {
                        if (curr === "\n") ++line;
                        if (++offset === length) return null;
                      }

                      if (charAt(offset) === "/") {
                        if (++offset === length) throw illegal("comment");

                        if (charAt(offset) === "/") {
                          // Line
                          isDoc = charAt(start = offset + 1) === "/";

                          while (charAt(++offset) !== "\n") {
                            if (offset === length) return null;
                          }

                          ++offset;
                          if (isDoc) /// Comment
                            setComment(start, offset - 1);
                          ++line;
                          repeat = true;
                        } else if ((curr = charAt(offset)) === "*") {
                          /* Block */
                          isDoc = charAt(start = offset + 1) === "*";

                          do {
                            if (curr === "\n") ++line;
                            if (++offset === length) throw illegal("comment");
                            prev = curr;
                            curr = charAt(offset);
                          } while (prev !== "*" || curr !== "/");

                          ++offset;
                          if (isDoc)
                            /** Comment */
                            setComment(start, offset - 2);
                          repeat = true;
                        } else return "/";
                      }
                    } while (repeat); // offset !== length if we got here


                    var end = offset;
                    delimRe.lastIndex = 0;
                    var delim = delimRe.test(charAt(end++));
                    if (!delim) while (end < length && !delimRe.test(charAt(end))) {
                      ++end;
                    }
                    var token = source.substring(offset, offset = end);
                    if (token === "\"" || token === "'") stringDelim = token;
                    return token;
                  }
                  /**
                   * Pushes a token back to the stack.
                   * @param {string} token Token
                   * @returns {undefined}
                   * @inner
                   */


                  function push(token) {
                    stack.push(token);
                  }
                  /**
                   * Peeks for the next token.
                   * @returns {string|null} Token or `null` on eof
                   * @inner
                   */


                  function peek() {
                    if (!stack.length) {
                      var token = next();
                      if (token === null) return null;
                      push(token);
                    }

                    return stack[0];
                  }
                  /**
                   * Skips a token.
                   * @param {string} expected Expected token
                   * @param {boolean} [optional=false] Whether the token is optional
                   * @returns {boolean} `true` when skipped, `false` if not
                   * @throws {Error} When a required token is not present
                   * @inner
                   */


                  function skip(expected, optional) {
                    var actual = peek(),
                        equals = actual === expected;

                    if (equals) {
                      next();
                      return true;
                    }

                    if (!optional) throw illegal("token '" + actual + "', '" + expected + "' expected");
                    return false;
                  }
                  /**
                   * Gets a comment.
                   * @param {number} [trailingLine] Line number if looking for a trailing comment
                   * @returns {string|null} Comment text
                   * @inner
                   */


                  function cmnt(trailingLine) {
                    var ret = null;

                    if (trailingLine === undefined$1) {
                      if (commentLine === line - 1 && (commentType === "*" || commentLineEmpty)) ret = commentText;
                    } else {
                      /* istanbul ignore else */
                      if (commentLine < trailingLine) peek();
                      if (commentLine === trailingLine && !commentLineEmpty && commentType === "/") ret = commentText;
                    }

                    return ret;
                  }

                  return Object.defineProperty({
                    next: next,
                    peek: peek,
                    push: push,
                    skip: skip,
                    cmnt: cmnt
                  }, "line", {
                    get: function get() {
                      return line;
                    }
                  });
                  /* eslint-enable callback-return */
                }
              }, {}],
              35: [function (require, module, exports) {
                module.exports = Type; // extends Namespace

                var Namespace = require(23);

                ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

                var Enum = require(15),
                    OneOf = require(25),
                    Field = require(16),
                    MapField = require(20),
                    Service = require(33),
                    Message = require(21),
                    Reader = require(27),
                    Writer = require(42),
                    util = require(37),
                    encoder = require(14),
                    decoder = require(13),
                    verifier = require(40),
                    converter = require(12),
                    wrappers = require(41);
                /**
                 * Constructs a new reflected message type instance.
                 * @classdesc Reflected message type.
                 * @extends NamespaceBase
                 * @constructor
                 * @param {string} name Message name
                 * @param {Object.<string,*>} [options] Declared options
                 */


                function Type(name, options) {
                  Namespace.call(this, name, options);
                  /**
                   * Message fields.
                   * @type {Object.<string,Field>}
                   */

                  this.fields = {}; // toJSON, marker

                  /**
                   * Oneofs declared within this namespace, if any.
                   * @type {Object.<string,OneOf>}
                   */

                  this.oneofs = undefined$1; // toJSON

                  /**
                   * Extension ranges, if any.
                   * @type {number[][]}
                   */

                  this.extensions = undefined$1; // toJSON

                  /**
                   * Reserved ranges, if any.
                   * @type {Array.<number[]|string>}
                   */

                  this.reserved = undefined$1; // toJSON

                  /*?
                   * Whether this type is a legacy group.
                   * @type {boolean|undefined}
                   */

                  this.group = undefined$1; // toJSON

                  /**
                   * Cached fields by id.
                   * @type {Object.<number,Field>|null}
                   * @private
                   */

                  this._fieldsById = null;
                  /**
                   * Cached fields as an array.
                   * @type {Field[]|null}
                   * @private
                   */

                  this._fieldsArray = null;
                  /**
                   * Cached oneofs as an array.
                   * @type {OneOf[]|null}
                   * @private
                   */

                  this._oneofsArray = null;
                  /**
                   * Cached constructor.
                   * @type {Constructor<{}>}
                   * @private
                   */

                  this._ctor = null;
                }

                Object.defineProperties(Type.prototype, {
                  /**
                   * Message fields by id.
                   * @name Type#fieldsById
                   * @type {Object.<number,Field>}
                   * @readonly
                   */
                  fieldsById: {
                    get: function get() {
                      /* istanbul ignore if */
                      if (this._fieldsById) return this._fieldsById;
                      this._fieldsById = {};

                      for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                        var field = this.fields[names[i]],
                            id = field.id;
                        /* istanbul ignore if */

                        if (this._fieldsById[id]) throw Error("duplicate id " + id + " in " + this);
                        this._fieldsById[id] = field;
                      }

                      return this._fieldsById;
                    }
                  },

                  /**
                   * Fields of this message as an array for iteration.
                   * @name Type#fieldsArray
                   * @type {Field[]}
                   * @readonly
                   */
                  fieldsArray: {
                    get: function get() {
                      return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
                    }
                  },

                  /**
                   * Oneofs of this message as an array for iteration.
                   * @name Type#oneofsArray
                   * @type {OneOf[]}
                   * @readonly
                   */
                  oneofsArray: {
                    get: function get() {
                      return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
                    }
                  },

                  /**
                   * The registered constructor, if any registered, otherwise a generic constructor.
                   * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
                   * @name Type#ctor
                   * @type {Constructor<{}>}
                   */
                  ctor: {
                    get: function get() {
                      return this._ctor || (this.ctor = Type.generateConstructor(this)());
                    },
                    set: function set(ctor) {
                      // Ensure proper prototype
                      var prototype = ctor.prototype;

                      if (!(prototype instanceof Message)) {
                        (ctor.prototype = new Message()).constructor = ctor;
                        util.merge(ctor.prototype, prototype);
                      } // Classes and messages reference their reflected type


                      ctor.$type = ctor.prototype.$type = this; // Mix in static methods

                      util.merge(ctor, Message, true);
                      this._ctor = ctor; // Messages have non-enumerable default values on their prototype

                      var i = 0;

                      for (; i <
                      /* initializes */
                      this.fieldsArray.length; ++i) {
                        this._fieldsArray[i].resolve();
                      } // ensures a proper value
                      // Messages have non-enumerable getters and setters for each virtual oneof field


                      var ctorProperties = {};

                      for (i = 0; i <
                      /* initializes */
                      this.oneofsArray.length; ++i) {
                        ctorProperties[this._oneofsArray[i].resolve().name] = {
                          get: util.oneOfGetter(this._oneofsArray[i].oneof),
                          set: util.oneOfSetter(this._oneofsArray[i].oneof)
                        };
                      }

                      if (i) Object.defineProperties(ctor.prototype, ctorProperties);
                    }
                  }
                });
                /**
                 * Generates a constructor function for the specified type.
                 * @param {Type} mtype Message type
                 * @returns {Codegen} Codegen instance
                 */

                Type.generateConstructor = function generateConstructor(mtype) {
                  /* eslint-disable no-unexpected-multiline */
                  var gen = util.codegen(["p"], mtype.name); // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype

                  for (var i = 0, field; i < mtype.fieldsArray.length; ++i) {
                    if ((field = mtype._fieldsArray[i]).map) gen("this%s={}", util.safeProp(field.name));else if (field.repeated) gen("this%s=[]", util.safeProp(field.name));
                  }

                  return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
                  ("this[ks[i]]=p[ks[i]]");
                  /* eslint-enable no-unexpected-multiline */
                };

                function clearCache(type) {
                  type._fieldsById = type._fieldsArray = type._oneofsArray = null;
                  delete type.encode;
                  delete type.decode;
                  delete type.verify;
                  return type;
                }
                /**
                 * Message type descriptor.
                 * @interface IType
                 * @extends INamespace
                 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
                 * @property {Object.<string,IField>} fields Field descriptors
                 * @property {number[][]} [extensions] Extension ranges
                 * @property {number[][]} [reserved] Reserved ranges
                 * @property {boolean} [group=false] Whether a legacy group or not
                 */

                /**
                 * Creates a message type from a message type descriptor.
                 * @param {string} name Message name
                 * @param {IType} json Message type descriptor
                 * @returns {Type} Created message type
                 */


                Type.fromJSON = function fromJSON(name, json) {
                  var type = new Type(name, json.options);
                  type.extensions = json.extensions;
                  type.reserved = json.reserved;
                  var names = Object.keys(json.fields),
                      i = 0;

                  for (; i < names.length; ++i) {
                    type.add((typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));
                  }

                  if (json.oneofs) for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i) {
                    type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
                  }
                  if (json.nested) for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
                    var nested = json.nested[names[i]];
                    type.add( // most to least likely
                    (nested.id !== undefined$1 ? Field.fromJSON : nested.fields !== undefined$1 ? Type.fromJSON : nested.values !== undefined$1 ? Enum.fromJSON : nested.methods !== undefined$1 ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));
                  }
                  if (json.extensions && json.extensions.length) type.extensions = json.extensions;
                  if (json.reserved && json.reserved.length) type.reserved = json.reserved;
                  if (json.group) type.group = true;
                  return type;
                };
                /**
                 * Converts this message type to a message type descriptor.
                 * @returns {IType} Message type descriptor
                 */


                Type.prototype.toJSON = function toJSON() {
                  var inherited = Namespace.prototype.toJSON.call(this);
                  return util.toObject(["options", inherited && inherited.options || undefined$1, "oneofs", Namespace.arrayToJSON(this.oneofsArray), "fields", Namespace.arrayToJSON(this.fieldsArray.filter(function (obj) {
                    return !obj.declaringField;
                  })) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions : undefined$1, "reserved", this.reserved && this.reserved.length ? this.reserved : undefined$1, "group", this.group || undefined$1, "nested", inherited && inherited.nested || undefined$1]);
                };
                /**
                 * @override
                 */


                Type.prototype.resolveAll = function resolveAll() {
                  var fields = this.fieldsArray,
                      i = 0;

                  while (i < fields.length) {
                    fields[i++].resolve();
                  }

                  var oneofs = this.oneofsArray;
                  i = 0;

                  while (i < oneofs.length) {
                    oneofs[i++].resolve();
                  }

                  return Namespace.prototype.resolveAll.call(this);
                };
                /**
                 * @override
                 */


                Type.prototype.get = function get(name) {
                  return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
                };
                /**
                 * Adds a nested object to this type.
                 * @param {ReflectionObject} object Nested object to add
                 * @returns {Type} `this`
                 * @throws {TypeError} If arguments are invalid
                 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
                 */


                Type.prototype.add = function add(object) {
                  if (this.get(object.name)) throw Error("duplicate name '" + object.name + "' in " + this);

                  if (object instanceof Field && object.extend === undefined$1) {
                    // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
                    // The root object takes care of adding distinct sister-fields to the respective extended
                    // type instead.
                    // avoids calling the getter if not absolutely necessary because it's called quite frequently
                    if (this._fieldsById ?
                    /* istanbul ignore next */
                    this._fieldsById[object.id] : this.fieldsById[object.id]) throw Error("duplicate id " + object.id + " in " + this);
                    if (this.isReservedId(object.id)) throw Error("id " + object.id + " is reserved in " + this);
                    if (this.isReservedName(object.name)) throw Error("name '" + object.name + "' is reserved in " + this);
                    if (object.parent) object.parent.remove(object);
                    this.fields[object.name] = object;
                    object.message = this;
                    object.onAdd(this);
                    return clearCache(this);
                  }

                  if (object instanceof OneOf) {
                    if (!this.oneofs) this.oneofs = {};
                    this.oneofs[object.name] = object;
                    object.onAdd(this);
                    return clearCache(this);
                  }

                  return Namespace.prototype.add.call(this, object);
                };
                /**
                 * Removes a nested object from this type.
                 * @param {ReflectionObject} object Nested object to remove
                 * @returns {Type} `this`
                 * @throws {TypeError} If arguments are invalid
                 * @throws {Error} If `object` is not a member of this type
                 */


                Type.prototype.remove = function remove(object) {
                  if (object instanceof Field && object.extend === undefined$1) {
                    // See Type#add for the reason why extension fields are excluded here.

                    /* istanbul ignore if */
                    if (!this.fields || this.fields[object.name] !== object) throw Error(object + " is not a member of " + this);
                    delete this.fields[object.name];
                    object.parent = null;
                    object.onRemove(this);
                    return clearCache(this);
                  }

                  if (object instanceof OneOf) {
                    /* istanbul ignore if */
                    if (!this.oneofs || this.oneofs[object.name] !== object) throw Error(object + " is not a member of " + this);
                    delete this.oneofs[object.name];
                    object.parent = null;
                    object.onRemove(this);
                    return clearCache(this);
                  }

                  return Namespace.prototype.remove.call(this, object);
                };
                /**
                 * Tests if the specified id is reserved.
                 * @param {number} id Id to test
                 * @returns {boolean} `true` if reserved, otherwise `false`
                 */


                Type.prototype.isReservedId = function isReservedId(id) {
                  return Namespace.isReservedId(this.reserved, id);
                };
                /**
                 * Tests if the specified name is reserved.
                 * @param {string} name Name to test
                 * @returns {boolean} `true` if reserved, otherwise `false`
                 */


                Type.prototype.isReservedName = function isReservedName(name) {
                  return Namespace.isReservedName(this.reserved, name);
                };
                /**
                 * Creates a new message of this type using the specified properties.
                 * @param {Object.<string,*>} [properties] Properties to set
                 * @returns {Message<{}>} Message instance
                 */


                Type.prototype.create = function create(properties) {
                  return new this.ctor(properties);
                };
                /**
                 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
                 * @returns {Type} `this`
                 */


                Type.prototype.setup = function setup() {
                  // Sets up everything at once so that the prototype chain does not have to be re-evaluated
                  // multiple times (V8, soft-deopt prototype-check).
                  var fullName = this.fullName,
                      types = [];

                  for (var i = 0; i <
                  /* initializes */
                  this.fieldsArray.length; ++i) {
                    types.push(this._fieldsArray[i].resolve().resolvedType);
                  } // Replace setup methods with type-specific generated functions


                  this.encode = encoder(this)({
                    Writer: Writer,
                    types: types,
                    util: util
                  });
                  this.decode = decoder(this)({
                    Reader: Reader,
                    types: types,
                    util: util
                  });
                  this.verify = verifier(this)({
                    types: types,
                    util: util
                  });
                  this.fromObject = converter.fromObject(this)({
                    types: types,
                    util: util
                  });
                  this.toObject = converter.toObject(this)({
                    types: types,
                    util: util
                  }); // Inject custom wrappers for common types

                  var wrapper = wrappers[fullName];

                  if (wrapper) {
                    var originalThis = Object.create(this); // if (wrapper.fromObject) {

                    originalThis.fromObject = this.fromObject;
                    this.fromObject = wrapper.fromObject.bind(originalThis); // }
                    // if (wrapper.toObject) {

                    originalThis.toObject = this.toObject;
                    this.toObject = wrapper.toObject.bind(originalThis); // }
                  }

                  return this;
                };
                /**
                 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
                 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
                 * @param {Writer} [writer] Writer to encode to
                 * @returns {Writer} writer
                 */


                Type.prototype.encode = function encode_setup(message, writer) {
                  return this.setup().encode(message, writer); // overrides this method
                };
                /**
                 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
                 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
                 * @param {Writer} [writer] Writer to encode to
                 * @returns {Writer} writer
                 */


                Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
                };
                /**
                 * Decodes a message of this type.
                 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Length of the message, if known beforehand
                 * @returns {Message<{}>} Decoded message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {util.ProtocolError<{}>} If required fields are missing
                 */


                Type.prototype.decode = function decode_setup(reader, length) {
                  return this.setup().decode(reader, length); // overrides this method
                };
                /**
                 * Decodes a message of this type preceeded by its byte length as a varint.
                 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Message<{}>} Decoded message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {util.ProtocolError} If required fields are missing
                 */


                Type.prototype.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof Reader)) reader = Reader.create(reader);
                  return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies that field values are valid and that required fields are present.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {null|string} `null` if valid, otherwise the reason why it is not
                 */


                Type.prototype.verify = function verify_setup(message) {
                  return this.setup().verify(message); // overrides this method
                };
                /**
                 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object to convert
                 * @returns {Message<{}>} Message instance
                 */


                Type.prototype.fromObject = function fromObject(object) {
                  return this.setup().fromObject(object);
                };
                /**
                 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
                 * @interface IConversionOptions
                 * @property {Function} [longs] Long conversion type.
                 * Valid values are `String` and `Number` (the global types).
                 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
                 * @property {Function} [enums] Enum value conversion type.
                 * Only valid value is `String` (the global type).
                 * Defaults to copy the present value, which is the numeric id.
                 * @property {Function} [bytes] Bytes value conversion type.
                 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
                 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
                 * @property {boolean} [defaults=false] Also sets default values on the resulting object
                 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
                 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
                 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
                 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
                 */

                /**
                 * Creates a plain object from a message of this type. Also converts values to other types if specified.
                 * @param {Message<{}>} message Message instance
                 * @param {IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */


                Type.prototype.toObject = function toObject(message, options) {
                  return this.setup().toObject(message, options);
                };
                /**
                 * Decorator function as returned by {@link Type.d} (TypeScript).
                 * @typedef TypeDecorator
                 * @type {function}
                 * @param {Constructor<T>} target Target constructor
                 * @returns {undefined}
                 * @template T extends Message<T>
                 */

                /**
                 * Type decorator (TypeScript).
                 * @param {string} [typeName] Type name, defaults to the constructor's name
                 * @returns {TypeDecorator<T>} Decorator function
                 * @template T extends Message<T>
                 */


                Type.d = function decorateType(typeName) {
                  return function typeDecorator(target) {
                    util.decorateType(target, typeName);
                  };
                };
              }, {
                "12": 12,
                "13": 13,
                "14": 14,
                "15": 15,
                "16": 16,
                "20": 20,
                "21": 21,
                "23": 23,
                "25": 25,
                "27": 27,
                "33": 33,
                "37": 37,
                "40": 40,
                "41": 41,
                "42": 42
              }],
              36: [function (require, module, exports) {
                /**
                 * Common type constants.
                 * @namespace
                 */
                var types = exports;

                var util = require(37);

                var s = ["double", // 0
                "float", // 1
                "int32", // 2
                "uint32", // 3
                "sint32", // 4
                "fixed32", // 5
                "sfixed32", // 6
                "int64", // 7
                "uint64", // 8
                "sint64", // 9
                "fixed64", // 10
                "sfixed64", // 11
                "bool", // 12
                "string", // 13
                "bytes" // 14
                ];

                function bake(values, offset) {
                  var i = 0,
                      o = {};
                  offset |= 0;

                  while (i < values.length) {
                    o[s[i + offset]] = values[i++];
                  }

                  return o;
                }
                /**
                 * Basic type wire types.
                 * @type {Object.<string,number>}
                 * @const
                 * @property {number} double=1 Fixed64 wire type
                 * @property {number} float=5 Fixed32 wire type
                 * @property {number} int32=0 Varint wire type
                 * @property {number} uint32=0 Varint wire type
                 * @property {number} sint32=0 Varint wire type
                 * @property {number} fixed32=5 Fixed32 wire type
                 * @property {number} sfixed32=5 Fixed32 wire type
                 * @property {number} int64=0 Varint wire type
                 * @property {number} uint64=0 Varint wire type
                 * @property {number} sint64=0 Varint wire type
                 * @property {number} fixed64=1 Fixed64 wire type
                 * @property {number} sfixed64=1 Fixed64 wire type
                 * @property {number} bool=0 Varint wire type
                 * @property {number} string=2 Ldelim wire type
                 * @property {number} bytes=2 Ldelim wire type
                 */


                types.basic = bake([
                /* double   */
                1,
                /* float    */
                5,
                /* int32    */
                0,
                /* uint32   */
                0,
                /* sint32   */
                0,
                /* fixed32  */
                5,
                /* sfixed32 */
                5,
                /* int64    */
                0,
                /* uint64   */
                0,
                /* sint64   */
                0,
                /* fixed64  */
                1,
                /* sfixed64 */
                1,
                /* bool     */
                0,
                /* string   */
                2,
                /* bytes    */
                2]);
                /**
                 * Basic type defaults.
                 * @type {Object.<string,*>}
                 * @const
                 * @property {number} double=0 Double default
                 * @property {number} float=0 Float default
                 * @property {number} int32=0 Int32 default
                 * @property {number} uint32=0 Uint32 default
                 * @property {number} sint32=0 Sint32 default
                 * @property {number} fixed32=0 Fixed32 default
                 * @property {number} sfixed32=0 Sfixed32 default
                 * @property {number} int64=0 Int64 default
                 * @property {number} uint64=0 Uint64 default
                 * @property {number} sint64=0 Sint32 default
                 * @property {number} fixed64=0 Fixed64 default
                 * @property {number} sfixed64=0 Sfixed64 default
                 * @property {boolean} bool=false Bool default
                 * @property {string} string="" String default
                 * @property {Array.<number>} bytes=Array(0) Bytes default
                 * @property {null} message=null Message default
                 */

                types.defaults = bake([
                /* double   */
                0,
                /* float    */
                0,
                /* int32    */
                0,
                /* uint32   */
                0,
                /* sint32   */
                0,
                /* fixed32  */
                0,
                /* sfixed32 */
                0,
                /* int64    */
                0,
                /* uint64   */
                0,
                /* sint64   */
                0,
                /* fixed64  */
                0,
                /* sfixed64 */
                0,
                /* bool     */
                false,
                /* string   */
                "",
                /* bytes    */
                util.emptyArray,
                /* message  */
                null]);
                /**
                 * Basic long type wire types.
                 * @type {Object.<string,number>}
                 * @const
                 * @property {number} int64=0 Varint wire type
                 * @property {number} uint64=0 Varint wire type
                 * @property {number} sint64=0 Varint wire type
                 * @property {number} fixed64=1 Fixed64 wire type
                 * @property {number} sfixed64=1 Fixed64 wire type
                 */

                types["long"] = bake([
                /* int64    */
                0,
                /* uint64   */
                0,
                /* sint64   */
                0,
                /* fixed64  */
                1,
                /* sfixed64 */
                1], 7);
                /**
                 * Allowed types for map keys with their associated wire type.
                 * @type {Object.<string,number>}
                 * @const
                 * @property {number} int32=0 Varint wire type
                 * @property {number} uint32=0 Varint wire type
                 * @property {number} sint32=0 Varint wire type
                 * @property {number} fixed32=5 Fixed32 wire type
                 * @property {number} sfixed32=5 Fixed32 wire type
                 * @property {number} int64=0 Varint wire type
                 * @property {number} uint64=0 Varint wire type
                 * @property {number} sint64=0 Varint wire type
                 * @property {number} fixed64=1 Fixed64 wire type
                 * @property {number} sfixed64=1 Fixed64 wire type
                 * @property {number} bool=0 Varint wire type
                 * @property {number} string=2 Ldelim wire type
                 */

                types.mapKey = bake([
                /* int32    */
                0,
                /* uint32   */
                0,
                /* sint32   */
                0,
                /* fixed32  */
                5,
                /* sfixed32 */
                5,
                /* int64    */
                0,
                /* uint64   */
                0,
                /* sint64   */
                0,
                /* fixed64  */
                1,
                /* sfixed64 */
                1,
                /* bool     */
                0,
                /* string   */
                2], 2);
                /**
                 * Allowed types for packed repeated fields with their associated wire type.
                 * @type {Object.<string,number>}
                 * @const
                 * @property {number} double=1 Fixed64 wire type
                 * @property {number} float=5 Fixed32 wire type
                 * @property {number} int32=0 Varint wire type
                 * @property {number} uint32=0 Varint wire type
                 * @property {number} sint32=0 Varint wire type
                 * @property {number} fixed32=5 Fixed32 wire type
                 * @property {number} sfixed32=5 Fixed32 wire type
                 * @property {number} int64=0 Varint wire type
                 * @property {number} uint64=0 Varint wire type
                 * @property {number} sint64=0 Varint wire type
                 * @property {number} fixed64=1 Fixed64 wire type
                 * @property {number} sfixed64=1 Fixed64 wire type
                 * @property {number} bool=0 Varint wire type
                 */

                types.packed = bake([
                /* double   */
                1,
                /* float    */
                5,
                /* int32    */
                0,
                /* uint32   */
                0,
                /* sint32   */
                0,
                /* fixed32  */
                5,
                /* sfixed32 */
                5,
                /* int64    */
                0,
                /* uint64   */
                0,
                /* sint64   */
                0,
                /* fixed64  */
                1,
                /* sfixed64 */
                1,
                /* bool     */
                0]);
              }, {
                "37": 37
              }],
              37: [function (require, module, exports) {
                /**
                 * Various utility functions.
                 * @namespace
                 */
                var util = module.exports = require(39);

                var roots = require(30);

                var Type, // cyclic
                Enum;
                util.codegen = require(3);
                util.fetch = require(5);
                util.path = require(8);
                /**
                 * Node's fs module if available.
                 * @type {Object.<string,*>}
                 */

                util.fs = util.inquire("fs");
                /**
                 * Converts an object's values to an array.
                 * @param {Object.<string,*>} object Object to convert
                 * @returns {Array.<*>} Converted array
                 */

                util.toArray = function toArray(object) {
                  if (object) {
                    var keys = Object.keys(object),
                        array = new Array(keys.length),
                        index = 0;

                    while (index < keys.length) {
                      array[index] = object[keys[index++]];
                    }

                    return array;
                  }

                  return [];
                };
                /**
                 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
                 * @param {Array.<*>} array Array to convert
                 * @returns {Object.<string,*>} Converted object
                 */


                util.toObject = function toObject(array) {
                  var object = {},
                      index = 0;

                  while (index < array.length) {
                    var key = array[index++],
                        val = array[index++];
                    if (val !== undefined$1) object[key] = val;
                  }

                  return object;
                };

                var safePropBackslashRe = /\\/g,
                    safePropQuoteRe = /"/g;
                /**
                 * Tests whether the specified name is a reserved word in JS.
                 * @param {string} name Name to test
                 * @returns {boolean} `true` if reserved, otherwise `false`
                 */

                util.isReserved = function isReserved(name) {
                  return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
                };
                /**
                 * Returns a safe property accessor for the specified property name.
                 * @param {string} prop Property name
                 * @returns {string} Safe accessor
                 */


                util.safeProp = function safeProp(prop) {
                  if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop)) return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
                  return "." + prop;
                };
                /**
                 * Converts the first character of a string to upper case.
                 * @param {string} str String to convert
                 * @returns {string} Converted string
                 */


                util.ucFirst = function ucFirst(str) {
                  return str.charAt(0).toUpperCase() + str.substring(1);
                };

                var camelCaseRe = /_([a-z])/g;
                /**
                 * Converts a string to camel case.
                 * @param {string} str String to convert
                 * @returns {string} Converted string
                 */

                util.camelCase = function camelCase(str) {
                  return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function ($0, $1) {
                    return $1.toUpperCase();
                  });
                };
                /**
                 * Compares reflected fields by id.
                 * @param {Field} a First field
                 * @param {Field} b Second field
                 * @returns {number} Comparison value
                 */


                util.compareFieldsById = function compareFieldsById(a, b) {
                  return a.id - b.id;
                };
                /**
                 * Decorator helper for types (TypeScript).
                 * @param {Constructor<T>} ctor Constructor function
                 * @param {string} [typeName] Type name, defaults to the constructor's name
                 * @returns {Type} Reflected type
                 * @template T extends Message<T>
                 * @property {Root} root Decorators root
                 */


                util.decorateType = function decorateType(ctor, typeName) {
                  /* istanbul ignore if */
                  if (ctor.$type) {
                    if (typeName && ctor.$type.name !== typeName) {
                      util.decorateRoot.remove(ctor.$type);
                      ctor.$type.name = typeName;
                      util.decorateRoot.add(ctor.$type);
                    }

                    return ctor.$type;
                  }
                  /* istanbul ignore next */


                  if (!Type) Type = require(35);
                  var type = new Type(typeName || ctor.name);
                  util.decorateRoot.add(type);
                  type.ctor = ctor; // sets up .encode, .decode etc.

                  Object.defineProperty(ctor, "$type", {
                    value: type,
                    enumerable: false
                  });
                  Object.defineProperty(ctor.prototype, "$type", {
                    value: type,
                    enumerable: false
                  });
                  return type;
                };

                var decorateEnumIndex = 0;
                /**
                 * Decorator helper for enums (TypeScript).
                 * @param {Object} object Enum object
                 * @returns {Enum} Reflected enum
                 */

                util.decorateEnum = function decorateEnum(object) {
                  /* istanbul ignore if */
                  if (object.$type) return object.$type;
                  /* istanbul ignore next */

                  if (!Enum) Enum = require(15);
                  var enm = new Enum("Enum" + decorateEnumIndex++, object);
                  util.decorateRoot.add(enm);
                  Object.defineProperty(object, "$type", {
                    value: enm,
                    enumerable: false
                  });
                  return enm;
                };
                /**
                 * Decorator root (TypeScript).
                 * @name util.decorateRoot
                 * @type {Root}
                 * @readonly
                 */


                Object.defineProperty(util, "decorateRoot", {
                  get: function get() {
                    return roots["decorated"] || (roots["decorated"] = new (require(29))());
                  }
                });
              }, {
                "15": 15,
                "29": 29,
                "3": 3,
                "30": 30,
                "35": 35,
                "39": 39,
                "5": 5,
                "8": 8
              }],
              38: [function (require, module, exports) {
                module.exports = LongBits;

                var util = require(39);
                /**
                 * Constructs new long bits.
                 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
                 * @memberof util
                 * @constructor
                 * @param {number} lo Low 32 bits, unsigned
                 * @param {number} hi High 32 bits, unsigned
                 */


                function LongBits(lo, hi) {
                  // note that the casts below are theoretically unnecessary as of today, but older statically
                  // generated converter code might still call the ctor with signed 32bits. kept for compat.

                  /**
                   * Low bits.
                   * @type {number}
                   */
                  this.lo = lo >>> 0;
                  /**
                   * High bits.
                   * @type {number}
                   */

                  this.hi = hi >>> 0;
                }
                /**
                 * Zero bits.
                 * @memberof util.LongBits
                 * @type {util.LongBits}
                 */


                var zero = LongBits.zero = new LongBits(0, 0);

                zero.toNumber = function () {
                  return 0;
                };

                zero.zzEncode = zero.zzDecode = function () {
                  return this;
                };

                zero.length = function () {
                  return 1;
                };
                /**
                 * Zero hash.
                 * @memberof util.LongBits
                 * @type {string}
                 */


                var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
                /**
                 * Constructs new long bits from the specified number.
                 * @param {number} value Value
                 * @returns {util.LongBits} Instance
                 */

                LongBits.fromNumber = function fromNumber(value) {
                  if (value === 0) return zero;
                  var sign = value < 0;
                  if (sign) value = -value;
                  var lo = value >>> 0,
                      hi = (value - lo) / 4294967296 >>> 0;

                  if (sign) {
                    hi = ~hi >>> 0;
                    lo = ~lo >>> 0;

                    if (++lo > 4294967295) {
                      lo = 0;
                      if (++hi > 4294967295) hi = 0;
                    }
                  }

                  return new LongBits(lo, hi);
                };
                /**
                 * Constructs new long bits from a number, long or string.
                 * @param {Long|number|string} value Value
                 * @returns {util.LongBits} Instance
                 */


                LongBits.from = function from(value) {
                  if (typeof value === "number") return LongBits.fromNumber(value);

                  if (util.isString(value)) {
                    /* istanbul ignore else */
                    if (util.Long) value = util.Long.fromString(value);else return LongBits.fromNumber(parseInt(value, 10));
                  }

                  return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
                };
                /**
                 * Converts this long bits to a possibly unsafe JavaScript number.
                 * @param {boolean} [unsigned=false] Whether unsigned or not
                 * @returns {number} Possibly unsafe number
                 */


                LongBits.prototype.toNumber = function toNumber(unsigned) {
                  if (!unsigned && this.hi >>> 31) {
                    var lo = ~this.lo + 1 >>> 0,
                        hi = ~this.hi >>> 0;
                    if (!lo) hi = hi + 1 >>> 0;
                    return -(lo + hi * 4294967296);
                  }

                  return this.lo + this.hi * 4294967296;
                };
                /**
                 * Converts this long bits to a long.
                 * @param {boolean} [unsigned=false] Whether unsigned or not
                 * @returns {Long} Long
                 */


                LongBits.prototype.toLong = function toLong(unsigned) {
                  return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
                  /* istanbul ignore next */
                  : {
                    low: this.lo | 0,
                    high: this.hi | 0,
                    unsigned: Boolean(unsigned)
                  };
                };

                var charCodeAt = String.prototype.charCodeAt;
                /**
                 * Constructs new long bits from the specified 8 characters long hash.
                 * @param {string} hash Hash
                 * @returns {util.LongBits} Bits
                 */

                LongBits.fromHash = function fromHash(hash) {
                  if (hash === zeroHash) return zero;
                  return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
                };
                /**
                 * Converts this long bits to a 8 characters long hash.
                 * @returns {string} Hash
                 */


                LongBits.prototype.toHash = function toHash() {
                  return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
                };
                /**
                 * Zig-zag encodes this long bits.
                 * @returns {util.LongBits} `this`
                 */


                LongBits.prototype.zzEncode = function zzEncode() {
                  var mask = this.hi >> 31;
                  this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
                  this.lo = (this.lo << 1 ^ mask) >>> 0;
                  return this;
                };
                /**
                 * Zig-zag decodes this long bits.
                 * @returns {util.LongBits} `this`
                 */


                LongBits.prototype.zzDecode = function zzDecode() {
                  var mask = -(this.lo & 1);
                  this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
                  this.hi = (this.hi >>> 1 ^ mask) >>> 0;
                  return this;
                };
                /**
                 * Calculates the length of this longbits when encoded as a varint.
                 * @returns {number} Length
                 */


                LongBits.prototype.length = function length() {
                  var part0 = this.lo,
                      part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
                      part2 = this.hi >>> 24;
                  return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
                };
              }, {
                "39": 39
              }],
              39: [function (require, module, exports) {
                var util = exports; // used to return a Promise where callback is omitted

                util.asPromise = require(1); // converts to / from base64 encoded strings

                util.base64 = require(2); // base class of rpc.Service

                util.EventEmitter = require(4); // float handling accross browsers

                util["float"] = require(6); // requires modules optionally and hides the call from bundlers

                util.inquire = require(7); // converts to / from utf8 encoded strings

                util.utf8 = require(10); // provides a node-like buffer pool in the browser

                util.pool = require(9); // utility to work with the low and high bits of a 64 bit value

                util.LongBits = require(38);
                /**
                 * An immuable empty array.
                 * @memberof util
                 * @type {Array.<*>}
                 * @const
                 */

                util.emptyArray = Object.freeze ? Object.freeze([]) :
                /* istanbul ignore next */
                []; // used on prototypes

                /**
                 * An immutable empty object.
                 * @type {Object}
                 * @const
                 */

                util.emptyObject = Object.freeze ? Object.freeze({}) :
                /* istanbul ignore next */
                {}; // used on prototypes

                /**
                 * Whether running within node or not.
                 * @memberof util
                 * @type {boolean}
                 * @const
                 */

                util.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);
                /**
                 * Tests if the specified value is an integer.
                 * @function
                 * @param {*} value Value to test
                 * @returns {boolean} `true` if the value is an integer
                 */

                util.isInteger = Number.isInteger ||
                /* istanbul ignore next */
                function isInteger(value) {
                  return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
                };
                /**
                 * Tests if the specified value is a string.
                 * @param {*} value Value to test
                 * @returns {boolean} `true` if the value is a string
                 */


                util.isString = function isString(value) {
                  return typeof value === "string" || value instanceof String;
                };
                /**
                 * Tests if the specified value is a non-null object.
                 * @param {*} value Value to test
                 * @returns {boolean} `true` if the value is a non-null object
                 */


                util.isObject = function isObject(value) {
                  return value && typeof value === "object";
                };
                /**
                 * Checks if a property on a message is considered to be present.
                 * This is an alias of {@link util.isSet}.
                 * @function
                 * @param {Object} obj Plain object or message instance
                 * @param {string} prop Property name
                 * @returns {boolean} `true` if considered to be present, otherwise `false`
                 */


                util.isset =
                /**
                 * Checks if a property on a message is considered to be present.
                 * @param {Object} obj Plain object or message instance
                 * @param {string} prop Property name
                 * @returns {boolean} `true` if considered to be present, otherwise `false`
                 */
                util.isSet = function isSet(obj, prop) {
                  var value = obj[prop];
                  if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
                    return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
                  return false;
                };
                /**
                 * Any compatible Buffer instance.
                 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
                 * @interface Buffer
                 * @extends Uint8Array
                 */

                /**
                 * Node's Buffer class if available.
                 * @type {Constructor<Buffer>}
                 */


                util.Buffer = function () {
                  try {
                    var Buffer = util.inquire("buffer").Buffer; // refuse to use non-node buffers if not explicitly assigned (perf reasons):

                    return Buffer.prototype.utf8Write ? Buffer :
                    /* istanbul ignore next */
                    null;
                  } catch (e) {
                    /* istanbul ignore next */
                    return null;
                  }
                }(); // Internal alias of or polyfull for Buffer.from.


                util._Buffer_from = null; // Internal alias of or polyfill for Buffer.allocUnsafe.

                util._Buffer_allocUnsafe = null;
                /**
                 * Creates a new buffer of whatever type supported by the environment.
                 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
                 * @returns {Uint8Array|Buffer} Buffer
                 */

                util.newBuffer = function newBuffer(sizeOrArray) {
                  /* istanbul ignore next */
                  return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
                };
                /**
                 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
                 * @type {Constructor<Uint8Array>}
                 */


                util.Array = typeof Uint8Array !== "undefined" ? Uint8Array
                /* istanbul ignore next */
                : Array;
                /**
                 * Any compatible Long instance.
                 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
                 * @interface Long
                 * @property {number} low Low bits
                 * @property {number} high High bits
                 * @property {boolean} unsigned Whether unsigned or not
                 */

                /**
                 * Long.js's Long class if available.
                 * @type {Constructor<Long>}
                 */

                util.Long =
                /* istanbul ignore next */
                global.dcodeIO &&
                /* istanbul ignore next */
                global.dcodeIO.Long || util.inquire("long");
                /**
                 * Regular expression used to verify 2 bit (`bool`) map keys.
                 * @type {RegExp}
                 * @const
                 */

                util.key2Re = /^true|false|0|1$/;
                /**
                 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
                 * @type {RegExp}
                 * @const
                 */

                util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
                /**
                 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
                 * @type {RegExp}
                 * @const
                 */

                util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
                /**
                 * Converts a number or long to an 8 characters long hash string.
                 * @param {Long|number} value Value to convert
                 * @returns {string} Hash
                 */

                util.longToHash = function longToHash(value) {
                  return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
                };
                /**
                 * Converts an 8 characters long hash string to a long or number.
                 * @param {string} hash Hash
                 * @param {boolean} [unsigned=false] Whether unsigned or not
                 * @returns {Long|number} Original value
                 */


                util.longFromHash = function longFromHash(hash, unsigned) {
                  var bits = util.LongBits.fromHash(hash);
                  if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);
                  return bits.toNumber(Boolean(unsigned));
                };
                /**
                 * Merges the properties of the source object into the destination object.
                 * @memberof util
                 * @param {Object.<string,*>} dst Destination object
                 * @param {Object.<string,*>} src Source object
                 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
                 * @returns {Object.<string,*>} Destination object
                 */


                function merge(dst, src, ifNotSet) {
                  // used by converters
                  for (var keys = Object.keys(src), i = 0; i < keys.length; ++i) {
                    if (dst[keys[i]] === undefined$1 || !ifNotSet) dst[keys[i]] = src[keys[i]];
                  }

                  return dst;
                }

                util.merge = merge;
                /**
                 * Converts the first character of a string to lower case.
                 * @param {string} str String to convert
                 * @returns {string} Converted string
                 */

                util.lcFirst = function lcFirst(str) {
                  return str.charAt(0).toLowerCase() + str.substring(1);
                };
                /**
                 * Creates a custom error constructor.
                 * @memberof util
                 * @param {string} name Error name
                 * @returns {Constructor<Error>} Custom error constructor
                 */


                function newError(name) {
                  function CustomError(message, properties) {
                    if (!(this instanceof CustomError)) return new CustomError(message, properties); // Error.call(this, message);
                    // ^ just returns a new error instance because the ctor can be called as a function

                    Object.defineProperty(this, "message", {
                      get: function get() {
                        return message;
                      }
                    });
                    /* istanbul ignore next */

                    if (Error.captureStackTrace) // node
                      Error.captureStackTrace(this, CustomError);else Object.defineProperty(this, "stack", {
                      value: new Error().stack || ""
                    });
                    if (properties) merge(this, properties);
                  }

                  (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
                  Object.defineProperty(CustomError.prototype, "name", {
                    get: function get() {
                      return name;
                    }
                  });

                  CustomError.prototype.toString = function toString() {
                    return this.name + ": " + this.message;
                  };

                  return CustomError;
                }

                util.newError = newError;
                /**
                 * Constructs a new protocol error.
                 * @classdesc Error subclass indicating a protocol specifc error.
                 * @memberof util
                 * @extends Error
                 * @template T extends Message<T>
                 * @constructor
                 * @param {string} message Error message
                 * @param {Object.<string,*>} [properties] Additional properties
                 * @example
                 * try {
                 *     MyMessage.decode(someBuffer); // throws if required fields are missing
                 * } catch (e) {
                 *     if (e instanceof ProtocolError && e.instance)
                 *         console.log("decoded so far: " + JSON.stringify(e.instance));
                 * }
                 */

                util.ProtocolError = newError("ProtocolError");
                /**
                 * So far decoded message instance.
                 * @name util.ProtocolError#instance
                 * @type {Message<T>}
                 */

                /**
                 * A OneOf getter as returned by {@link util.oneOfGetter}.
                 * @typedef OneOfGetter
                 * @type {function}
                 * @returns {string|undefined} Set field name, if any
                 */

                /**
                 * Builds a getter for a oneof's present field name.
                 * @param {string[]} fieldNames Field names
                 * @returns {OneOfGetter} Unbound getter
                 */

                util.oneOfGetter = function getOneOf(fieldNames) {
                  var fieldMap = {};

                  for (var i = 0; i < fieldNames.length; ++i) {
                    fieldMap[fieldNames[i]] = 1;
                  }
                  /**
                   * @returns {string|undefined} Set field name, if any
                   * @this Object
                   * @ignore
                   */


                  return function () {
                    // eslint-disable-line consistent-return
                    for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i) {
                      if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined$1 && this[keys[i]] !== null) return keys[i];
                    }
                  };
                };
                /**
                 * A OneOf setter as returned by {@link util.oneOfSetter}.
                 * @typedef OneOfSetter
                 * @type {function}
                 * @param {string|undefined} value Field name
                 * @returns {undefined}
                 */

                /**
                 * Builds a setter for a oneof's present field name.
                 * @param {string[]} fieldNames Field names
                 * @returns {OneOfSetter} Unbound setter
                 */


                util.oneOfSetter = function setOneOf(fieldNames) {
                  /**
                   * @param {string} name Field name
                   * @returns {undefined}
                   * @this Object
                   * @ignore
                   */
                  return function (name) {
                    for (var i = 0; i < fieldNames.length; ++i) {
                      if (fieldNames[i] !== name) delete this[fieldNames[i]];
                    }
                  };
                };
                /**
                 * Default conversion options used for {@link Message#toJSON} implementations.
                 *
                 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
                 *
                 * - Longs become strings
                 * - Enums become string keys
                 * - Bytes become base64 encoded strings
                 * - (Sub-)Messages become plain objects
                 * - Maps become plain objects with all string keys
                 * - Repeated fields become arrays
                 * - NaN and Infinity for float and double fields become strings
                 *
                 * @type {IConversionOptions}
                 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
                 */


                util.toJSONOptions = {
                  longs: String,
                  enums: String,
                  bytes: String,
                  json: true
                };

                util._configure = function () {
                  var Buffer = util.Buffer;
                  /* istanbul ignore if */

                  if (!Buffer) {
                    util._Buffer_from = util._Buffer_allocUnsafe = null;
                    return;
                  } // because node 4.x buffers are incompatible & immutable
                  // see: https://github.com/dcodeIO/protobuf.js/pull/665


                  util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
                  /* istanbul ignore next */
                  function Buffer_from(value, encoding) {
                    return new Buffer(value, encoding);
                  };

                  util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
                  /* istanbul ignore next */
                  function Buffer_allocUnsafe(size) {
                    return new Buffer(size);
                  };
                };
              }, {
                "1": 1,
                "10": 10,
                "2": 2,
                "38": 38,
                "4": 4,
                "6": 6,
                "7": 7,
                "9": 9
              }],
              40: [function (require, module, exports) {
                module.exports = verifier;

                var Enum = require(15),
                    util = require(37);

                function invalid(field, expected) {
                  return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
                }
                /**
                 * Generates a partial value verifier.
                 * @param {Codegen} gen Codegen instance
                 * @param {Field} field Reflected field
                 * @param {number} fieldIndex Field index
                 * @param {string} ref Variable reference
                 * @returns {Codegen} Codegen instance
                 * @ignore
                 */


                function genVerifyValue(gen, field, fieldIndex, ref) {
                  /* eslint-disable no-unexpected-multiline */
                  if (field.resolvedType) {
                    if (field.resolvedType instanceof Enum) {
                      gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));

                      for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) {
                        gen("case %i:", field.resolvedType.values[keys[j]]);
                      }

                      gen("break")("}");
                    } else {
                      gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
                    }
                  } else {
                    switch (field.type) {
                      case "int32":
                      case "uint32":
                      case "sint32":
                      case "fixed32":
                      case "sfixed32":
                        gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
                        break;

                      case "int64":
                      case "uint64":
                      case "sint64":
                      case "fixed64":
                      case "sfixed64":
                        gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
                        break;

                      case "float":
                      case "double":
                        gen("if(typeof %s!==\"number\")", ref)("return%j", invalid(field, "number"));
                        break;

                      case "bool":
                        gen("if(typeof %s!==\"boolean\")", ref)("return%j", invalid(field, "boolean"));
                        break;

                      case "string":
                        gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
                        break;

                      case "bytes":
                        gen("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)("return%j", invalid(field, "buffer"));
                        break;
                    }
                  }

                  return gen;
                  /* eslint-enable no-unexpected-multiline */
                }
                /**
                 * Generates a partial key verifier.
                 * @param {Codegen} gen Codegen instance
                 * @param {Field} field Reflected field
                 * @param {string} ref Variable reference
                 * @returns {Codegen} Codegen instance
                 * @ignore
                 */


                function genVerifyKey(gen, field, ref) {
                  /* eslint-disable no-unexpected-multiline */
                  switch (field.keyType) {
                    case "int32":
                    case "uint32":
                    case "sint32":
                    case "fixed32":
                    case "sfixed32":
                      gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
                      break;

                    case "int64":
                    case "uint64":
                    case "sint64":
                    case "fixed64":
                    case "sfixed64":
                      gen("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                      ("return%j", invalid(field, "integer|Long key"));
                      break;

                    case "bool":
                      gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
                      break;
                  }

                  return gen;
                  /* eslint-enable no-unexpected-multiline */
                }
                /**
                 * Generates a verifier specific to the specified message type.
                 * @param {Type} mtype Message type
                 * @returns {Codegen} Codegen instance
                 */


                function verifier(mtype) {
                  /* eslint-disable no-unexpected-multiline */
                  var gen = util.codegen(["m"], mtype.name + "$verify")("if(typeof m!==\"object\"||m===null)")("return%j", "object expected");
                  var oneofs = mtype.oneofsArray,
                      seenFirstField = {};
                  if (oneofs.length) gen("var p={}");

                  for (var i = 0; i <
                  /* initializes */
                  mtype.fieldsArray.length; ++i) {
                    var field = mtype._fieldsArray[i].resolve(),
                        ref = "m" + util.safeProp(field.name);

                    if (field.optional) gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null
                    // map fields

                    if (field.map) {
                      gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
                      genVerifyKey(gen, field, "k[i]");
                      genVerifyValue(gen, field, i, ref + "[k[i]]")("}"); // repeated fields
                    } else if (field.repeated) {
                      gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
                      genVerifyValue(gen, field, i, ref + "[i]")("}"); // required or present fields
                    } else {
                      if (field.partOf) {
                        var oneofProp = util.safeProp(field.partOf.name);
                        if (seenFirstField[field.partOf.name] === 1) gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
                        seenFirstField[field.partOf.name] = 1;
                        gen("p%s=1", oneofProp);
                      }

                      genVerifyValue(gen, field, i, ref);
                    }

                    if (field.optional) gen("}");
                  }

                  return gen("return null");
                  /* eslint-enable no-unexpected-multiline */
                }
              }, {
                "15": 15,
                "37": 37
              }],
              41: [function (require, module, exports) {
                /**
                 * Wrappers for common types.
                 * @type {Object.<string,IWrapper>}
                 * @const
                 */
                var wrappers = exports;

                var Message = require(21);
                /**
                 * From object converter part of an {@link IWrapper}.
                 * @typedef WrapperFromObjectConverter
                 * @type {function}
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Message<{}>} Message instance
                 * @this Type
                 */

                /**
                 * To object converter part of an {@link IWrapper}.
                 * @typedef WrapperToObjectConverter
                 * @type {function}
                 * @param {Message<{}>} message Message instance
                 * @param {IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 * @this Type
                 */

                /**
                 * Common type wrapper part of {@link wrappers}.
                 * @interface IWrapper
                 * @property {WrapperFromObjectConverter} [fromObject] From object converter
                 * @property {WrapperToObjectConverter} [toObject] To object converter
                 */
                // Custom wrapper for Any


                wrappers[".google.protobuf.Any"] = {
                  fromObject: function fromObject(object) {
                    // unwrap value type if mapped
                    if (object && object["@type"]) {
                      var type = this.lookup(object["@type"]);
                      /* istanbul ignore else */

                      if (type) {
                        // type_url does not accept leading "."
                        var type_url = object["@type"].charAt(0) === "." ? object["@type"].substr(1) : object["@type"]; // type_url prefix is optional, but path seperator is required

                        return this.create({
                          type_url: "/" + type_url,
                          value: type.encode(type.fromObject(object)).finish()
                        });
                      }
                    }

                    return this.fromObject(object);
                  },
                  toObject: function toObject(message, options) {
                    // decode value if requested and unmapped
                    if (options && options.json && message.type_url && message.value) {
                      // Only use fully qualified type name after the last '/'
                      var name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
                      var type = this.lookup(name);
                      /* istanbul ignore else */

                      if (type) message = type.decode(message.value);
                    } // wrap value if unmapped


                    if (!(message instanceof this.ctor) && message instanceof Message) {
                      var object = message.$type.toObject(message, options);
                      object["@type"] = message.$type.fullName;
                      return object;
                    }

                    return this.toObject(message, options);
                  }
                };
              }, {
                "21": 21
              }],
              42: [function (require, module, exports) {
                module.exports = Writer;

                var util = require(39);

                var BufferWriter; // cyclic

                var LongBits = util.LongBits,
                    base64 = util.base64,
                    utf8 = util.utf8;
                /**
                 * Constructs a new writer operation instance.
                 * @classdesc Scheduled writer operation.
                 * @constructor
                 * @param {function(*, Uint8Array, number)} fn Function to call
                 * @param {number} len Value byte length
                 * @param {*} val Value to write
                 * @ignore
                 */

                function Op(fn, len, val) {
                  /**
                   * Function to call.
                   * @type {function(Uint8Array, number, *)}
                   */
                  this.fn = fn;
                  /**
                   * Value byte length.
                   * @type {number}
                   */

                  this.len = len;
                  /**
                   * Next operation.
                   * @type {Writer.Op|undefined}
                   */

                  this.next = undefined$1;
                  /**
                   * Value to write.
                   * @type {*}
                   */

                  this.val = val; // type varies
                }
                /* istanbul ignore next */


                function noop() {} // eslint-disable-line no-empty-function

                /**
                 * Constructs a new writer state instance.
                 * @classdesc Copied writer state.
                 * @memberof Writer
                 * @constructor
                 * @param {Writer} writer Writer to copy state from
                 * @ignore
                 */


                function State(writer) {
                  /**
                   * Current head.
                   * @type {Writer.Op}
                   */
                  this.head = writer.head;
                  /**
                   * Current tail.
                   * @type {Writer.Op}
                   */

                  this.tail = writer.tail;
                  /**
                   * Current buffer length.
                   * @type {number}
                   */

                  this.len = writer.len;
                  /**
                   * Next state.
                   * @type {State|null}
                   */

                  this.next = writer.states;
                }
                /**
                 * Constructs a new writer instance.
                 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
                 * @constructor
                 */


                function Writer() {
                  /**
                   * Current length.
                   * @type {number}
                   */
                  this.len = 0;
                  /**
                   * Operations head.
                   * @type {Object}
                   */

                  this.head = new Op(noop, 0, 0);
                  /**
                   * Operations tail
                   * @type {Object}
                   */

                  this.tail = this.head;
                  /**
                   * Linked forked states.
                   * @type {Object|null}
                   */

                  this.states = null; // When a value is written, the writer calculates its byte length and puts it into a linked
                  // list of operations to perform when finish() is called. This both allows us to allocate
                  // buffers of the exact required size and reduces the amount of work we have to do compared
                  // to first calculating over objects and then encoding over objects. In our case, the encoding
                  // part is just a linked list walk calling operations with already prepared values.
                }
                /**
                 * Creates a new writer.
                 * @function
                 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
                 */


                Writer.create = util.Buffer ? function create_buffer_setup() {
                  return (Writer.create = function create_buffer() {
                    return new BufferWriter();
                  })();
                }
                /* istanbul ignore next */
                : function create_array() {
                  return new Writer();
                };
                /**
                 * Allocates a buffer of the specified size.
                 * @param {number} size Buffer size
                 * @returns {Uint8Array} Buffer
                 */

                Writer.alloc = function alloc(size) {
                  return new util.Array(size);
                }; // Use Uint8Array buffer pool in the browser, just like node does with buffers

                /* istanbul ignore else */


                if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
                /**
                 * Pushes a new operation to the queue.
                 * @param {function(Uint8Array, number, *)} fn Function to call
                 * @param {number} len Value byte length
                 * @param {number} val Value to write
                 * @returns {Writer} `this`
                 * @private
                 */

                Writer.prototype._push = function push(fn, len, val) {
                  this.tail = this.tail.next = new Op(fn, len, val);
                  this.len += len;
                  return this;
                };

                function writeByte(val, buf, pos) {
                  buf[pos] = val & 255;
                }

                function writeVarint32(val, buf, pos) {
                  while (val > 127) {
                    buf[pos++] = val & 127 | 128;
                    val >>>= 7;
                  }

                  buf[pos] = val;
                }
                /**
                 * Constructs a new varint writer operation instance.
                 * @classdesc Scheduled varint writer operation.
                 * @extends Op
                 * @constructor
                 * @param {number} len Value byte length
                 * @param {number} val Value to write
                 * @ignore
                 */


                function VarintOp(len, val) {
                  this.len = len;
                  this.next = undefined$1;
                  this.val = val;
                }

                VarintOp.prototype = Object.create(Op.prototype);
                VarintOp.prototype.fn = writeVarint32;
                /**
                 * Writes an unsigned 32 bit value as a varint.
                 * @param {number} value Value to write
                 * @returns {Writer} `this`
                 */

                Writer.prototype.uint32 = function write_uint32(value) {
                  // here, the call to this.push has been inlined and a varint specific Op subclass is used.
                  // uint32 is by far the most frequently used operation and benefits significantly from this.
                  this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
                  return this;
                };
                /**
                 * Writes a signed 32 bit value as a varint.
                 * @function
                 * @param {number} value Value to write
                 * @returns {Writer} `this`
                 */


                Writer.prototype.int32 = function write_int32(value) {
                  return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
                  : this.uint32(value);
                };
                /**
                 * Writes a 32 bit value as a varint, zig-zag encoded.
                 * @param {number} value Value to write
                 * @returns {Writer} `this`
                 */


                Writer.prototype.sint32 = function write_sint32(value) {
                  return this.uint32((value << 1 ^ value >> 31) >>> 0);
                };

                function writeVarint64(val, buf, pos) {
                  while (val.hi) {
                    buf[pos++] = val.lo & 127 | 128;
                    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
                    val.hi >>>= 7;
                  }

                  while (val.lo > 127) {
                    buf[pos++] = val.lo & 127 | 128;
                    val.lo = val.lo >>> 7;
                  }

                  buf[pos++] = val.lo;
                }
                /**
                 * Writes an unsigned 64 bit value as a varint.
                 * @param {Long|number|string} value Value to write
                 * @returns {Writer} `this`
                 * @throws {TypeError} If `value` is a string and no long library is present.
                 */


                Writer.prototype.uint64 = function write_uint64(value) {
                  var bits = LongBits.from(value);
                  return this._push(writeVarint64, bits.length(), bits);
                };
                /**
                 * Writes a signed 64 bit value as a varint.
                 * @function
                 * @param {Long|number|string} value Value to write
                 * @returns {Writer} `this`
                 * @throws {TypeError} If `value` is a string and no long library is present.
                 */


                Writer.prototype.int64 = Writer.prototype.uint64;
                /**
                 * Writes a signed 64 bit value as a varint, zig-zag encoded.
                 * @param {Long|number|string} value Value to write
                 * @returns {Writer} `this`
                 * @throws {TypeError} If `value` is a string and no long library is present.
                 */

                Writer.prototype.sint64 = function write_sint64(value) {
                  var bits = LongBits.from(value).zzEncode();
                  return this._push(writeVarint64, bits.length(), bits);
                };
                /**
                 * Writes a boolish value as a varint.
                 * @param {boolean} value Value to write
                 * @returns {Writer} `this`
                 */


                Writer.prototype.bool = function write_bool(value) {
                  return this._push(writeByte, 1, value ? 1 : 0);
                };

                function writeFixed32(val, buf, pos) {
                  buf[pos] = val & 255;
                  buf[pos + 1] = val >>> 8 & 255;
                  buf[pos + 2] = val >>> 16 & 255;
                  buf[pos + 3] = val >>> 24;
                }
                /**
                 * Writes an unsigned 32 bit value as fixed 32 bits.
                 * @param {number} value Value to write
                 * @returns {Writer} `this`
                 */


                Writer.prototype.fixed32 = function write_fixed32(value) {
                  return this._push(writeFixed32, 4, value >>> 0);
                };
                /**
                 * Writes a signed 32 bit value as fixed 32 bits.
                 * @function
                 * @param {number} value Value to write
                 * @returns {Writer} `this`
                 */


                Writer.prototype.sfixed32 = Writer.prototype.fixed32;
                /**
                 * Writes an unsigned 64 bit value as fixed 64 bits.
                 * @param {Long|number|string} value Value to write
                 * @returns {Writer} `this`
                 * @throws {TypeError} If `value` is a string and no long library is present.
                 */

                Writer.prototype.fixed64 = function write_fixed64(value) {
                  var bits = LongBits.from(value);
                  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
                };
                /**
                 * Writes a signed 64 bit value as fixed 64 bits.
                 * @function
                 * @param {Long|number|string} value Value to write
                 * @returns {Writer} `this`
                 * @throws {TypeError} If `value` is a string and no long library is present.
                 */


                Writer.prototype.sfixed64 = Writer.prototype.fixed64;
                /**
                 * Writes a float (32 bit).
                 * @function
                 * @param {number} value Value to write
                 * @returns {Writer} `this`
                 */

                Writer.prototype["float"] = function write_float(value) {
                  return this._push(util["float"].writeFloatLE, 4, value);
                };
                /**
                 * Writes a double (64 bit float).
                 * @function
                 * @param {number} value Value to write
                 * @returns {Writer} `this`
                 */


                Writer.prototype["double"] = function write_double(value) {
                  return this._push(util["float"].writeDoubleLE, 8, value);
                };

                var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
                  buf.set(val, pos); // also works for plain array values
                }
                /* istanbul ignore next */
                : function writeBytes_for(val, buf, pos) {
                  for (var i = 0; i < val.length; ++i) {
                    buf[pos + i] = val[i];
                  }
                };
                /**
                 * Writes a sequence of bytes.
                 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
                 * @returns {Writer} `this`
                 */

                Writer.prototype.bytes = function write_bytes(value) {
                  var len = value.length >>> 0;
                  if (!len) return this._push(writeByte, 1, 0);

                  if (util.isString(value)) {
                    var buf = Writer.alloc(len = base64.length(value));
                    base64.decode(value, buf, 0);
                    value = buf;
                  }

                  return this.uint32(len)._push(writeBytes, len, value);
                };
                /**
                 * Writes a string.
                 * @param {string} value Value to write
                 * @returns {Writer} `this`
                 */


                Writer.prototype.string = function write_string(value) {
                  var len = utf8.length(value);
                  return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
                };
                /**
                 * Forks this writer's state by pushing it to a stack.
                 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
                 * @returns {Writer} `this`
                 */


                Writer.prototype.fork = function fork() {
                  this.states = new State(this);
                  this.head = this.tail = new Op(noop, 0, 0);
                  this.len = 0;
                  return this;
                };
                /**
                 * Resets this instance to the last state.
                 * @returns {Writer} `this`
                 */


                Writer.prototype.reset = function reset() {
                  if (this.states) {
                    this.head = this.states.head;
                    this.tail = this.states.tail;
                    this.len = this.states.len;
                    this.states = this.states.next;
                  } else {
                    this.head = this.tail = new Op(noop, 0, 0);
                    this.len = 0;
                  }

                  return this;
                };
                /**
                 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
                 * @returns {Writer} `this`
                 */


                Writer.prototype.ldelim = function ldelim() {
                  var head = this.head,
                      tail = this.tail,
                      len = this.len;
                  this.reset().uint32(len);

                  if (len) {
                    this.tail.next = head.next; // skip noop

                    this.tail = tail;
                    this.len += len;
                  }

                  return this;
                };
                /**
                 * Finishes the write operation.
                 * @returns {Uint8Array} Finished buffer
                 */


                Writer.prototype.finish = function finish() {
                  var head = this.head.next,
                      // skip noop
                  buf = this.constructor.alloc(this.len),
                      pos = 0;

                  while (head) {
                    head.fn(head.val, buf, pos);
                    pos += head.len;
                    head = head.next;
                  } // this.head = this.tail = null;


                  return buf;
                };

                Writer._configure = function (BufferWriter_) {
                  BufferWriter = BufferWriter_;
                };
              }, {
                "39": 39
              }],
              43: [function (require, module, exports) {
                module.exports = BufferWriter; // extends Writer

                var Writer = require(42);

                (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

                var util = require(39);

                var Buffer = util.Buffer;
                /**
                 * Constructs a new buffer writer instance.
                 * @classdesc Wire format writer using node buffers.
                 * @extends Writer
                 * @constructor
                 */

                function BufferWriter() {
                  Writer.call(this);
                }
                /**
                 * Allocates a buffer of the specified size.
                 * @param {number} size Buffer size
                 * @returns {Buffer} Buffer
                 */


                BufferWriter.alloc = function alloc_buffer(size) {
                  return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
                };

                var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
                  buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                  // also works for plain array values
                }
                /* istanbul ignore next */
                : function writeBytesBuffer_copy(val, buf, pos) {
                  if (val.copy) // Buffer values
                    val.copy(buf, pos, 0, val.length);else for (var i = 0; i < val.length;) {
                    // plain array values
                    buf[pos++] = val[i++];
                  }
                };
                /**
                 * @override
                 */

                BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
                  if (util.isString(value)) value = util._Buffer_from(value, "base64");
                  var len = value.length >>> 0;
                  this.uint32(len);
                  if (len) this._push(writeBytesBuffer, len, value);
                  return this;
                };

                function writeStringBuffer(val, buf, pos) {
                  if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
                    util.utf8.write(val, buf, pos);else buf.utf8Write(val, pos);
                }
                /**
                 * @override
                 */


                BufferWriter.prototype.string = function write_string_buffer(value) {
                  var len = Buffer.byteLength(value);
                  this.uint32(len);
                  if (len) this._push(writeStringBuffer, len, value);
                  return this;
                };
                /**
                 * Finishes the write operation.
                 * @name BufferWriter#finish
                 * @function
                 * @returns {Buffer} Finished buffer
                 */

              }, {
                "39": 39,
                "42": 42
              }]
            }, {}, [19]);
          })(typeof window === "object" && window || typeof self === "object" && self || this);
        })();

        _cjsExports = exports('default', module.exports);
      });

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);
    }
  };
});

System.register("chunks:///_virtual/migrate-canvas.ts", ['cc'], function () {
  'use strict';

  var cclegacy, director, Director, Canvas, Camera, game, Node;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      director = module.director;
      Director = module.Director;
      Canvas = module.Canvas;
      Camera = module.Camera;
      game = module.game;
      Node = module.Node;
    }],
    execute: function () {
      cclegacy._RF.push({}, "d0542klO8BG07lUw7bhDWKK", "migrate-canvas", undefined);

      var customLayerMask = 0x000fffff;
      var builtinLayerMask = 0xfff00000;
      director.on(Director.EVENT_AFTER_SCENE_LAUNCH, function () {
        var _director$getScene, _director$getScene2, _director$getScene3;

        var roots = (_director$getScene = director.getScene()) === null || _director$getScene === void 0 ? void 0 : _director$getScene.children;
        var allCanvases = (_director$getScene2 = director.getScene()) === null || _director$getScene2 === void 0 ? void 0 : _director$getScene2.getComponentsInChildren(Canvas);
        if (allCanvases.length <= 1) return;
        allCanvases = allCanvases.filter(function (x) {
          return !!x.cameraComponent;
        });
        var allCameras = (_director$getScene3 = director.getScene()) === null || _director$getScene3 === void 0 ? void 0 : _director$getScene3.getComponentsInChildren(Camera);
        var usedLayer = 0;
        allCameras.forEach(function (x) {
          return usedLayer |= x.visibility & customLayerMask;
        });
        var persistCanvas = [];

        for (var i = 0, l = roots.length; i < l; i++) {
          var root = roots[i];
          if (!game.isPersistRootNode(root)) continue;
          var canvases = root.getComponentsInChildren(Canvas);
          if (canvases.length === 0) continue;
          persistCanvas.push.apply(persistCanvas, canvases.filter(function (x) {
            return !!x.cameraComponent;
          }));
        }

        persistCanvas.forEach(function (val) {
          var isLayerCollided = allCanvases.find(function (x) {
            return x !== val && x.cameraComponent.visibility & val.cameraComponent.visibility & customLayerMask;
          });

          if (isLayerCollided) {
            var availableLayers = ~usedLayer;
            var lastAvailableLayer = availableLayers & ~(availableLayers - 1);
            val.cameraComponent.visibility = lastAvailableLayer | val.cameraComponent.visibility & builtinLayerMask;
            setChildrenLayer(val.node, lastAvailableLayer);
            usedLayer |= availableLayers;
          }
        });
      });

      function setChildrenLayer(node, layer) {
        for (var i = 0, l = node.children.length; i < l; i++) {
          node.children[i].layer = layer;
          setChildrenLayer(node.children[i], layer);
        }
      }

      var setParentEngine = Node.prototype.setParent;
      {
        Node.prototype.setParent = function (value, keepWorldTransform) {
          setParentEngine.call(this, value, keepWorldTransform);
          if (!value) return; // find canvas

          var layer = getCanvasCameraLayer(this);

          if (layer) {
            this.layer = layer;
            setChildrenLayer(this, layer);
          }
        };
      }

      function getCanvasCameraLayer(node) {
        var layer = 0;
        var canvas = node.getComponent(Canvas);

        if (canvas && canvas.cameraComponent) {
          if (canvas.cameraComponent.visibility & canvas.node.layer) {
            layer = canvas.node.layer;
          } else {
            layer = canvas.cameraComponent.visibility & ~(canvas.cameraComponent.visibility - 1);
          }

          return layer;
        }

        if (node.parent) {
          layer = getCanvasCameraLayer(node.parent);
        }

        return layer;
      }

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EventMgr.ts", ['cc', './_rollupPluginModLoBabelHelpers.js'], function (exports) {
  'use strict';

  var cclegacy, _decorator, Component, _defineProperty, _inheritsLoose, _assertThisInitialized;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      _defineProperty = module.defineProperty;
      _inheritsLoose = module.inheritsLoose;
      _assertThisInitialized = module.assertThisInitialized;
    }],
    execute: function () {
      var _dec, _class, _class2, _temp;

      cclegacy._RF.push({}, "d08bfpnzn5DVYJdXPIoC/+D", "EventMgr", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var EventMgr = exports('EventMgr', (_dec = ccclass("EventMgr"), _dec(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(EventMgr, _Component);

        function EventMgr() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this), "events_map", {});

          return _this;
        }

        var _proto = EventMgr.prototype;

        _proto.onLoad = function onLoad() {
          if (EventMgr.Instance === null) {
            EventMgr.Instance = this;
          } else {
            this.destroy();
            return;
          }
        } // func(event_name: string, udata: any)
        ;

        _proto.AddEventListener = function AddEventListener(eventName, caller, func) {
          if (!this.events_map[eventName]) {
            this.events_map[eventName] = [];
          }

          var event_queue = this.events_map[eventName];
          event_queue.push({
            caller: caller,
            func: func
          });
        };

        _proto.RemoveListenner = function RemoveListenner(eventName, caller, func) {
          if (!this.events_map[eventName]) {
            return;
          }

          var event_queue = this.events_map[eventName];

          for (var i = 0; i < event_queue.length; i++) {
            var obj = event_queue[i];

            if (obj.caller == caller && obj.func == func) {
              event_queue.splice(i, 1);
              break;
            }
          }

          if (event_queue.length <= 0) {
            this.events_map[eventName] = null;
          }
        };

        _proto.Emit = function Emit(eventName, udata) {
          if (!this.events_map[eventName]) {
            return;
          }

          var event_queue = this.events_map[eventName];

          for (var i = 0; i < event_queue.length; i++) {
            var obj = event_queue[i];
            obj.func.call(obj.caller, eventName, udata);
          }
        };

        return EventMgr;
      }(Component), _defineProperty(_class2, "Instance", null), _temp)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/helper.ts", ['cc', './index.cjs.js', './index.cjs.mjs_cjs=&original=.js'], function (exports) {
  'use strict';

  var cclegacy, _cjsExports;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      _cjsExports = module.default;
    }, null],
    execute: function () {
      cclegacy._RF.push({}, "d6558k3dD1D3ZNR3rkSJz2y", "helper", undefined);

      var Logger = _cjsExports.Logger;
      var loadTime = exports('loadTime', function loadTime(label) {
        var time = new Date().getTime();
        Logger.warn("------" + label + "\u52A0\u8F7D\u5B8C\u6210\uFF0C\u5F53\u524D\u65F6\u95F4\u6233\uFF1A " + time + "\uFF0C\u5F53\u524D\u52A0\u8F7D\u8017\u65F6\uFF1A" + (time - performance.timing.navigationStart));
      });

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EnvColliders.ts", ['cc'], function (exports) {
  'use strict';

  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      exports('MyPhysics', void 0);

      cclegacy._RF.push({}, "e30936Zb21Kn5o6dbORxo7k", "EnvColliders", undefined);
      /**
       * @Author: liubeizhang
       * @Date: 2021-08-29 09:08:00
       * 确定性碰撞环境
       */


      var MyPhysics;

      (function (_MyPhysics) {})(MyPhysics || (MyPhysics = exports('MyPhysics', {})));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/GameDataMgr.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './index.cjs.js', './index.cjs.mjs_cjs=&original=.js', './GameConstants.ts', './lodash.ts', './BridgeMgr.ts', './long.js', './long.mjs_cjs=&original=.js'], function (exports) {
  'use strict';

  var cclegacy, _decorator, v3, _defineProperty, _cjsExports, RoleType, RoundStatus, GameCountDownTime, GridType, PlayerState, GameType, MODEL_ID, SKIN_ID, lodash, BridgeMgr, _cjsExports$1;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      v3 = module.v3;
    }, function (module) {
      _defineProperty = module.defineProperty;
    }, function (module) {
      _cjsExports = module.default;
    }, null, function (module) {
      RoleType = module.RoleType;
      RoundStatus = module.RoundStatus;
      GameCountDownTime = module.GameCountDownTime;
      GridType = module.GridType;
      PlayerState = module.PlayerState;
      GameType = module.GameType;
      MODEL_ID = module.MODEL_ID;
      SKIN_ID = module.SKIN_ID;
    }, function (module) {
      lodash = module.lodash;
    }, function (module) {
      BridgeMgr = module.BridgeMgr;
    }, function (module) {
      _cjsExports$1 = module.default;
    }, null],
    execute: function () {
      var _class, _temp;

      cclegacy._RF.push({}, "ed052fdD9RCqLCXl+gfxjSG", "GameDataMgr", undefined);

      var Logger = _cjsExports.Logger;
      var ccclass = _decorator.ccclass;
      var GameDataMgr = exports('default', // GameApp
      // 全局游戏数据管理
      ccclass(_class = (_temp = /*#__PURE__*/function () {
        function GameDataMgr() {
          _defineProperty(this, "battleId", "");

          _defineProperty(this, "roomId", "");

          _defineProperty(this, "uId", "");

          _defineProperty(this, "token", "");

          _defineProperty(this, "deviceId", "");

          _defineProperty(this, "anchorUid", "");

          _defineProperty(this, "isViewer", false);

          _defineProperty(this, "inMic", true);

          _defineProperty(this, "x", 0);

          _defineProperty(this, "y", 0);

          _defineProperty(this, "w", 0);

          _defineProperty(this, "h", 0);

          _defineProperty(this, "roundConfirmTime", GameCountDownTime);

          _defineProperty(this, "roundCountdown", GameCountDownTime);

          _defineProperty(this, "playerStatus", PlayerState.OFFLINE);

          _defineProperty(this, "playerType", RoleType.UNKNOWN);

          _defineProperty(this, "myCurrentTurnData", {});

          _defineProperty(this, "startType", GameType.REGULAR_GAME);

          _defineProperty(this, "isPlayoff", false);

          _defineProperty(this, "currentDuel", []);

          _defineProperty(this, "nextDuel", []);

          _defineProperty(this, "leftDuel", []);

          _defineProperty(this, "rightDuel", []);

          _defineProperty(this, "mapInfo", []);

          _defineProperty(this, "roundSettleData", []);

          _defineProperty(this, "gameNo", 0);

          _defineProperty(this, "roundNo", 0);

          _defineProperty(this, "roundStatus", RoundStatus.IN_GAME);

          _defineProperty(this, "gameSettleData", {});
        }

        var _proto = GameDataMgr.prototype; //需要的数据结构
        //1,房间信息
        //2,用户id，用户状态，设备id，是否在当前
        //3,
        // ---------游戏数据 end--------
        //初始化桥数据

        _proto.init = function init(cb) {
          var _this = this;

          Logger.info("bridge 开始获取房间信息GameDataMgr init getRoomInfo ");

          _cjsExports.PkBridge.getRoomInfo().then(function (roomInfo) {
            BridgeMgr.Instance.getRoomInfo();
            Logger.info("bridge 已经获取房间信息GameDataMgr init getRoomInfo ", roomInfo);

            _this.updateRoomInfo(roomInfo); //确定玩家类型


            _this.checkPlayerType();

            if (cb) cb();
          });
        };

        _proto.getLongStr = function getLongStr(data) {
          if (!data) return "";
          return _cjsExports$1.fromValue(data).toString();
        };

        _proto.updateTestData = function updateTestData() {
          var testUdata = [{
            idx: "0",
            uid: "212581059431380021",
            roomId: "1141",
            token: "WetKyldMWQWVAf6UYZWSiWGKLhcRfOt0KyA5MknTUqnfiMO3EHQ5Z9wB8Igf0Wx1_b5xqYhsqEB0GOMIVYxKO1phsJPLelRdfWOlik0wy5268y8sQPCbzOWchl1ogbg2o131GC78y1GeDc4GzjNsvyDWoNY86mSz5h_Xm91rdl1uBmidQOLl8pupbQVS-EC2JueZsdCJSay7PqMd9EEW8BpIQ-mzcyyNzRRZ-cCo4TzTZOngQ3aQ2SZQmrWIkjCc"
          }, {
            idx: "1",
            uid: "212570966531270005",
            roomId: "1140",
            token: "WetKyldMWQWVAf6UYZWSiaywOG4AZ3HCKnrxpv9Z7ZnfiMO3EHQ5Z9wB8Igf0Wx15iIcCMSnewUY3IlB3Olh_PAzMV3X3cFYt39vQCDQli8B0e8GvxjFCA8f4yngdrV7pa06Hg0FzI0lPGiSmHyJJsdjRMVnUFcqM_tGU6gFRX52cCi3bet0yNkHVIrskSnrJueZsdCJSay7PqMd9EEW8BpIQ-mzcyyNzRRZ-cCo4TzTZOngQ3aQ2SZQmrWIkjCc"
          }, {
            idx: "2",
            uid: "1835212113000006",
            roomId: "1140",
            token: "6aAfqrWutmD4yZ3XgUQt66wUg2sAgr4l3lKEjOJHk4RsBgB794mHDG18KnsRWnKybaPGopvF4DSJtqBmBfnj9yzsumqZVg5wQ91lMpCIOnn1XmkhZuBb9aF6MwNoYI-x9uYH9TYB8w0qb0qyTOaqLQMo7buQiO4RfJW_8R5b9JtlxOJ6W3lw717AYxBTHL42VBTdpyw5RXfkOOlRYE4acrjM50v1xAFK9JWapgUE33auQbLXyfHwAM4f3SL00WXG"
          }];
          this.anchorUid = "212581059431380021";
          var idx = parseInt(_cjsExports.Utils.getUrlKey("uid"));
          if (!idx) idx = 0;
          this.roomId = testUdata[idx].roomId;
          this.uId = testUdata[idx].uid;
          this.token = testUdata[idx].token;
          this.playerType = RoleType.PLAYER;
        } // 基于桥事件获取到房间信息，最开始就可以获取到
        ;

        _proto.updateRoomInfo = function updateRoomInfo(roomData) {
          if (!roomData) {
            Logger.info("bridge roomData数据异常！请检查桥事件是否调用成功！roomData=" + JSON.stringify(roomData));
            return;
          }

          this.roomId = roomData.roomId;
          this.uId = roomData.uid;
          this.anchorUid = roomData.hostUid;
          this.deviceId = roomData.deviceId;
          this.isViewer = roomData.isViewer;
          this.inMic = roomData.inMic;
          this.x = roomData.x;
          this.y = roomData.y;
          this.w = roomData.w;
          this.h = roomData.h;
          Logger.info("bridge 更新房间信息updateRoomInfo ", JSON.stringify(this));
        };

        _proto.updateGameSnapshotRespData = function updateGameSnapshotRespData(data) {
          // 更新左右两侧用户信息
          this.leftDuel = [];
          this.rightDuel = [];

          for (var i = 0; i < data.length; i++) {
            var info = data[i]; //属于同一分组，位于左侧

            var hostUid = this.getLongStr(info.hostUid);
            var uid = this.getLongStr(info.uid);
            var userOnlineStatus = info.userOnlineStatus ? info.userOnlineStatus : info.status ? info.status : 0;
            var userData = {
              "uid": uid,
              "anchorUid": hostUid,
              "avatar": info.avatar,
              "username": info.username,
              "score": info.score ? info.score : 0,
              "roleName": info.roleName,
              "roleId": info.roleId,
              "roleIcon": info.roleIcon,
              "isAnchor": info.isAnchor ? true : false,
              "userOnlineStatus": userOnlineStatus
            };

            if (this.anchorUid === hostUid) {
              this.leftDuel.push(userData);
            } else {
              this.rightDuel.push(userData);
            }
          }

          Logger.info("Star-LogicData-updateGameSnapshotRespData 抢星星游戏开始, uid = ", this.uId, "anchorUid = ", this.anchorUid, "roomId = ", this.roomId, " playerType = ", this.playerType, " battleId = ", this.battleId, " isPlayoff = ", this.isPlayoff, " gameNo = ", this.gameNo, " roundNo = ", this.roundNo, " leftDual = ", this.leftDuel, " rightDual = ", this.rightDuel);
        } //确定自己的用户类型
        ;

        _proto.checkPlayerType = function checkPlayerType() {
          //  isPC
          //      主播，                               -> 展示PC UI界面
          //   not PC
          //      isViewer 
          //          主播在客户端登录，设置为观众视角   ->展示客户端观众 UI界面
          //      !isViewer
          //          在GameList列表内， 玩家
          //               inMic 在麦上 玩家          -> 展示客户端玩家 UI界面
          //              不在麦上      观众          -> 展示客户端玩家 UI界面
          //          不在GameList列表内，观众         -> 展示客户端观众 UI界面
          var playerType = RoleType.AUDIENCE;

          if (_cjsExports.Bridge.app.isYppPC) {
            playerType = RoleType.PC_PLAYER;
          } else {
            if (this.isViewer) {
              playerType = RoleType.AUDIENCE;
            } else {
              if (this.inMic) {
                playerType = RoleType.PLAYER;
              }
            }
          }

          this.playerType = playerType;
        } // 更新局数据
        ;

        _proto.updateGameStartData = function updateGameStartData(data) {
          this.battleId = this.getLongStr(data.battleId);
          this.startType = data.startType;
          var playoff = data.isPlayoff;
          this.isPlayoff = playoff == 1 ? true : false;
          this.gameNo = data.gameNo ? data.gameNo : 1;
          this.roundNo = data.roundNo ? data.roundNo : 1;
          this.roundStatus = RoundStatus.IN_GAME;
          this.roundConfirmTime = data.roundConfirmTime == undefined || data.roundConfirmTime == 0 ? GameCountDownTime : data.roundConfirmTime;
          this.roundCountdown = this.roundConfirmTime / 1000;
          this.currentDuel = [];

          for (var i = 0; i < data.currentDuel.length; i++) {
            var info = data.currentDuel[i];
            var playerData = {
              "uid": this.getLongStr(info.uid),
              "anchorUid": this.getLongStr(info.anchorUid),
              "avatar": info.avatar,
              "username": info.username,
              "score": info.score,
              "roleName": info.roleName,
              "roleId": info.roleId,
              "roleIcon": info.roleIcon,
              "isAnchor": info.isAnchor ? true : false,
              "userOnlineStatus": info.userOnlineStatus
            };
            this.currentDuel.push(playerData);
          }

          this.nextDuel = [];

          for (var _i = 0; _i < data.nextDuel.length; _i++) {
            var _info = data.nextDuel[_i];
            var _playerData = {
              "uid": this.getLongStr(_info.uid),
              "anchorUid": this.getLongStr(_info.anchorUid),
              "avatar": _info.avatar,
              "username": _info.username,
              "score": _info.score,
              "roleName": _info.roleName,
              "roleId": _info.roleId,
              "roleIcon": _info.roleIcon,
              "isAnchor": _info.isAnchor ? true : false,
              "userOnlineStatus": _info.userOnlineStatus
            };
            this.nextDuel.push(_playerData);
          }

          this.updateMapInfo(data);
          Logger.info("Star-LogicData-updateGameStartData 本局游戏开始，我的uid = ", this.uId, " battleId = ", this.battleId, " gameNo = ", this.gameNo, " roundNo = ", this.roundNo, "anchorUid = ", this.anchorUid, "roomId = ", this.roomId, " playerType = ", this.playerType, " roundConfirmTime = ", this.roundConfirmTime, " roundCountdown = ", this.roundCountdown, " isPlayoff = ", this.isPlayoff, "我在当前局的格子数据 = ", JSON.stringify(this.myCurrentTurnData), "currentDuel = ", JSON.stringify(this.currentDuel), " nextDuel = ", JSON.stringify(this.nextDuel), " mapInfo = ", JSON.stringify(this.mapInfo));
        };

        _proto.updateMapInfo = function updateMapInfo(data) {
          this.mapInfo = [];
          var gridList = data.map.gridList;
          this.myCurrentTurnData = {};

          for (var i = 0; i < gridList.length; i++) {
            var info = gridList[i];
            var gold = info.gold ? info.gold : 0;
            var grid = {
              "id": info.id,
              // 格子ID(1-9)
              "type": info.type,
              // 格子类型（1金币；2人物；3空格子）
              "uid": this.getLongStr(info.uid),
              // 用户uid
              "gold": gold,
              // 金币数量
              "isMe": false,
              "gridIsAnchor": false,
              "roleId": "1",
              "skinId": "1"
            }; //自己处在当前轮中

            if (grid.uid == this.uId && info.type == GridType.ROLE) {
              //加入一个字段，说明自己在玩
              grid.isMe = true;
              this.myCurrentTurnData = lodash.cloneDeep(grid);
              grid.gridIsAnchor = false;
              Logger.info("我在本回合中，我的uid = ", this.uId, " 我的角色是: ", grid.type, "myCurrentTurnData = ", JSON.stringify(this.myCurrentTurnData));
            } //计算玩家对应的的皮肤和角色id


            if (info.type == GridType.ROLE) {
              var roleName = this.getGameRoleName(grid.uid);
              var roleId = this.getPlayerRoleId(roleName);
              var skinId = this.getPlayerSkinId(roleName);
              grid.roleId = roleId;
              grid.skinId = skinId;
            }

            this.mapInfo.push(grid);
          }
        } // 更新回合数据
        ;

        _proto.updateRoundStartData = function updateRoundStartData(data) {
          this.gameNo = data.gameNo;
          this.roundNo = data.roundNo;
          this.roundStatus = RoundStatus.IN_GAME;
          this.roundConfirmTime = data.roundConfirmTime == undefined || data.roundConfirmTime == 0 ? GameCountDownTime : data.roundConfirmTime;
          this.roundCountdown = this.roundConfirmTime / 1000;
          this.updateMapInfo(data);
          Logger.info("Star-LogicData-updateRoundStartData 本轮游戏开始，我的uid = ", this.uId, "anchorUid = ", this.anchorUid, " battleId = ", this.battleId, " gameNo = ", this.gameNo, " roundNo = ", this.roundNo, "roomId = ", this.roomId, " playerType = ", this.playerType, " isPlayoff = ", this.isPlayoff, " roundConfirmTime = ", this.roundConfirmTime, " roundCountdown = ", this.roundCountdown, "我在当前局的格子数据 = ", JSON.stringify(this.myCurrentTurnData), " mapInfo = ", JSON.stringify(this.mapInfo));
        } // 更新回合结算数据
        ;

        _proto.updateRoundSettleData = function updateRoundSettleData(data) {
          //设置当前状态位结算状态
          this.roundStatus = RoundStatus.IN_SETTLE; //更新结算数据

          this.roundSettleData = [];
          var roundSettle = data.roundSettle;

          for (var i = 0; i < roundSettle.length; i++) {
            var settle = roundSettle[i];
            var settleAUid = this.getLongStr(settle.uid);
            var isHitted = false; //选择的格子是否与其他玩家的选择冲突，冲突，则说明撞上了

            for (var j = 0; j < roundSettle.length; j++) {
              var settleBUid = this.getLongStr(roundSettle[j].uid);

              if (settleAUid != settleBUid && settle.gridNo == roundSettle[j].gridNo) {
                isHitted = true;
                break;
              }
            } //选择的格子不是空类型，并且没有跟其他玩家相撞，则表示赢了钱


            var isFail = true;

            for (var k = 0; k < this.mapInfo.length; k++) {
              if (settle.gridNo == this.mapInfo[k].id && this.mapInfo[k].type != GridType.NONE && !isHitted) {
                isFail = false;
                break;
              }
            }

            var _gold = settle.gold ? settle.gold : 0;

            var _score = settle.score ? settle.score : 0;

            var settleData = {
              uid: settleAUid,
              gridNo: settle.gridNo,
              gold: _gold,
              score: _score,
              isHitted: isHitted,
              isFail: isFail,
              starPos: v3(0, 0, 0)
            };
            this.roundSettleData.push(settleData);
          }

          Logger.info("Star-LogicData-updateRoundSettleData 本轮结算开始，我的uid = ", this.uId, "anchorUid = ", this.anchorUid, "roomId = ", this.roomId, " playerType = ", this.playerType, " battleId = ", this.battleId, " isPlayoff = ", this.isPlayoff, " gameNo = ", this.gameNo, " roundNo = ", this.roundNo, " roundSettleData = ", JSON.stringify(this.roundSettleData));
        } // 重连，数据更新
        ;

        _proto.updateReEnterData = function updateReEnterData(data) {
          this.gameNo = data.gameNo;
          this.roundNo = data.roundNo;
          this.roundStatus = data.roundStatus;
          this.isPlayoff = data.isPlayoff == 1 ? true : false;
          this.roundConfirmTime = data.roundConfirmTime == undefined || data.roundConfirmTime == 0 ? GameCountDownTime : data.roundConfirmTime;
          this.roundCountdown = data.roundCountdown == undefined || data.roundCountdown == 0 ? this.roundConfirmTime / 1000 : data.roundCountdown;
          var userInfos = data.teamA.concat(data.teamB); // 更新左右两侧用户信息

          this.leftDuel = [];
          this.rightDuel = [];
          this.currentDuel = [];
          this.myCurrentTurnData = {};

          for (var i = 0; i < userInfos.length; i++) {
            var info = userInfos[i]; //属于同一分组，位于左侧

            var uid = this.getLongStr(info.uid);
            var anchorUid = this.getLongStr(info.anchorUid);
            var userData = {
              "uid": uid,
              "anchorUid": anchorUid,
              "avatar": info.avatar,
              "username": info.username,
              "score": info.score,
              "roleName": info.roleName,
              "roleId": info.roleId,
              "roleIcon": info.roleIcon,
              "isAnchor": info.isAnchor,
              "userOnlineStatus": info.userOnlineStatus
            };

            if (this.anchorUid === anchorUid) {
              this.leftDuel.push(userData);
            } else {
              this.rightDuel.push(userData);
            }

            var _gridList = data.map.gridList;

            for (var j = 0; j < _gridList.length; j++) {
              var mapInfo = _gridList[j]; //处在当前轮中

              if (this.getLongStr(mapInfo.uid) == uid && mapInfo.type == GridType.ROLE) {
                this.currentDuel.push(userData);
              }
            }
          } //组装地图数据


          this.mapInfo = [];
          var gridList = data.map.gridList;

          for (var _j = 0; _j < gridList.length; _j++) {
            var _mapInfo = gridList[_j];
            var gold = _mapInfo.gold ? _mapInfo.gold : 0;
            var grid = {
              "id": _mapInfo.id,
              // 格子ID(1-9)
              "type": _mapInfo.type,
              // 格子类型（1金币；2人物；3空格子）
              "uid": this.getLongStr(_mapInfo.uid),
              // 用户uid
              "gold": gold,
              // 金币数量
              "isMe": false,
              "gridIsAnchor": false,
              "roleId": "1",
              "skinId": "1"
            }; //处在当前轮中

            if (grid.uid == this.uId && _mapInfo.type == GridType.ROLE) {
              //加入一个字段，说明自己在玩
              grid.isMe = true;
              this.myCurrentTurnData = lodash.cloneDeep(grid);
              grid.gridIsAnchor = false;
              Logger.info("我在本回合中，我的uid = " + this.uId + " 我的角色是: " + grid.type);
            } //更新用户的角色id和皮肤id


            var roleName = this.getGameRoleName(grid.uid);
            var roleId = this.getPlayerRoleId(roleName);
            var skinId = this.getPlayerSkinId(roleName);
            grid.roleId = roleId;
            grid.skinId = skinId;
            this.mapInfo.push(grid);
          }

          Logger.info("Star-LogicData-updateReEnterData 重连数据更新开始，我的uid = ", this.uId, "anchorUid = ", this.anchorUid, "roomId = ", this.roomId, " playerType = ", this.playerType, " battleId = ", this.battleId, " isPlayoff = ", this.isPlayoff, " gameNo = ", this.gameNo, " roundNo = ", this.roundNo, " roundStatus = ", this.roundStatus, "我在当前局的格子数据 = ", JSON.stringify(this.myCurrentTurnData), " leftDuel = ", JSON.stringify(this.leftDuel), " rightDuel = ", JSON.stringify(this.rightDuel), " mapInfo = ", JSON.stringify(this.mapInfo));
        } // 更新用户状态
        ;

        _proto.updatePlayerStateData = function updatePlayerStateData(data) {
          this.playerStatus = data.changeType ? PlayerState.ONLINE : PlayerState.OFFLINE;
        } // 更新当局结算结算数据
        ;

        _proto.updateGameSettleData = function updateGameSettleData(data) {} //获取局开始弹窗数据
        ;

        _proto.getGameStartWebviewData = function getGameStartWebviewData() {
          //通知webview调用弹窗
          var title = '第1局玩家';

          if (this.startType == GameType.REGULAR_GAME) {
            title = "第" + this.gameNo + "局玩家";
          } else {
            title = '加赛局玩家';
          }

          var currentLeftDuel = [];
          var currentRightDuel = [];

          for (var i = 0; i < this.currentDuel.length; i++) {
            var user = this.currentDuel[i];

            if (this.anchorUid == user.anchorUid) {
              currentLeftDuel.push({
                uid: user.uid,
                avatar: user.avatar,
                nickname: user.username
              });
            } else {
              currentRightDuel.push({
                uid: user.uid,
                avatar: user.avatar,
                nickname: user.username
              });
            }
          }

          var nextData = null;

          if (this.nextDuel.length > 0) {
            var nextLeftDuel = [];
            var nextRightDuel = [];

            for (var _i2 = 0; _i2 < this.nextDuel.length; _i2++) {
              var _user = this.nextDuel[_i2];

              if (this.anchorUid == _user.anchorUid) {
                nextLeftDuel.push({
                  uid: _user.uid,
                  avatar: _user.avatar,
                  nickname: _user.username
                });
              } else {
                nextRightDuel.push({
                  uid: _user.uid,
                  avatar: _user.avatar,
                  nickname: _user.username
                });
              }
            }

            nextData = {
              // 下一局玩家，没有则不传该属性
              left: nextLeftDuel,
              right: nextRightDuel
            };
          }

          return {
            show: true,
            // 显示还是隐藏
            title: title,
            // 对局名称
            gameTitle: '精打细算抢星星',
            // 游戏title
            gameNo: this.gameNo,
            // 游戏第几局
            curPlayer: {
              // 当前对局玩家
              left: currentLeftDuel,
              right: currentRightDuel
            },
            nextPlayer: nextData
          };
        } //获取游戏角色
        ;

        _proto.getGameRoleName = function getGameRoleName(uid) {
          for (var i = 0; i < this.currentDuel.length; i++) {
            var userInfo = this.currentDuel[i];

            if (uid == userInfo.uid) {
              return userInfo.roleId;
            }
          }

          return "";
        } // 获取玩家角色模型
        ;

        _proto.getPlayerRoleId = function getPlayerRoleId(roleName) {
          roleName = roleName == "" ? '1' : roleName;
          return MODEL_ID[roleName];
        } // 获取玩家角色皮肤id
        ;

        _proto.getPlayerSkinId = function getPlayerSkinId(roleName) {
          roleName = roleName == "" ? '1' : roleName;
          return SKIN_ID[roleName];
        };

        return GameDataMgr;
      }(), _temp)) || _class);

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/GameDataType.ts", ['cc'], function () {
  'use strict';

  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "f87fdDNWGBFeKLIE7QwBBCp", "GameDataType", undefined);

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/SoundMgr.ts", ['cc', './_rollupPluginModLoBabelHelpers.js', './ResMgr.ts'], function (exports) {
  'use strict';

  var cclegacy, _decorator, AudioSourceComponent, sys, error, Component, _defineProperty, _inheritsLoose, _assertThisInitialized, ResMgr;

  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      AudioSourceComponent = module.AudioSourceComponent;
      sys = module.sys;
      error = module.error;
      Component = module.Component;
    }, function (module) {
      _defineProperty = module.defineProperty;
      _inheritsLoose = module.inheritsLoose;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      ResMgr = module.ResMgr;
    }],
    execute: function () {
      var _dec, _class, _class2, _temp;

      cclegacy._RF.push({}, "fd826houZ9FoI/2QiZGivCA", "SoundMgr", undefined);

      var ccclass = _decorator.ccclass,
          property = _decorator.property;
      var EFFECT_NUM = 8;
      var SoundMgr = exports('SoundMgr', (_dec = ccclass("SoundMgr"), _dec(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(SoundMgr, _Component);

        function SoundMgr() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _defineProperty(_assertThisInitialized(_this), "music_mute", 0);

          _defineProperty(_assertThisInitialized(_this), "effect_mute", 0);

          _defineProperty(_assertThisInitialized(_this), "effect_volume", 1);

          _defineProperty(_assertThisInitialized(_this), "music_volume", 1);

          _defineProperty(_assertThisInitialized(_this), "music_as", null);

          _defineProperty(_assertThisInitialized(_this), "effect_as", []);

          _defineProperty(_assertThisInitialized(_this), "cur_as", 0);

          return _this;
        }

        var _proto = SoundMgr.prototype;

        _proto.onLoad = function onLoad() {
          if (SoundMgr.Instance === null) {
            SoundMgr.Instance = this;
          } else {
            this.destroy();
            return;
          }

          this.music_as = this.node.addComponent(AudioSourceComponent);
          this.music_as.volume = this.music_volume;

          if (this.music_mute === 1) {
            this.music_as.volume = 0;
          }

          for (var i = 0; i < EFFECT_NUM; i++) {
            var as = this.node.addComponent(AudioSourceComponent);
            this.effect_as.push(as);
            as.volume = this.effect_volume;

            if (this.effect_mute === 1) {
              as.volume = 0;
            }
          }

          this.cur_as = 0;
        };

        _proto.get_music_volume = function get_music_volume() {
          return this.music_volume;
        };

        _proto.set_music_volume = function set_music_volume(value) {
          this.music_volume = value;
          this.music_as.volume = value;
          sys.localStorage.setItem("music_volume", value.toString());
        };

        _proto.get_music_mute = function get_music_mute() {
          return this.music_mute;
        };

        _proto.set_music_mute = function set_music_mute(b_mute) {
          var value = b_mute ? 1 : 0;

          if (this.music_mute == value) {
            return;
          }

          this.music_mute = value; // this.music_as.mute = b_mute;

          if (this.music_mute === 1) {
            this.music_as.volume = 0;
          } else {
            this.music_as.volume = this.music_volume;
          }

          sys.localStorage.setItem("music_mute", value.toString());
        };

        _proto.get_effect_volume = function get_effect_volume() {
          return this.effect_volume;
        };

        _proto.set_effect_volume = function set_effect_volume(value) {
          for (var i = 0; i < this.effect_as.length; i++) {
            this.effect_as[i].volume = value;
          }

          this.effect_volume = value;
          sys.localStorage.setItem("effect_volume", value.toString());
        };

        _proto.get_effect_mute = function get_effect_mute() {
          return this.effect_mute;
        };

        _proto.set_effect_mute = function set_effect_mute(b_mute) {
          var value = b_mute ? 1 : 0;

          if (this.effect_mute == value) {
            return;
          }

          for (var i = 0; i < this.effect_as.length; i++) {
            // this.effect_as[i].mute = b_mute;
            if (this.effect_mute === 1) {
              this.effect_as[i].volume = 0;
            } else {
              this.effect_as[i].volume = this.effect_volume;
            }
          }

          this.effect_mute = value;
          sys.localStorage.setItem("effect_mute", value.toString());
        };

        _proto.play_music = function play_music(url, loop) {
          if (loop === void 0) {
            loop = false;
          }

          loop = loop ? true : false;
          this.music_as.loop = loop;
          this.music_as.clip = ResMgr.Instance.getAsset(url);

          if (this.music_as.clip) {
            this.music_as.play();
          } else {
            error("music audio clip null: ", url);
          }
        };

        _proto.stop_music = function stop_music() {
          this.music_as.stop();
        };

        _proto.play_effect = function play_effect(url) {
          var as = this.effect_as[this.cur_as];
          this.cur_as++;

          if (this.cur_as >= EFFECT_NUM) {
            this.cur_as = 0;
          }

          as.clip = ResMgr.Instance.getAsset(url);

          if (as.clip) {
            as.play();
          } else {
            error("effect audio clip null: ", url);
          }
        };

        return SoundMgr;
      }(Component), _defineProperty(_class2, "Instance", null), _temp)) || _class));

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/main", ['./pad.ts', './helper.ts', './ResMgr.ts', './UIMgr.ts', './EventMgr.ts', './ResLoading_Ctrl.ts', './GameConstants.ts', './Decimal.ts', './F.ts', './vector.ts', './PoolMgr.ts', './ResourceUtil.ts', './lodash.ts', './AudioManager.ts', './ColliderBase.ts', './MyCylinderCollider.ts', './BridgeMgr.ts', './EffectManager.ts', './GameDataMgr.ts', './UserHeader_Ctrl.ts', './MainUI_Ctrl.ts', './FloorCtrl.ts', './StarFlyingCtrl.ts', './GridHandler.ts', './WebviewMgr.ts', './MesssageMgr.ts', './GameApp.ts', './PlayerCtrl.ts', './PlayerBottomUI_Ctrl.ts', './PCBottomUI_Ctrl.ts', './MyBoxCollider.ts', './ScoreNodeControl.ts', './ColliderConfig.ts', './matrix.ts', './AudienceBottomUI_Ctrl.ts', './migrate-canvas.ts', './EnvColliders.ts', './GameDataType.ts', './SoundMgr.ts', './protobuf-library.min.mjs_cjs=&original=.js', './protobuf-bundles.mjs_cjs=&original=.js', './fetch.umd.mjs_cjs=&original=.js', './protobuf-library.mjs_cjs=&original=.js'], function () {
  'use strict';

  return {
    setters: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
    execute: function () {}
  };
});

(function(r) {
  r('virtual:///prerequisite-imports/main', 'chunks:///_virtual/main'); 
})(function(mid, cid) {
    System.register(mid, [cid], function (_export, _context) {
    return {
        setters: [function(_m) {
            var _exportObj = {};

            for (var _key in _m) {
              if (_key !== "default" && _key !== "__esModule") _exportObj[_key] = _m[_key];
            }
      
            _export(_exportObj);
        }],
        execute: function () { }
    };
    });
});